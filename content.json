{"meta":{"title":"涛哥的博客","subtitle":"欢迎来访","description":"高质量技术博客","author":"JaredTao","url":"https://jaredtao.github.io"},"pages":[],"posts":[{"title":"玩转QtQuick(2)-默认渲染器","slug":"玩转QtQuick(2)-默认渲染器","date":"2021-01-21T05:44:23.000Z","updated":"2021-01-21T13:16:49.545Z","comments":true,"path":"2021/01/21/玩转QtQuick(2)-默认渲染器/","link":"","permalink":"https://jaredtao.github.io/2021/01/21/%E7%8E%A9%E8%BD%ACQtQuick(2)-%E9%BB%98%E8%AE%A4%E6%B8%B2%E6%9F%93%E5%99%A8/","excerpt":"","text":"简介 Qt Quick的默认渲染器 批次渲染 不透明图元 Alpha混合图元 混合3D图元 纹理集 批次渲染的根节点 变换的节点 裁剪 顶点缓冲 抗锯齿 顶点抗锯齿 多采样抗锯齿 性能 可视化 批次可视化 裁剪可视化 变更可视化 OverDraw 过渡绘制可视化 通过QtRHI(硬件渲染接口) 进行渲染 简介这是《玩转QtQuick》系列文章的第二篇，主要是介绍Qt Quick的默认渲染器。 本文会涉及到一些图形学的基本概念，例如：材质、纹理、光栅化、图元等，建议参考相关资料，本文不做进一步的解释。 因为Qt官方文档写的比较全面，所以本文主要是对官方文档的翻译，同时会补充一些个人理解。 翻译主要参考Qt5.15的文档，适当做了一些调整，尽量信达雅，尽量说人话。 下面翻译开始 Qt Quick的默认渲染器本文介绍默认渲染器在内部的工作方式，以方便开发者们以最佳的方式 使用它(编写代码)，包括性能和功能。 通常无需了解渲染器的内部结构，就能够获得良好的性能。 但是，在与场景图集成或弄清楚为什么无法从图形芯片中挤出最大效率时，这可能会有所帮助。 (即使在每个帧都是唯一的并且所有内容都是从头开始上传的情况下，默认渲染器也将表现良好) Qml场景中的Item将填充QSGNode实例树。一旦实例树创建好之后，此树将完整描述如何渲染特定的帧。 它不会包含对任何Item的反向引用，并且在大多数平台上将通过单独的线程进行处理和渲染。 渲染器是“场景图”的自包含部分，它遍历QSGNode树，并使用QSGGeometryNode中定义 的几何形状和QSGMaterial中定义的着色器状态来更新图形状态并生成DrawCall。 如果有需要，可以使用内部的“场景图”后端API完全替换渲染器。 对于希望利用非标准硬件功能的平台供应商来说，这最为有趣。 对于大多数用例，默认渲染器就足够了。 默认渲染器着重于优化渲染的两种主要策略：批量处理调用和在GPU上保留几何图元。 批次渲染传统的2D API (例如QPainter，Cairo或者Context2D)被设计为每帧处理大量单独的DrawCall,而当DrawCall的次数 非常少且状态更改保持在一定水平时，OpenGL和其它硬件加速的API表现最佳。 考虑以下用例： 绘制此列表的最简单方法是逐行进行。 首先，绘制背景。背景是特定颜色的矩形。在OpenGL术语中，这意味着使用一个着色器程序进行纯色填充，设置填充颜色， 设置包含x和y偏移量的转换矩阵，然后使用例如glDrawArrays绘制组成矩形的两个三角形。 接下来绘制图标。用OpenGL术语来说，这意味着使用一个着色器程序来绘制纹理，激活要使用的纹理，设置转换矩阵，启用alpha混合， 然后使用例如glDrawArrays绘制组成图标边界矩形的两个三角形。 行 之间的文本和分隔线遵循类似的模式。 对于列表中的每一行都重复此过程，因此对于更长的列表，OpenGL状态变更和DrawCall所带来的 开销完全超过了使用硬件加速API所能提供的好处。 当每个图元都很大时，此开销可以忽略不计，但是在典型的UI环境中，有许多小项加起来会产生相当大的开销。 默认的“场景图”渲染器也在这些限制内运行，并且会尝试将单个图元合并到批次中，同时保留完全相同的视觉效果。 结果是更少的OpenGL状态变更和最少的DrawCall调用，从而实现了最佳性能。 不透明图元渲染器将不透明图元和需要透明度的图元进行了分类。 通过使用OpenGL的Z缓冲为每一个图元赋予唯一的z值，渲染器可以自由地对不透明图元进行重新排序，而无需考虑 它们在屏幕上的位置以及与它们重叠的其它元素。通过查看每个图元的材质状态，渲染器将创建不透明的批次渲染。 在QtQuick的主要Item中，属于不透明图元的包括不透明颜色的Rectangle和完全不透明的Image,主要是JPEG和BMP格式。 使用不透明图元的另一个好处是，不透明图元不需要启用GL_BLEND，这个操作可能会非常耗性能，尤其是在移动端和嵌入式GPU上。 不透明图元在启用glDepthMask和GL_DEPTH_TEST的情况下以从前到后的方式渲染。在内部进行early-z校验的GPU上，这意味着 片元着色器不需要针对被遮盖的像素或像素块运行。 请注意，渲染器仍需要考虑这些节点，并且顶点着色器仍将为这些图元的每个顶点运行，因此，如果应用程序知道某些东西被完全遮盖，则 最好的办法是设置Item::visible或Item::opacity隐藏它。 Item::z用来控制Item相对于其同级元素的“堆叠顺序”，它与渲染器和OpenGL的z缓冲没有直接关系。 Alpha混合图元一旦绘制了不透明的图元，渲染器将禁用glDepthMask,启用GL_BLEND并以从后到前的方式渲染所有alpha混合图元。 alpha混合图元的批次渲染在渲染器内需要更多的工作，因为重叠的元素需要以正确的顺序进行渲染，以使alpha看起来正确。 仅仅依靠Z缓冲是不够的。渲染器在所有alpha混合图元上进行传递，除了其材质状态外，还将查询其边框，以确定哪些元素 可以批次渲染，哪些元素不能批次。 上图左边的情况，可以在一次DrawCall中渲染蓝色背景，而在另一次DrawCall中渲染两个文本元素，因为这些文本仅与其 同一层的背景重叠。 右边的情况，Item 4的背景覆盖了Item 3的背景，因此每一个背景和文本需要在不同的DrawCall中渲染。 在Z方向上，alpha节点与不透明节点交错，且在可用时触发early-z。同样的，将Item::visible设置为false会快很多。 混合3D图元“场景图”支持伪3D和适当的3D图元。 例如，可以用ShaderEffect来实现“页面卷曲”效果，或者可以使用QSGGeometry和自定义材质来实现凹凸贴图。实现这 些功能时，开发者需要意识到默认渲染器已经使用了深度缓冲区。 渲染器修改了QSGMaterialShader::vertexShader()返回的顶点着色器，并在应用了模型视图和投影矩阵之后压缩了 顶点的z值，然后在z上添加了一个小平移以将其放置在正确的z位置。 压缩时会假定z值在0到1的范围内。 纹理集激活的纹理在OpenGL中是个唯一的状态，这意味着使用不同纹理的多个图元无法批次渲染。因此，Qt Quick“场景图”允许 将多个QSGTexture实例分配为较大纹理的较小子区域，也就是“纹理集”。 纹理集的最大好处是多个QSGTexture实例引用同一个OpenGL纹理实例。这样还可以批量处理带纹理的DrawCall，例如 Qml中的Image,BorderImage,ShaderEffect等，以及C++中的QSGSimpleTextureNode和自定义 的QSGGeometryNode都使用了纹理。 尺寸过大的纹理不会进入纹理集。 纹理集使用带参数QQuickWindow::TextureCanUseAtlas的函数调用QQuickWindow::createTextureFromImage()创建。 纹理集没有范围从0到1的坐标。使用QSGTexture::normalizedTextureSubRect()获取纹理坐标。 “场景图”使用试探法来确定纹理集应该多大以及输入大小的阈值。如果需要不同的值，可以通过设置环境变量 QSG_ATLAS_WIDTH=[width], QSG_ATLAS_HEIGHT=[height]和QSG_ATLAS_SIZE_LIMIT=[size]来覆盖试探法。 对于平台供应商而言，更改这些数值通常是有趣的。 批次渲染的根节点除了将兼容的图元合并到一个批次，默认渲染器还尝试将每帧需要发送到GPU的数据量减到最少。 默认渲染器会标记在一起的子树，并尝试将它们放入单独的批次中。 识别批次后，即可使用顶点缓冲对象将其合并，上传并存储在GPU内存中。 变换的节点每个QtQuick中的Item会往场景树中插入一个QSGTransformNode来管理其x、y坐标、缩放比例。子Item会 附加在此变换节点之下。默认渲染器会跟踪帧之间变换节点的状态，并将查看子树以确定：变换节点作为一个 批次渲染的根节点是否良好。在帧之间变化且具有相当复杂的子树的变换节点可以成为批次渲染的根节点。 批次渲染根节点的子树中QSGGeometryNodes相对于CPU上的根节点已经预先转换过了，然后讲它们上传 并保留在GPU上。当变换发生时，渲染器仅需要更新根节点的矩阵，而无需更新每个单独的节点，从而使列表 和网格滚动非常快。对于连续的帧，只要不添加或删除节点，就可以快速地、不增加消耗地渲染。当新内容 进入子树时，将对其进行重建，但这仍然相当较快。 在Grid或List中滚动时，会有节点添加或者删除，但也总会有一些帧是不变的。 将变换节点 标记为 批次根节点的另一个好处是，它允许渲染器保留树中未更改的部分。 例如：UI由一个List和一行按钮 组成。滚动List并添加或删除Delegate时，UI的其余 部分(一行按钮)保持不变,可以使用存储在GPU上的几何图元进行绘制。 可以使用环境变量QSG_RENDERER_BATCH_NODE_THRESHOLD=[count]和QSG_RENDERER_BATCH_VERTEX_THRESHOLD=[count]来 覆盖要成为批次根节点的转换节点和顶点阈值。覆盖这些标志对平台供应商最有用。 在批次渲染根节点之下，会为每个唯一的材质状态集和几何图元类型创建一个批次节点。 裁剪将Item::clip设置为true时，将创建一个QSGClipNode,其几何形状为矩形。 默认渲染器将通过在OpenGL中使用scissoring来应用此裁剪操作。如果将Item 旋转了非90°角，则使用OpenGL的模版缓冲区。QtQuick的Item仅支持通过Qml启用 矩形的裁剪，“场景图”API和渲染器则支持任何形状的裁剪。 将裁剪应用于子树时，该子树需要使用唯一的OpenGL状态进行渲染。这意味着当Item::clip 为true时，该Item的批次渲染仅限于其子Item。当有许多子级(例如ListView或GridView)或 复杂的子级(例如TextArea)时，这是好事。 应该避免在较小的Item上使用裁剪，因为它会阻止批次渲染。这包括Button上面的Label，TextField和Table中的Delegate。 顶点缓冲每个批次渲染都会使用顶点缓冲区对象(VBO)将其数据存储在GPU上。该顶点缓冲区保留在帧之间，并在“场景图”所 表示的部分发生更改是更新。 默认情况下，渲染器将使用GL_STATIC_DRAW将数据上传到VBO。 通过环境变量QSG_RENDERER_BUFFER_STRATEGY=[strategy]可以选择其它上传策略，有效的策略还包括stream和dynamic。 更改此值对平台供应商最有用。 抗锯齿“场景图”支持两种类型的抗锯齿。 默认情况下，诸如Rectangle和Image之类的图元，将通过沿图元的边缘添加顶点的方式，使 边缘淡化到透明，以实现抗锯齿。我们称此方法为顶点抗锯齿。 如果用户通过QQuickWindow::setFormat()将QSurfaceFormat设置为大于0的值，请求OpenGL多重采样，“场景图”将首选 基于多重采样的抗锯齿(MSAA)。 这两种技术将影响渲染器的内部实现方式，并且具有不同的限制。 通过设置环境变量QSG_ANTIALIASING_METHOD为msaa或者vertex也可以覆盖使用的抗锯齿方法。 即使两个图元的边在数学上相同，顶点抗锯齿也会在相邻图元的边缘之间产生接缝。多重采样抗锯齿则不会如此。 顶点抗锯齿可以使用Item::antialiasing属性启用和禁用单个Item的顶点抗锯齿。在硬件支持的前提下，无论是正常渲染的图元，还是捕获到 帧缓冲区对象中的图元(例如使用ShaderEffectSource),顶点抗锯齿都可以正常运行并产生更高质量的抗锯齿功能。 使用顶点抗锯齿的不利之处在于，每个启用了抗锯齿的图元都必须进行混合。在批次渲染方面，这意味着渲染器需要做更多的工作来确定 图元是否可以进行批次渲染。如果和场景中其它元素重叠，也可能导致更少的批次渲染，从而影响性能。 在低端硬件上，混合操作也可能会非常耗性能。对于覆盖屏幕大部分区域的图像或者圆角矩形，这些图元内部所需要的混合操作数量 可能会导致严重的性能损耗，因为必须混合整个图元。 多采样抗锯齿多采样抗锯齿是一项硬件功能，其中硬件会计算图元中每个像素的覆盖值。一部分硬件可以以非常低的成本进行多次采样，而另一些 硬件需要更多的内存和GPU周期来渲染一帧， 使用多采样可以对许多图元进行抗锯齿（例如圆角矩形和图片），并且在“场景图”中仍然是不透明的。这意味着在创建渲染批次时， 渲染器的工作会更加轻松，并且可以依赖early-z来避免过渡渲染。 使用多重采样抗锯齿时，渲染到帧缓冲区对象中的内容需要额外的扩展以支持帧缓冲区的多重采样。通常是GL_EXT_framebuffer_multisample 和GL_EXT_framebuffer_blit。大多数台式机芯片都具有这些扩展，但是在嵌入式芯片中却很少见。 如果硬件中不提供帧缓冲区多采样，则不会进行多采样抗锯齿，包括ShaderEffectSource。 性能如文章开头所说，不需要了解渲染器的详细信息就能够获得良好的性能。默认渲染器在设计时就针对常见用例进行了优化， 并且在几乎任何情况下都将表现良好。 有效的批次渲染可带来良好的性能，并尽可能少地上传几何图形。通过设置环境变量QSG_RENDERER_DEBUG=render，渲染 器将输出相应的统计信息，包括：批次渲染进行的程度，使用的批次数量，保留的批次及不透明和透明的批次数量等。 追求最佳性能时，应仅在真正需要时上传数据，批次数量应该少于10个，且至少3-4个不透明批次。 默认渲染器不执行任何CPU端的视口裁剪或遮挡检测。如果某些内容不可见，则不应该显示，使用Item::visible将其设置 为false。不添加这样的逻辑的主要原因是，它增加了额外的成本，这也将损害那些表现良好的应用程序。 确保纹理集被使用。除非图像特别大，否则Image和BorderImage 将使用它。C++代码中想要创建纹理集，需在调用 QQuickWindow::createTexture()时传递QQuickWindow::TextureCanUseAtlas参数。通过设置环境变量 QSG_ATLAS_OVERLAY，所有纹理集将被着色,以便在应用程序中轻松识别它们。 尽可能使用不透明图元。不透明图元在渲染器中处理速度更快，在GPU上绘制速度更快。例如，即使每个像素都是不透明的，PNG 文件也会经常具有alpha通道。JPG文件始终是不透明的。当图像提供给QQuickImageProvider或者使用 QQuickWindow::createTextureFromImage()创建图像时，请尽可能使用QImage::Format_RGB32格式。 如前文所示，重叠的复合Item无法批次渲染。 裁剪会中断批次渲染。切勿在表格内的单元格，delegate或者类似的元素中使用裁剪。使用省略代替文本裁剪。 创建一个返回裁剪后图像的QQuickImageProvider，代替图像裁剪。 批次渲染仅适用于16位索引。所有QtQuick内置的Item都使用了16位索引，但是自定义几何图元也可以自由使用32位索引。 一些材质的标志会阻止批次渲染，其中最受限制的一个是QSGMaterial::RequiresFullMatrix,它阻止了所有批次渲染。 具有单色背景的应用程序应使用QQuickWindow::setColor()而不是顶级带颜色的Rectangle。 QQuickWindow::setColor()将在glClear()的调用中使用，这是比较快的。 生成Mipmap的Image不会放在纹理集中，也不会进行批次渲染。 存在一个OpenGL驱动程序相关的Bug：帧缓冲对象(FBO)回读时发生的一些错误会损坏渲染的字形。如果在环境变量 中设置QML_USE_GLYPHCACHE_WORKAROUND，则Qt会在RAM中保留该字形的其它副本。这意味着当渲染以前 未渲染的字形时，性能会稍低，因为Qt通过CPU访问额外的副本。这也意味着字形缓存将使用两倍的内存。渲染质量不受影响。 如果应用程序性能不佳，需要确认瓶颈是否在渲染。此时可以使用探查器Profiler! 设置环境变量QSG_RENDER_TIMING=1 将输出许多有用的时序参数，这些参数可以用来查明问题所在。 可视化为了可视化“场景图”默认渲染器的各个方面，可以将QSG_VISUALIZE环境变量设置为下面每个部分中详细介绍的值其中之一。 下面这段Qml代码提供了一些变量输出的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import QtQuick 2.2Rectangle &#123; width: 200 height: 140 ListView &#123; id: clippedList x: 20 y: 20 width: 70 height: 100 clip: true model: [\"Item A\", \"Item B\", \"Item C\", \"Item D\"] delegate: Rectangle &#123; color: \"lightblue\" width: parent.width height: 25 Text &#123; text: modelData anchors.fill: parent horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter &#125; &#125; &#125; ListView &#123; id: clippedDelegateList x: clippedList.x + clippedList.width + 20 y: 20 width: 70 height: 100 clip: true model: [\"Item A\", \"Item B\", \"Item C\", \"Item D\"] delegate: Rectangle &#123; color: \"lightblue\" width: parent.width height: 25 clip: true Text &#123; text: modelData anchors.fill: parent horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter &#125; &#125; &#125;&#125; 左侧的ListView,我们将其clip属性设置为true。右侧的ListView，我们将每个delegate的clip属性设置为true。 以此来说明裁剪对批次渲染的影响。 这是正常的运行结果 可视化元素不考虑裁剪，并且渲染顺序是任意的。 批次可视化设置环境变量QSG_VISUALIZE为batches可以在渲染器中可视化查看批次。 合并过的批次以纯色渲染，未合并的批次以对角线图案渲染。独立的颜色越少意味着批次分配的越好。 如果未合并的批次中包含许多单独的节点，则是比较糟糕的。 QSG_VISUALIZE=batches 裁剪可视化设置环境变量QSG_VISUALIZE为clip,渲染器会在“场景图”中渲染红色区域来指示裁剪区域。 默认情况下Item不裁剪，因此不会显示裁剪区域。 QSG_VISUALIZE=clip 变更可视化设置环境变量QSG_VISUALIZE为changes,可以在“场景图”中看到变更。“场景图”中的变更以随机颜色的 闪烁叠加显示。图元上的变更以纯色显示，而批次渲染根节点的变更以特定的pattern显示。 OverDraw 过渡绘制可视化设置环境变量QSG_VISUALIZE为overdraw,可以在“场景图”中看到过渡绘制。可视化的3D视图中， 所有过渡绘制的Item会高亮显示。此模式也可以用来检测视口之外的几何图元。不透明的Item以绿色显示， 而半透明的Item以红色显示。视口的边框为蓝色显示。不透明的内容使“场景图”更易于处理，渲染速度更快。 请注意，上面的代码中顶层矩形框Rectangle是多余的，因为窗口也是白色的，在这种情况下渲染矩形框会造成资源浪费。 将其更改为Item会略微提高性能。 QSG_VISUALIZE=overdraw 通过QtRHI(硬件渲染接口) 进行渲染从Qt5.14开始，默认适配层增加了一个选项，可以使用 QtGui模块提供的图形抽象层Qt Rendering Hardware Interface (RHI) 进行渲染。启用后，将不进行OpenGL调用，而是使用抽象层提供的API来渲染“场景图”，然后将其转换为OpenGL, Vulkan,Metal或者Direct3D调用。 通过一次编写着色器代码，编译为SPIR-V,然后转换为适用于各种图形API的语法，实现着色器的统一处理。 要启用此功能，代替直接OpenGL调用，可以通过下面的变量: 环境变量 有效值 描述 QSG_RHI 1 启用通过RHI的渲染。除非被QSG_RHI_BACKEND覆盖，否则将根据平台选择目标图像API。默认值为window平台使用Direct3D 11, MacOS平台使用metal，其它平台使用OpenGL QSG_RHI_BACKEND vulkan,metal,opengl,d2d11 请求使用指定的图形API QSG_INFO 1 与基于OpenGL的渲染路径一样，设置此选项将在初始化Qt Quick“场景图”时启用打印信息。 这对于故障排除非常有用。 QSG_RHI_DEBUG_LAYER 1 在适用的情况下（Vulkan，Direct3D），启用图形API实现的调试或验证层（如果有）。 QSG_RHI_PREFER_SOFTWARE_RENDERER 1 请求使用软光栅化的适配器或物理设备。仅在API支持枚举适配器(Direct3D或Vulkan)时适用，否则会被忽略 希望始终使用单个指定的图形API运行应用程序，也可以通过C++代码来设置。 例如，在构造任何QQuickWindow之前，在main函数的早期进行以下调用将强制使用vulkan 1QQuickWindow::setSceneGraphBackend(QSGRendererInterface::VulkanRhi); 可以查看QSGRendererInterface::GraphicsApi文档。以Rhi结尾的枚举值等价于设置QSG_RHI和QSG_RHI_BACKEND。 除非被QSG_RHI_PREFER_SOFTWARE_RENDERER或特定后端的变量（例如QT_D3D_ADAPTER_INDEX 或者 QT_VK_PHYSICAL_DEVICE_INDEX）覆盖， 否则所有QRhi后端都会选择系统默认的GPU适配器或物理设备。目前没有进一步的适配器相关配置项。","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转QtQuick(1)-SceneGraph场景图简介","slug":"玩转QtQuick(1)-SceneGraph场景图简介","date":"2021-01-20T05:44:23.000Z","updated":"2021-01-21T07:18:25.277Z","comments":true,"path":"2021/01/20/玩转QtQuick(1)-SceneGraph场景图简介/","link":"","permalink":"https://jaredtao.github.io/2021/01/20/%E7%8E%A9%E8%BD%ACQtQuick(1)-SceneGraph%E5%9C%BA%E6%99%AF%E5%9B%BE%E7%AE%80%E4%BB%8B/","excerpt":"","text":"简介 Qt Quick 中的“场景图” Qt Quick “场景图”的结构 Scene Graph API / “场景图”接口 节点 预处理 节点所有权 材质 便捷的节点 “场景图”和渲染 渲染循环 线程渲染循环 非线程渲染循环 (基本渲染循环和窗口渲染循环) 使用QQuickRenderControl自定义渲染控制 “场景图”和原生图形API的混合使用 自定义Item使用QPainter 日志支持 “场景图”后端 简介这是《玩转QtQuick》系列文章的第一篇，主要是介绍Qt Quick Scene Graph “场景图”的关键特性、主要架构及实现原理等等。 (不是QWidget 框架中那个 QGraphicsView哦，是Qt Quick的Scene Graph，不一样) Scene Graph 是QtQuick/Qml所依赖的渲染框架。 本文会涉及到一些图形学的基本概念，例如：材质、纹理、光栅化、图元等，建议参考相关资料，本文不做进一步的解释。 因为Qt官方文档写的比较全面，所以本文主要是对官方文档的翻译，同时会补充一些个人理解。 翻译主要参考Qt5.15的文档，适当做了一些调整，尽量信达雅，尽量说人话。 下面翻译开始 Qt Quick 中的“场景图”Qt Quick 2 使用了专用的“场景图”，然后遍历并通过图形API(例如OpenGL、OpenGL ES、Vulkan、Metal 或Direct 3D)渲染该“场景图”。 将“场景图”用于图形渲染而不是传统的命令式绘图系统(QPainter之类的)，意味着可以在帧之间保留要渲染的场景，并且在渲染开始之前就知道要 渲染的完整图元集。这为许多优化打开了大门，例如：通过批量渲染最大程度减少状态变化、丢弃被遮挡的图元。 再举个具体的例子，假设用户界面包含一个列表，列表有10个节点，其中每个节点都有背景色、图标和文本。 使用传统的绘图技术，这将导致30次DrawCall和30次状态更改。 而“场景图”可以重组原始图元进行渲染，以便在第一次DrawCall中渲染所有背景，第二次DrawCall渲染所有图标，第三次DrawCall渲染所有文本， 从而将DrawCall的总数减少到3次。这样可以显著提高硬件的性能。 “场景图”与Qt Quick 2.0 紧密相关，不能单独使用。“场景图”由QQuickWindow类管理和渲染，自定义Item类型 可以通过调用QQuickItem::updatePaintNode()将其图元添加到“场景图”中。 “场景图”是Item场景的图形表示，它是一个独立的结构，其中包含足以渲染所有节点的信息。 设置完成后，就可以独立于Item状态对其进行操作和渲染。 在许多平台上，“场景图”会在GUI线程准备下一帧状态时，在专用渲染线程上进行渲染。 注意：本文列出的许多信息特定于 Qt “场景图”的内置默认行为。如果使用替代的方案时，并非所有概念都适用。 Qt Quick “场景图”的结构“场景图” 由许多预定义的节点类型组成，每种类型都有专门的用途。 尽管我们将其称为“场景图”，但更精确的定义是“节点树”。 该树根据Qml场景中的QQuickItem类型构建，然后在内部对该场景进行渲染，最终呈现该场景。 “节点” 本身不包含任何 绘制 或者 paint() 虚函数。 “节点树”主要由内建的预定义类型组成，用户也可以添加具有自定义内容的完整子树，包括表示3D模型的子树。 Scene Graph API / “场景图”接口一般是指Qt Quick中 QSG开头的所有类。 节点对用户而言,最重要的节点是QSGGeometryNode。它用来实现自定义图形中的几何形状和材质。 使用QSGGeometry可以定义几何坐标，并描述形状或者图元网格。它可以是直线，矩形，多边形，许多 不连续的矩形或者复杂的3D网格。材质定义如何填充此图形的每个像素。 一个节点可以有任意数量的子节点，并且几何节点将被渲染，以便它们以子顺序出现，且父级位于其子级之后。 注意：这并未说明渲染器中的实际渲染顺序，仅保证视觉顺序。 有效的节点如下: 节点名称 描述 QSGNode “场景图”中所有节点的基类 QSGGeometryNode 用于“场景图”中所有可渲染的内容 QSGClipNode “场景图”中实现“切割”功能 QSGOpacityNode 用来改变透明度 QSGTransformNode 实现旋转、平移、缩放等几何变换 自定义节点通过继承QQuickItem类，重写QQuickItem::updatePaintNode()，并且设置 QQuickItem::ItemHasContents 标志的方式，添加到“场景图”。 警告：至关重要的是, 原生图形（OpenGL，Vulkan，Metal等）操作以及与“场景图”的交互只能在渲染线程中进行，主要 在updatePaintNode()调用期间进行。经验法则是仅在QQuickItem::updatePaintNode()函数内使用带有“QSG”前缀的类。 更多详细的信息，可以参考Qt文档： Scene Graph - Custom Geometry 预处理节点具有虚函数QSGNode::preprocess(),该函数将在渲染“场景图”之前被调用。 节点子类可以设置标志QSGNode::UsePreprocess并重写QSGNode::preprocess()函数以对其节点进行预处理。 例如, 更新纹理的一部分, 或者将贝塞尔曲线划分为当前比例因子的正确细节级别。 节点所有权节点的所有权归创建者，或者设置标志QSGNode::OwnedByParent后归“场景图”。 通常将所有权分配给“场景图”是可取的，因为这样可以简化“场景图”位于GUI线程之外时的清理操作。 材质材质描述如何填充QSGGeometryNode中几何图形的内部。它封装了图形管线中顶点和片元阶段的着色器，并提供了足够的灵活性， 尽管大多数Qt Quick 项目本身仅使用了非常基本的材质，例如纯色和纹理填充。 想要对Qml中Item使用自定义着色的用户，可以直接在Qml中使用ShaderEffect。 下面是一个完整的材质类列表： 材质名称 描述 QSGMaterial 封装了“着色器程序”的渲染状态 QSGMaterialRhiShader 表示独立于图形API的“着色器程序” QSGMaterialShader 表示渲染器中的OpenGL“着色器程序” QSGMaterialType 与QSGMaterial结合用作唯一类型标记 QSGFlatColorMaterial “场景图”中渲染纯色图元的便捷方法 QSGOpaqueTextureMaterial “场景图”中渲染不透明纹理图元的便捷方法 QSGTextureMaterial “场景图”中渲染纹理图元的便捷方法 QSGVertexColorMaterial “场景图”中渲染 逐顶点彩色图元的便捷方法 更多详细的信息，可以参考Qt文档： Scene Graph - Simple Material 便捷的节点“场景图”API是一套 偏底层的接口，专注于性能而不是易用性。 从头开始编写自定义的几何图形和材质，即使是最基本的几何图形和材质，也需要大量的代码。 因此，“场景图”API包含了一些节点类，以使最常用自定义节点的开发更便捷。 节点名称 描述 QSGSimpleRectNode QSGGeometryNode的子类，定义了矩形图元和纯色材质 QSGSimpleTextureNode QSGGeometryNode的子类，定义了矩形图元和纹理材质 “场景图”和渲染“场景图”的渲染发生在QQuickWindow类的内部，并且没有公共API可以访问它。 但是，渲染管线中有一些地方可以让用户附加应用程序代码。 可通过直接调用“场景图”使用的图形API(OpenGL、Vulkan、Metal等)来添加自定义“场景图”内容，或插入 任意渲染命令。插入点由“渲染循环”定义。 有关“场景图”渲染器如何工作的详细说明，可以参考Qt文档: Qt Quick Scene Graph Default Renderer。 渲染循环共有三种渲染循环变体: 基本渲染循环(basic)，窗口渲染循环(windows)和线程渲染循环(threaded)。 其中，基本渲染循环和窗口渲染循环是单线程的，线程渲染循环在专用线程上执行“场景图”渲染。 Qt尝试根据平台及可能使用的图形驱动程序选择合适的渲染循环。如果这不能满足你的需求，或者处于测试的目的，可以使用环境变量 QSG_RENDER_LOOP强制使用指定的渲染循环。要验证使用哪个渲染循环，请启用qt.scenegraph.general日志类别。 注意：线程渲染循环和窗口渲染循环 依赖于图形API实现来进行节流，例如，在OpenGL环境下，“请求交换间隔”为1。 一些图形驱动程序允许用户忽略此设置并将其关闭，而忽略Qt的请求。 在不阻塞“交换缓冲区”操作(或其它位置)的情况下，渲染循环将以尽快的速度运行动画并使CPU 100%运转。 如果已知系统无法提供基于vsync的限制,请通过设置环境变量QSG_RENDER_LOOP = basic使用 基本渲染循环。 线程渲染循环在许多环境中，“场景图”将在专用渲染线程上进行。这样做是为了增加多核处理器的并行度，并更好地利用停顿时间。 这可以显著提高性能，但是与“场景图”进行交互的位置和时间加了一些限制。 以下是关于OpenGL环境下如何使用线程渲染循环的简单概述。除了OpenGL上下文的特定要求外，其它图形API的步骤也是相同的。 Qml场景中发生变化，触发调用QQuickItem::update()， 这可能是动画或者用户操作的结果。 一个 事件会被post到渲染线程来启动新的一帧。 渲染线程准备渲染新的一帧，GUI线程会启动阻塞。 当渲染线程准备新的一帧时，GUI线程调用QQuickItem::updatePolish() 对场景中节点进行最终的“润色”,再渲染它们。 GUI 线程阻塞。 QQuickWindow::beforeSynchronizing()信号发出。应用程序可以对此信号进行直连(Qt::DirectConnection), 以进行QQuickItem::updatePaintNode()之前所需的任何准备工作。 将Qml状态同步到“场景图”中。自上一帧以来，所有已更改的节点上调用QQuickItem::updatePaintNode()函数完成同步。 这是Qml与“场景图”中的节点唯一的交互时机。 GUI线程不再阻塞。 渲染“场景图”： a. QQuickWindow::beforeRendering() 信号发出。应用程序可以直连(Qt::DirectConnection)此信号,来 调用自定义图形API，然后将其可视化渲染在Qml场景之下。 b. 指定了QSGNode::UsePreprocess标志的节点将调用其QSGNode::preprocess()函数。 c. 渲染器处理节点。 d. 渲染器生成状态并记录使用中的图形API的绘制调用。 e. QQuickWindow::afterRendering 信号发出。应用程序可以直连(Qt::DirectConnection)此信号,来 调用自定义图形API，然后将其可视化渲染在Qml场景之上。 f. 新的一帧准备就绪。交换缓冲区(OpenGL)，或者记录当前命令，然后将命令缓冲区提交到图形队列(Vulkan,Metal)。 QQuickWindow::frameSwapped()信号发出。 渲染线程正在渲染时，GUI可以自由地进行动画、处理事件等。 当前默认情况下，线程渲染循环工作在 带opengl32.dll的Windows平台,具有Metal的MacOS平台，移动平台， 具有EGLFS的嵌入式Linux,以及平台无关的Vulkan环境，但这可能会有所改变。 通过在环境变量中设置QSG_RENDER_LOOP=threaded,可以强制使用线程渲染器。 非线程渲染循环 (基本渲染循环和窗口渲染循环)当前默认在使用非线程渲染循环的环境，包括使用ANGLE及非默认opengl32实现的windows平台，使用OpenGL的MacOS， 以及一些特殊驱动的linux环境。 这主要是一种预防措施，因为并非所有的OpenGL驱动和窗口系统的组合都经过测试。同时，诸如ANGLE 或 Mesa llvmpipe之类的实现根本无法在线程渲染中正常运行。因此，对于这些环境，不能使用线程渲染。 在MacOS OpenGL环境下，使用XCode 10 (10.14 SDK) 或更高版本进行构建时不支持线程渲染循环，因为这会选择在 MacOS 10.14上使用“基于图层的视图”。你可以使用XCode 9 (10.13 SDK)进行构建，以避开“基于图层的视图”,这种 情况下，线程渲染循环可以用并且默认会启用。 Metal没有这样的限制。 非线程渲染循环默认在使用ANGLE的windows平台，而“基本渲染循环”用于其它需要非线程渲染循环的平台。 即使使用非线程渲染循环，也应像使用线程渲染循环一样编写代码，否则将使代码不可移植。 以下是非线程渲染循环中帧渲染序列的简化图示。 使用QQuickRenderControl自定义渲染控制使用QQuickRenderControl时，驱动渲染循环的责任将转移到应用程序中。 在这种情况下，不使用内置的渲染循环。 取而代之的是，由应用程序在适当的时候调用 polish synchronize rendering等渲染步骤,实现类似于上述 行为的线程渲染循环或非线程渲染循环。 “场景图”和原生图形API的混合使用“场景图”提供了两种方法，来集成应用程序提供的图形命令： 直接发出OpenGL、Vulkan、Metal等命令，以及在“场景图”中创建纹理化节点。 通过连接到QQuickWindow::beforeRendering 和 QQuickWindow::afterRendering()信号，应用程序可以直接在“场景图” 渲染的同一上下文中进行OpenGL调用。 使用Vulkan或者Metal之类的API，应用程序可以通过QSGRendererInterface来查询本机对象，例如“场景图”的命令缓冲区， 并在认为合适的情况下，向其记录命令。 如信号的名称所示，用户随后可以在Qt Quick “场景图”下方或者上方渲染内容。 以这种方式集成的好处是不需要额外的帧缓冲区或者内存来执行渲染，并且消除了可能昂贵的纹理化步骤。 缺点是Qt Quick 决定何时调用信号，这也是唯一允许OpenGL应用程序绘制的时间点。 Qt提供了一些 “场景图”相关的示例，可在examples中找到: 例子名称 描述 Scene Graph - OpenGL Under QML 示例通过“场景图”的信号使用OpenGL Scene Graph - Direct3D 11 Under QML 示例通过“场景图”的信号使用Direct3D Scene Graph - Metal Under QML 示例通过“场景图”的信号使用Metal Scene Graph - Vulkan Under QML 示例通过“场景图”的信号使用Vulkan 另一个替代方式，是创建一个 QQuickFrameBufferObject (当前仅适用OpenGL)，在这个FBO内部渲染，然后将其 作为纹理显示在“场景图”中。 “Scene Graph - Rendering FBOs” 示例如何完成此操作。 还可以组合多个渲染上下文和多个线程以创建要在“场景图”中显示的内容。 “The Scene Graph - Rendering FBOs in a thread” 示例如何完成此操作。 “Scene Graph - Metal Texture Import”示例直接使用基础API创建和渲染纹理，然后在自定义QQuickItem中的 “场景图”中包装和使用此资源。该示例适用了Metal，但是概念也适用于所有其它图形API。 尽管QQuickFrameBufferObject当前不支持，除OpenGL之外的其它图形API也可以采用这种方法。 警告：当在“场景图”中混合渲染OpenGL内容时，重要的一个点是应用程序不要使OpenGL上下文 处在缓冲区绑定状态，“属性启用”，特殊值处在z缓冲区或模板缓冲区等。这样做会导致无法预测的行为。 警告：自定义渲染代码必须具有多线程意识，它不应该假设应用程序在GUI线程中运行。 自定义Item使用QPainterQQuickItem提供一个子类QQuickPaintedItem,它允许用户使用QPainter渲染内容。 警告: QQuickPaintedItem通过“间接2D 表面”渲染它的内容，“间接2D 表面”可以是软件光栅化，也可以是 “OpenGL帧缓冲对象(FBO)”。这种渲染包含2步操作。第一步是光栅化表面，第二步是渲染表面。 因此，直接使用“场景图” 接口渲染，速度比QQuickPaintedItem快。 日志支持“场景图”支持很多种日志类别。这些日志除了对Qt贡献者有帮助之外，还可用于追踪性能问题和缺陷。 日志类别 描述 qt.scenegraph.time.texture 纹理上传的耗时 qt.scenegraph.time.compilation 编译着色器耗时 qt.scenegraph.time.renderer 渲染器不同步骤耗时 qt.scenegraph.time.renderloop 渲染循环不同阶段耗时 qt.scenegraph.time.glyph 准备字形的距离场耗时 qt.scenegraph.general “场景图”和图形栈中的常规信息 qt.scenegraph.renderloop 渲染循环相关的信息。这个日志模式是Qt开发者主要使用的 旧版QSG_INFO环境变量也可以用。将其设置为非零值将启用qt.scengraph.general类别。 注意：遇到图形问题时，或不确定正在使用哪个渲染循环或图形API时，请至少启用qt.scenegraph.general和qt.rhi,或者 设置QSG_INFO=1的情况下启动应用程序。然后这将在初始化期间将一些基本信息打印到调试输出。 “场景图”后端除了公共API外，“场景图”还具有适配层，该适配层用以实现特定硬件的适配。这是一个未公开的、内部的、私有实现的插件， 可以让硬件适配团队充分利用其硬件。这包括： 自定义纹理； 特别是QQuickWindow::createTextureFromImage的实现以及Image和BorderImage类型使用的纹理的内部表示。 自定义渲染器；适配层使插件可以决定如何遍历和渲染“场景图”，从而有可能针对特定硬件优化渲染 算法或 使用可提高性能的扩展。 许多默认Qml类型的自定义“场景图”实现，包括其文本和字体渲染。 自定义动画驱动程序；允许动画系统连接到低级“垂直同步”的显示设备，以获得平滑的渲染。 自定义渲染循环；可以更好地控制Qml如果处理多个窗口。","categories":[{"name":"玩转QtQuick","slug":"玩转QtQuick","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQtQuick/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"}],"keywords":[{"name":"玩转QtQuick","slug":"玩转QtQuick","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQtQuick/"}]},{"title":"QQuickWidget中文输入法问题的正确解法","slug":"QQuickWidget中文输入法问题的正确解法","date":"2020-11-30T04:44:23.000Z","updated":"2020-11-30T03:50:39.118Z","comments":true,"path":"2020/11/30/QQuickWidget中文输入法问题的正确解法/","link":"","permalink":"https://jaredtao.github.io/2020/11/30/QQuickWidget%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E9%97%AE%E9%A2%98%E7%9A%84%E6%AD%A3%E7%A1%AE%E8%A7%A3%E6%B3%95/","excerpt":"","text":"QQuickWidget中文输入法问题的正确解法 Qt的bug 旧的解法 正确的解法 QQuickWidget中文输入法问题的正确解法本文分享特定问题的解法,用不到的可以忽略。 Qt的bug使用QQuickWidget的时候，遇到过这个问题：界面的TextInput 或者TextEdit, 鼠标点击聚焦后，切换为光标输入状态，此时切换系统中文输入法，会发现无法输入。 (系统任务栏的输入法状态是正确的,界面上输入字符，直接显示英文，无法显示输入法的候选框) 需要把界面切到其它软件，再切换回来，之后就能够输入了。 可以参考Qt官方bug报告: https://bugreports.qt.io/browse/QTBUG-61475 旧的解法这个Bug是2018年报告的，我们当时做项目，也被这个Bug坑到了。 当时我给出了一个弱化版本的解法，原理是在第一次聚焦的时候，清理掉QQuickWidget的焦点。 12345678910111213141516QuickWidget::QuickWidget(QWidget *parent) : QQuickWidget(parent)&#123; ... connect(quickWindow(), &amp;QQuickWindow::activeFocusItemChanged, this, &amp;QuickWidget::onClearFocus); ...&#125;void QuickWidget::onClearFocus()&#123; QQuickItem *pItem = quickWindow()-&gt;activeFocusItem(); if (pItem &amp;&amp; (pItem-&gt;inherits(\"QQuickTextInput\") || pItem-&gt;inherits(\"QQuickTextField\"))) &#123; disconnect(quickWindow(), &amp;QQuickWindow::activeFocusItemChanged, this, &amp;QuickWidget::onClearFocus); QuickWidget::clearFocus(); &#125;&#125; 此方法勉强能用，一些细节上体验不太好。 当时找不到更好的方法，就这样用着了。 正确的解法2020年Qt官方终于派出了资深的专家，在Qt5.15.2中，彻底解决了这个问题。 (看到有不少博客、论坛，还在流传我提供的旧版本，于心不忍) 于是我从新版本里面，提炼出来了代码，给使用旧版本的同学解决此问题。 123456789101112131415161718192021222324252627282930313233QuickWidget::QuickWidget(QWidget *parent) : QQuickWidget(parent)&#123; ...#if QT_VERSION &lt; QT_VERSION_CHECK(5, 15, 2) connect(quickWindow(), &amp;QQuickWindow::focusObjectChanged, this, &amp;QuickWidget::propagateFocusObjectChanged);#endif ...&#125;#if QT_VERSION &lt; QT_VERSION_CHECK(5, 15, 2)bool QuickWidget::event(QEvent *e)&#123; switch (e-&gt;type()) &#123; case QEvent::FocusAboutToChange: return QCoreApplication::sendEvent(quickWindow(), e); default: break; &#125; return Super::event(e);&#125;void QuickWidget::propagateFocusObjectChanged(QObject *focusObject)&#123; if (QApplication::focusObject() != this) return; if (this-&gt;window()-&gt;windowHandle()) &#123; emit this-&gt;window()-&gt;windowHandle()-&gt;focusObjectChanged(focusObject); &#125;&#125;#endif","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qt实用技能","slug":"Qt实用技能","permalink":"https://jaredtao.github.io/tags/Qt%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qml(18)-用户向导","slug":"玩转Qml(18)-用户向导","date":"2020-11-10T05:44:23.000Z","updated":"2020-12-25T10:03:20.961Z","comments":true,"path":"2020/11/10/玩转Qml(18)-用户向导/","link":"","permalink":"https://jaredtao.github.io/2020/11/10/%E7%8E%A9%E8%BD%ACQml(18)-%E7%94%A8%E6%88%B7%E5%90%91%E5%AF%BC/","excerpt":"","text":"简介 效果预览 源码 原理说明 需求说明 原理 Qml对象作用域 QObject对象树 实现 最小改动 获取焦点区域 找到对象 取坐标 向导页 向导组件 向导数据源 简介很多现代化的软件，都会有向导功能，相信大家并不陌生。 “用户向导”的作用，可以帮助新用户快速了解产品，也可以用来提醒用户该如何操作。 这次涛哥就分享一个Qml制作“用户向导”的方案。 效果预览看一下最终效果 在整个软件界面上，覆盖一层遮罩，只保留一部分镂空区域，并用箭头指向镂空区域， 以此,将用户的眼球聚焦到镂空区域，并用适当的文字,说明镂空区域的作用。 这个遮罩层是不能操作到软件界面的，点击任意区域，会转到下一步的向导，直到最后向导退出。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 原理说明向导的实现方案有很多，比如贴图之类的。按不同的需求，方案也不尽相同。 这里先列一个涛哥的需求，再讨论方案才有意义。 需求说明 窗口大小不固定 焦点区域可以是Qml界面中的任意可视组件 向导功能要独立实现，且对已有代码改动最小 原理遮罩的制作，在Qml中就是几个半透明的Rectangle拼在一起，附带一个顶层MouseArea， 将所有鼠标事件都过滤掉，这些都比较简单。 焦点区域才是本文的核心。 Qml对象作用域先来说一下Qml中的对象作用域吧。 如果你阅读过《Qml Book》或者有一定的Qml经验，就知道Qml中的对象，都是通过id相互引用的。 像html / Android，都有类似findElementById这样的接口，获取任意的组件。 在Qml，省去了find这一步，可以直接使用id进行访问。 不过呢，Qml这个id的可访问性，不是任何场景都能直接用的，有诸多情况下，不能直接使用, 例如： 平级的两个组件，它们的子组件不能互相访问到（同一个文件作用域中的除外） 各种View的delegate中的组件id，view外部不能直接访问(这是因为delegate有多个实例的情况下，id不能唯一标识) Loader/Component动态加载后的子组件，不能被直接访问（动态加载，都不知道它什么时候创建，当然不能用它） 诸如此类，都不能直接访问。 扩展说明: 顶层组件的id，可以被所有子组件访问，因此可以用来存储全局对象； Qml单例组件，或者C++上下文对象，也可以被所有子组件访问。 这两种方式也可以用来实现向导功能，有兴趣的读者可自己探索。 QObject对象树Qml中的所有可视化组件，大都是继承于Item，Item的继承关系是 Item ==&gt; QQuickItem ==&gt; QObject 因此呢，Qml中的所有对象，都在一个QObject树上，具有父子关系。 我们可以从任意节点，向上找到根节点，也可以通过根节点的findChild的方式，找到任意一个带objectName的节点。 涛哥的向导方案，便是基于此实现。 实现最小改动在已有的Qml代码中，对于想当作焦点区域的组件，最小改动是增加一个objectName 例如涛哥想把已有的标题栏按钮，作为焦点区域： 改动前: 1234567... SkinBtn &#123; width: 24 height: 24 anchors.verticalCenter: parent.verticalCenter &#125;... 改动后: 12345678... SkinBtn &#123; width: 24 height: 24 anchors.verticalCenter: parent.verticalCenter objectName: \"skinBtn\" &#125;... 获取焦点区域找到对象像前面的组件，只要有了objectName，就可以从任意位置获取到它了 这需要一点C++代码扩展 1234567QQuickItem *getObject(QObject * pRootObject, const QString &amp;targetObjName)&#123; if (!pRootObject) &#123; return nullptr; &#125; return pRootObject-&gt;findChild&lt;QQuickItem *&gt;(targetObjName);&#125; 通过findChild就可以拿到目标对象了, rootObject是根节点，可以从任意节点向上找到， 也可以通过QQmlContex直接获取到。 取坐标找到了对象，就可以计算它的坐标，用于向导了。 为了方便计算，同时避免处理繁杂的父子关系，可以直接把坐标映射到顶层窗口。向导的坐标也以顶层窗口为准即可。 这里进一步封装了C++代码,直接计算好坐标 123456789101112131415161718QRect getItemGeometryToScene(const QString &amp;targetObjName) const&#123; if (!pRootObject) &#123; return &#123;&#125;; &#125; auto pItem = pRootObject-&gt;findChild&lt;QQuickItem *&gt;(targetObjName); if (pItem) &#123; if (pItem-&gt;parentItem()) &#123; //如果有父节点，调用父节点的mapToScene将坐标映射到顶层窗口 auto pos = pItem-&gt;parentItem()-&gt;mapToScene(pItem-&gt;position()); return QRectF &#123; pos.x(), pos.y(), pItem-&gt;width(), pItem-&gt;height() &#125;.toRect(); &#125; else &#123; //如果没有父节点，坐标本身就是相对顶层窗口的 return pItem-&gt;boundingRect().toRect(); &#125; &#125; return &#123;&#125;;&#125; 完整的代码，可以在TaoQuick项目中看到, 封装了一个QuickTool类， 所在路径是TaoQuick/3rdparty/TaoCommon/QuickTool 向导页接下来就是封装一个向导页面了,遮罩围绕在焦点四周，同时带上箭头和文字说明即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175//CusWizardPage.qmlimport QtQuick 2.9import QtQuick.Controls 2.2 import QtGraphicalEffects 1.0import \"..\"import \"../..\"Item &#123; id: pageItem z: 998 anchors.fill: parent property string wizardName property string wizardDescript property string targetObjectName property int pageType: pageTypeDown property color maskColor: \"black\" property real maskOpacity: 0.75 property rect focusRect //int 做枚举，定义4种方向的箭头 readonly property int pageTypeDown: Qt.DownArrow readonly property int pageTypeUp: Qt.UpArrow readonly property int pageTypeLeft: Qt.LeftArrow readonly property int pageTypeRight: Qt.RightArrow Component.onCompleted: &#123; //组件创建时，通过C++扩展，获取到焦点区域坐标 var rect = quickTool.getItemGeometryToScene(targetObjectName) focusRect = rect &#125; //焦点区域的同步item,用来给四周的组件定位 Item &#123; id: focusItem x: focusRect.x y: focusRect.y width: focusRect.width height: focusRect.height RadialGradient &#123; anchors.fill: parent gradient: Gradient &#123; GradientStop &#123; position: 0.0; color: \"transparent\" &#125; GradientStop &#123; position: 0.6; color: maskColor &#125; &#125; opacity: maskOpacity / 2 &#125; &#125; //left Rectangle &#123; x: 0 y: 0 width: focusRect.x height: parent.height color: maskColor opacity: maskOpacity &#125; //right Rectangle &#123; x: focusRect.x + focusRect.width y: 0 width: pageItem.width - x height: parent.height color: maskColor opacity: maskOpacity &#125; //top Rectangle &#123; x: focusRect.x width: focusRect.width y: 0 height: focusRect.y color: maskColor opacity: maskOpacity &#125; //bottom Rectangle &#123; x: focusRect.x width: focusRect.width y: focusRect.y + focusRect.height height: pageItem.height - y color: maskColor opacity: maskOpacity &#125; Row &#123; id: leftRow spacing: 10 visible: pageType === pageTypeLeft z: 998 anchors &#123; left: focusItem.right leftMargin: 5 verticalCenter: focusItem.verticalCenter &#125; CusImage &#123; source: CusConfig.imagePathPrefix + \"arrow-left.png\" anchors.verticalCenter: parent.verticalCenter &#125; &#125; Row &#123; id: rightRow spacing: 10 layoutDirection: Qt.RightToLeft visible: pageType === pageTypeRight z: 998 anchors &#123; right: focusItem.left rightMargin: 5 verticalCenter: focusItem.verticalCenter &#125; CusImage &#123; source: CusConfig.imagePathPrefix + \"arrow-right.png\" anchors.verticalCenter: parent.verticalCenter &#125; &#125; Column &#123; id: downColumn spacing: 10 visible: pageType === pageTypeDown width: 300 z: 998 anchors &#123; bottom: focusItem.top bottomMargin: 5 horizontalCenter: focusItem.horizontalCenter &#125; CusImage &#123; source: CusConfig.imagePathPrefix + \"arrow-down.png\" anchors.horizontalCenter: parent.horizontalCenter &#125; &#125; Column &#123; id: upColumn spacing: 10 visible: pageType === pageTypeUp width: 300 z: 998 anchors &#123; top: focusItem.bottom topMargin: 5 horizontalCenter: focusItem.horizontalCenter &#125; CusImage &#123; source: CusConfig.imagePathPrefix + \"arrow-up.png\" anchors.horizontalCenter: parent.horizontalCenter &#125; &#125; CusLabel &#123; id: wizardDescriptLabel z: 998 text: qsTr(wizardDescript) + CusConfig.transString font.pixelSize: 16 color: \"white\" anchors &#123; horizontalCenter: parent.horizontalCenter verticalCenter: parent.verticalCenter verticalCenterOffset: 50 horizontalCenterOffset: -50 &#125; &#125; CusLabel &#123; z: 998 text: qsTr(wizardName) + CusConfig.transString font.pixelSize: 26 color: \"white\" anchors &#123; left: wizardDescriptLabel.left bottom: wizardDescriptLabel.top bottomMargin: 30 &#125; &#125;&#125; 向导组件向导一般不止一页，而是很多页，这里就封装了一个向导组件。 使用model-view的方式,数据源由外部设置，组件只管按照model去实例化对应的向导页即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//CusWizard.qmlimport QtQuick 2.9import QtQuick.Controls 2.2import \"..\"import \"../..\"Item &#123; id: cusWizardItem signal wizardFinished property string totlaString: qsTr(\"Wizard %1/%2 &gt;\").arg(currentIndex + 1).arg(count) + CusConfig.transString property string operatorString: qsTr(\"Click any area to show next\") + CusConfig.transString MouseArea &#123; anchors.fill: parent hoverEnabled: true onClicked: &#123; currentIndex++ if (currentIndex &gt;= count) &#123; wizardFinished() &#125; &#125; &#125; property var model property int count: model.count property int currentIndex: 0 Repeater &#123; model: cusWizardItem.model delegate: CusWizardPage &#123; anchors.fill: parent visible: index === currentIndex wizardName: model.name wizardDescript: model.descript targetObjectName: model.targetObjectName pageType: model.arrowType &#125; &#125; CusLabel &#123; z: 999 id: centerLabel anchors &#123; centerIn: parent horizontalCenterOffset: 300 verticalCenterOffset: 150 &#125; text: totlaString font.pixelSize: 22 color: \"white\" &#125; CusLabel &#123; z: 999 anchors &#123; centerIn: parent horizontalCenterOffset: 300 verticalCenterOffset: 150 + centerLabel.height &#125; text: operatorString color: \"white\" &#125;&#125; 向导数据源最后来看一下，TaoQuick项目的首页，提供的向导数据model 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869ListModel &#123; id:wizardModel ListElement &#123; name: \"TitleBar\" descript: \"drag change window pos, double click change window state\" targetObjectName: \"blankItem\" arrowType: Qt.UpArrow &#125; ListElement &#123; name: \"Control Buttons\" descript: \"minimize, maximize, normal or close main window\" targetObjectName: \"controlButtonsRow\" arrowType: Qt.UpArrow &#125; ListElement &#123; name: \"Skin Button\" descript: \"switch theme\" targetObjectName: \"skinBtn\" arrowType: Qt.UpArrow &#125; ListElement &#123; name: \"Language Button\" descript: \"switch language\" targetObjectName: \"langBtn\" arrowType: Qt.UpArrow &#125; ListElement &#123; name: \"Left Pane\" descript: \"show content list\" targetObjectName: \"leftPane\" arrowType: Qt.LeftArrow &#125; ListElement &#123; name: \"Drawer Button\" descript: \"show or hide left pane\" targetObjectName: \"menuBtn\" arrowType: Qt.LeftArrow &#125; ListElement &#123; name: \"Search Input\" descript: \"search content\" targetObjectName: \"searchInput\" arrowType: Qt.LeftArrow &#125; ListElement &#123; name: \"Home Button\" descript: \"go back home page\" targetObjectName: \"homeBtn\" arrowType: Qt.LeftArrow &#125; ListElement &#123; name: \"Content List\" descript: \"switch content\" targetObjectName: \"contentListView\" arrowType: Qt.LeftArrow &#125; ListElement &#123; name: \"Content Pane\" descript: \"show current selected content by list\" targetObjectName: \"contentRect\" arrowType: Qt.RightArrow &#125; ListElement &#123; name: \"Tool Buttons\" descript: \"special function buttons such as Wizard, View Source Code and so on\" targetObjectName: \"wizardBtn\" arrowType: Qt.RightArrow &#125;&#125;","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(17)-树组件的定制","slug":"玩转Qml(17)-树组件的定制","date":"2020-06-15T15:44:23.000Z","updated":"2020-12-25T10:03:01.051Z","comments":true,"path":"2020/06/15/玩转Qml(17)-树组件的定制/","link":"","permalink":"https://jaredtao.github.io/2020/06/15/%E7%8E%A9%E8%BD%ACQml(17)-%E6%A0%91%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9A%E5%88%B6/","excerpt":"","text":"简介 发行说明 效果预览 Qt本身的国际化 存在翻译不全的问题 新的方案 关于批量翻译 总结 简介最近遇到一些需求，要在Qt/Qml中开发树结构，并能够导入、导出json格式。 于是我写了一个简易的Demo，并做了一些性能测试。 在这里将源码、实现原理、以及性能测试都记录、分享出来，算是抛砖引玉吧，希望有更多人来讨论、交流。 TreeEdit源码起初的代码在单独的仓库 github https://github.com/jaredtao/TreeEdit gitee镜像 https://gitee.com/jaredtao/Tree 后续会收录到《玩转Qml》配套的开源项目TaoQuick中 github https://github.com/jaredtao/TaoQuick gitee镜像 https://gitee.com/jaredtao/TaoQuick 效果预览看一下最终效果 Qml实现的树结构编辑器, 功能包括: 树结构的缩进节点展开、折叠添加节点删除节点重命名节点搜索导入导出节点属性编辑（完善中） 原理说明数据model的实现，使用C++，继承于QAbstractListModel，并实现rowCount、data等方法。 model本身是List结构的，在此基础上，对model数据进行扩展以模拟树结构，例如增加了 “节点深度”、“是否有子节点”等数据段。 view使用Qml Controls 2中的ListView模拟实现(Controls 1 中的TreeView即将被废弃)。 关键代码model基本model的声明如下: 123456789101112131415161718192021222324252627282930template &lt;typename T&gt;class TaoListModel : public QAbstractListModel &#123;public: //声明父类 using Super = QAbstractListModel; TaoListModel(QObject* parent = nullptr); TaoListModel(const QList&lt;T&gt;&amp; nodeList, QObject* parent = nullptr); const QList&lt;T&gt;&amp; nodeList() const &#123; return m_nodeList; &#125; void setNodeList(const QList&lt;T&gt;&amp; nodeList); int rowCount(const QModelIndex&amp; parent) const override; QVariant data(const QModelIndex&amp; index, int role) const override; bool setData(const QModelIndex&amp; index, const QVariant&amp; value, int role) override; bool insertRows(int row, int count, const QModelIndex&amp; parent = QModelIndex()) override; bool removeRows(int row, int count, const QModelIndex&amp; parent = QModelIndex()) override; Qt::ItemFlags flags(const QModelIndex&amp; index) const override; Qt::DropActions supportedDropActions() const override;protected: QList&lt;T&gt; m_nodeList;&#125;; 其中数据成员使用 QList m_nodeList 存储, 大部分成员函数是对此数据的操作。 Json格式的model声明如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const static QString cDepthKey = QStringLiteral(\"TModel_depth\");const static QString cExpendKey = QStringLiteral(\"TModel_expend\");const static QString cChildrenExpendKey = QStringLiteral(\"TModel_childrenExpend\");const static QString cHasChildendKey = QStringLiteral(\"TModel_hasChildren\");const static QString cParentKey = QStringLiteral(\"TModel_parent\");const static QString cChildrenKey = QStringLiteral(\"TModel_children\");const static QString cRecursionKey = QStringLiteral(\"subType\");const static QStringList cFilterKeyList = &#123; cDepthKey, cExpendKey, cChildrenExpendKey, cHasChildendKey, cParentKey, cChildrenKey &#125;;class TaoJsonTreeModel : public TaoListModel&lt;QJsonObject&gt; &#123; Q_OBJECT Q_PROPERTY(int count READ count NOTIFY countChanged)public: //声明父类 using Super = TaoListModel&lt;QJsonObject&gt;; //从json文件读入数据 Q_INVOKABLE void loadFromJson(const QString&amp; jsonPath, const QString&amp; recursionKey = cRecursionKey); //导出到json文件 Q_INVOKABLE bool saveToJson(const QString&amp; jsonPath, bool compact = false) const; Q_INVOKABLE void clear(); //设置指定节点的数值 Q_INVOKABLE void setNodeValue(int index, const QString &amp;key, const QVariant &amp;value); //在index添加子节点。刷新父级，返回新项index Q_INVOKABLE int addNode(int index, const QJsonObject&amp; json); Q_INVOKABLE int addNode(const QModelIndex&amp; index, const QJsonObject&amp; json) &#123; return addNode(index.row(), json); &#125; //删除。递归删除所有子级,刷新父级 Q_INVOKABLE void remove(int index); Q_INVOKABLE void remove(const QModelIndex&amp; index) &#123; remove(index.row()); &#125; Q_INVOKABLE QList&lt;int&gt; search(const QString&amp; key, const QString&amp; value, Qt::CaseSensitivity cs = Qt::CaseInsensitive) const; //展开子级。只展开一级,不递归 Q_INVOKABLE void expand(int index); Q_INVOKABLE void expand(const QModelIndex&amp; index) &#123; expand(index.row()); &#125; //折叠子级。递归全部子级。 Q_INVOKABLE void collapse(int index); Q_INVOKABLE void collapse(const QModelIndex&amp; index) &#123; collapse(index.row()); &#125; //展开到指定项。递归 Q_INVOKABLE void expandTo(int index); Q_INVOKABLE void expandTo(const QModelIndex&amp; index) &#123; expandTo(index.row()); &#125; //展开全部 Q_INVOKABLE void expandAll(); //折叠全部 Q_INVOKABLE void collapseAll(); int count() const; Q_INVOKABLE QVariant data(int idx, int role = Qt::DisplayRole) const &#123; return Super::data(Super::index(idx), role); &#125;signals: void countChanged(); ...&#125;; TaoJsonTreeModel继承于TaoListModel，并提供大量Q_INVOKABLE函数，以供Qml调用。 viewTreeView的模拟实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586Item &#123; id: root readonly property string __depthKey: \"TModel_depth\" readonly property string __expendKey: \"TModel_expend\" readonly property string __childrenExpendKey: \"TModel_childrenExpend\" readonly property string __hasChildendKey: \"TModel_hasChildren\" readonly property string __parentKey: \"TModel_parent\" readonly property string __childrenKey: \"TModel_children\" ... ListView &#123; id: listView anchors.fill: parent currentIndex: -1 delegate: Rectangle &#123; id: delegateRect width: listView.width color: (listView.currentIndex === index || area.hovered) ? config.normalColor : config.darkerColor // 根据 expaned 判断是否展开，不展开的情况下高度为0 height: model.display[__expendKey] === true ? 35 : 0 // 优化。高度为0时visible为false，不渲染。 visible: height &gt; 0 property alias editable: nameEdit.editable property alias editItem: nameEdit TTextInput &#123; id: nameEdit anchors.verticalCenter: parent.verticalCenter //按深度缩进 x: root.basePadding + model.display[__depthKey] * root.subPadding text: model.display[\"name\"] height: parent.height width: parent.width * 0.8 - x editable: false onTEditFinished: &#123; sourceModel.setNodeValue(index, \"name\", displayText) &#125; &#125; TTransArea &#123; id: area height: parent.height width: parent.width - controlIcon.x hoverEnabled: true acceptedButtons: Qt.LeftButton | Qt.RightButton onPressed: &#123; //单击时切换当前选中项 if (listView.currentIndex !== index) &#123; listView.currentIndex = index; &#125; else &#123; listView.currentIndex = -1; &#125; &#125; onTDoubleClicked: &#123; //双击进入编辑状态 delegateRect.editable = true; nameEdit.forceActiveFocus() nameEdit.ensureVisible(0) &#125; &#125; Image &#123; id: controlIcon anchors &#123; verticalCenter: parent.verticalCenter right: parent.right rightMargin: 20 &#125; //有子节点时，显示小图标 visible: model.display[__hasChildendKey] source: model.display[__childrenExpendKey] ? \"qrc:/img/collapse.png\" : \"qrc:/img/expand.png\" MouseArea &#123; anchors.fill: parent onClicked: &#123; //点击小图标时，切换折叠、展开的状态 if (model.display[__hasChildendKey]) &#123; if( true === model.display[__childrenExpendKey]) &#123; collapse(index) &#125; else &#123; expand(index) &#125; &#125; &#125; &#125; &#125; &#125; &#125; ...&#125; model层并没有扩展role，而是在data函数的role为display时直接返回json数据， 所以delegate中统一使用model.display[xxx]的方式访问数据。 性能测试测试环境CPU: Intel i5-8400 2.8GHz 六核 内存: 16GB OS: Windows10 1909 Qt: 5.12.6 编译器: msvc 2017 x64 测试框架: QTest 测试方法数据生成使用node表示根节点的数量，depth表示每个根节点下面嵌套节点的层数。 例如： node 等于 100， depth 等于10，则数据如下： 顶层有100个节点，每个节点下面再嵌套10层，共计节点 100 + 100 * 10 = 1100. 生成json数据的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566...//单元测试类class LoadTest : public QObject &#123; Q_OBJECTpublic: LoadTest(); ~LoadTest(); static void genJson(const QPoint&amp; point); ...//私有槽函数会被QTest调用private slots: //初始化 void initTestCase(); //清理 void cleanupTestCase(); //测试导入 void test_load(); //测试导入前，准备数据 void test_load_data(); //测试导出 void test_save(); //测试导出前，准备数据 void test_save_data();&#125;;...//节点最大值const int nodeMax = 10000;//嵌套深度最大值const int depthMax = 100;void LoadTest::genJson(const QPoint&amp; point)&#123; using namespace TaoCommon; int node = point.x(); int depth = point.y(); QJsonArray arr; for (int i = 0; i &lt; node; ++i) &#123; QJsonObject obj; obj[\"name\"] = QString(\"node_%1\").arg(i); QVector&lt;QJsonArray&gt; childrenArr = &#123; depth, QJsonArray &#123; QJsonObject &#123;&#125; &#125; &#125;; //最后一个节点，嵌套层级最深的。 childrenArr[depth - 1][0] = QJsonObject &#123; &#123; \"name\", QString(\"node_%1_%2\").arg(i).arg(depth - 1) &#125; &#125;; //从后往前倒推。 for (int j = depth - 2; j &gt;= 0; --j) &#123; childrenArr[j][0] = QJsonObject &#123; &#123; cRecursionKey, childrenArr[j + 1] &#125;, &#123; \"name\", QString(\"node_%1_%2\").arg(i).arg(j) &#125; &#125;; &#125; obj[cRecursionKey] = childrenArr[0]; arr.append(obj); &#125; writeJsonFile(qApp-&gt;applicationDirPath() + QString(\"/%1_%2.json\").arg(node).arg(depth), arr);&#125;void LoadTest::initTestCase()&#123; QList&lt;QPoint&gt; list; for (int i = 1; i &lt;= nodeMax; i *= 10) &#123; for (int j = 1; j &lt;= depthMax; j *= 10) &#123; list.append(&#123; i, j &#125;); &#125; &#125; auto result = QtConcurrent::map(list, &amp;LoadTest::genJson); result.waitForFinished();&#125; 初始化函数initTestCase中，组织了一个QList，然后使用QtConcurrent::map并发调用genJson函数，生成数据json文件。 node和depth每次扩大10倍。 经过测试，嵌套层数在100以上时，Qt可能会崩溃。要么是QJsonDocument无法解析，要么是Qml挂掉。所以不使用100以上的嵌套级别。 测试过程QTest十分好用，简单易上手，参考帮助文件即可 例如测试加载的代码如下: 123456789101112131415161718192021222324252627282930void LoadTest::prepareData()&#123; //添加两列数据 QTest::addColumn&lt;int&gt;(\"node\"); QTest::addColumn&lt;int&gt;(\"depth\"); //添加行 for (int i = 1; i &lt;= nodeMax; i *= 10) &#123; for (int j = 1; j &lt;= depthMax; j *= 10) &#123; QTest::newRow(QString(\"%1_%2\").arg(i).arg(j).toStdString().c_str()) &lt;&lt; i &lt;&lt; j; &#125; &#125;&#125;void LoadTest::test_load_data()&#123; //准备数据 prepareData();&#125;void LoadTest::test_load()&#123; using namespace TaoCommon; //取数据 QFETCH(int, node); QFETCH(int, depth); TaoJsonTreeModel model; //性能测试 QBENCHMARK &#123; model.loadFromJson(qApp-&gt;applicationDirPath() + QString(\"/%1_%2.json\").arg(node).arg(depth)); &#125;&#125; 测试结果 一秒内最多可以加载的数据量在十万级别，包括 10000 x 10耗时在 386毫秒，1000 x 100 耗时在671毫秒。","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qt(15)-操控Web小车案例","slug":"玩转Qt(15)-Web操控小车案例","date":"2020-03-12T11:44:23.000Z","updated":"2020-12-25T10:09:36.330Z","comments":true,"path":"2020/03/12/玩转Qt(15)-Web操控小车案例/","link":"","permalink":"https://jaredtao.github.io/2020/03/12/%E7%8E%A9%E8%BD%ACQt(15)-Web%E6%93%8D%E6%8E%A7%E5%B0%8F%E8%BD%A6%E6%A1%88%E4%BE%8B/","excerpt":"","text":"前言 简介 Qt与Web嵌套 MiniBrowser 半透明测试 渲染原理 小结 Qt与Web分离 Qt小车 原版小车 改进小车 必要的知识 WebSocket和 QWebSocket WebChannel Qt启动系统浏览器 Qt的OpenUrl C# .net的 Process::Start Web控制端 目录结构 Html TypeScript TypeScript中的QObject TypeScript中连接websocket TypeScript中的QWebChannel TypeScript中使用javaScript 改进qwebchannel.js以支持await QObject to Typescript 前言这次讨论Qt与Web混合开发相关技术。 这类技术存在适用场景，例如：Qt项目使用Web大量现成的组件/方案做功能扩展， Qt项目中性能无关/频繁更新迭代的页面用html单独实现，Qt项目提供Web形式的SDK给 用户做二次开发等等，或者是Web开发人员齐全而Qt/C++人手不足，此类非技术问题， 都可以使用Qt + Web混合开发。 (不适用的请忽略本文) 简介上次的文章《Qt与Web混合开发》，讨论了Qt与Web混合开发相关技术。 这次通过一个web控制小车的案例，继续讨论相关技术。 本文会先介绍Qt与Web嵌套使用,再介绍Qt与Web分开使用，之后着重讨论分开使用 的一些实现细节，特别是WebChannel通信、WebChannel在Web/typescript中的使用。 Qt与Web嵌套MiniBrowser这里以Qt官方的例子MiniBrowser来说明吧。 打开方式如下： 运行效果如下： 这个例子是在Qml中嵌套了WebView。 半透明测试涛哥做了一个简单的半透明测试。 增加了两个半透明的小方块，蓝色的在WebView上面，红色的在WebView下面。 运行效果也是正确的: 代码是这样的： 红色框中是我增加的代码。 为什么要做半透明测试呢？根据以往的经验,不同渲染方式的两种窗口/组件嵌套在一起，总会出现透明失效之类的问题，例如 qml与Widget嵌套。 渲染原理涛哥翻了一下Qt源码，了解到渲染的实现方式，Windows平台大致如下： chromium在单独的进程处理html渲染，并将渲染结果存储在共享内存中；主窗口在需要重绘的时候，从共享内存中获取内容并渲染。 小结这里的WebView内部封装好了WebEngine，其本身也是一个Item，就和普通的Qml一样，属性绑定、js function都可以正常使用，暂时不深入讨论了。 Qt与Web分离Qt与Web分离，就是字面意思，Web在单独的浏览器或者App中运行，不和Qt堆在一起。两者通过socket进行通信。 这里用我自己做的例子来说明吧。 先看看效果： 左边是Qt实现的一个简易小车，可以前进和转向。右边是Html5实现的控制端，控制左边的小车。 源码在github上: https://github.com/jaredtao/QtWeb Qt小车原版小车小车来自Qt的D-Bus Remote Controller 例子 原版的例子，实现了通过QDBus 跨进程 控制小车。 (吐槽：这是一个古老的例子,使用了GraphicsView 和QDBus) (知识拓展1： DBus是unix系统特有的一种进程间通信机制，使用有些复杂。Qt对DBus机制进行了封装/简化，即QDBus模块， 通过xml文件的配置后，把DBus的使用转换成了信号-槽的形式。类似于现在的Qt Remote Objects) (知识拓展2： Windows本身不支持DBus，网上有socket模拟DBus的方案。参考: https://www.freedesktop.org/wiki/Software/dbus/) 改进小车我做了一些修改，主要如下： 去掉了DBus 增加控制按钮 增加WebChannel 修改Car的实现，导出一些属性和函数。 注册Car到WebChannel 这里贴一些关键代码 Car的头文件： 其中要说明的是： speed和angle属性具备 读、写、change信号。 还有加速、减速、左转、右转四个公开的槽函数。 必要的知识WebSocket和 QWebSocketWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。 WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 Qt为我们封装好了WebSocket，即QWebSocket和QWebSocketServer，简单易用。 如果你了解socket编程，就看作TCP好了；如果不了解，请先去补充一下知识吧。 WebChannel按涛哥的理解，WebChannel是在socket上建立的一种通信协议，这个协议的作用是把QObject暴露给远端的HTML。 大致使用流程： Qt程序中，要暴露的QObject全部注册到WebChannel。 Qt程序中，启动一个WebSocketServer，等待Html的连接。 Html加载好qwebchannel.js文件, 然后去连接WebSocket。 连接建立以后，Qt程序中，由WebChannel接手这个WebSocket，按协议将QObject的各种“元数据”传输给远端Html。 Html端，qwebchannel.js处理WebSocket收到的各种“元数据”，用js的Object 动态创建出对应的QObject。 到这里两边算是做好了准备，可以互相调用了。 Qt端QObject数据变化只要发出信号，就会由WebChannel自动通知Web端； Web端可以主动调用QObject的public的 invok函数、槽函数，以及读、写属性。 Qt启动系统浏览器在使用WebChannel的时候，Qt端建立了WebSocketServer，之后要把server的路径(例如：ws://127.0.0.1:12345)告诉Html。 一般就是在打开Html的时候带上Query参数，例如： F:\\QtWeb\\index.html?webChannelBaseUrl=ws://127.0.0.1:12345 Qt的OpenUrlQml中有 Qt.openUrlExternally, C++ 中有 QDesktopServices::openUrl，本质一样， 都可以打开一个本地的html网页。 其在Windows平台的底层实现是Win32 API。这里有个Win32 API的缺陷，传Query参数会被丢掉。 C# .net的 Process::Start涛哥找到了替代的方案: .net framework / .net core有个启动进程的函数： System.Diagnostics.Process::Start, 可以调用浏览器并传query参数 123456&#x2F;&#x2F;C# 启动chromeSystem.Diagnostics.Process.Start(&#39;chrome&#39;, &#39;F:\\QtWeb\\index.html?webChannelBaseUrl&#x3D;ws:&#x2F;&#x2F;127.0.0.1:12345&#39;);&#x2F;&#x2F;C# 启动firefoxSystem.Diagnostics.Process.Start(&#39;firefox&#39;, &#39;F:\\QtWeb\\index.html?webChannelBaseUrl&#x3D;ws:&#x2F;&#x2F;127.0.0.1:12345&#39;);&#x2F;&#x2F;C# 启动IESystem.Diagnostics.Process.Start(&#39;IExplore&#39;, &#39;F:\\QtWeb\\index.html?webChannelBaseUrl&#x3D;ws:&#x2F;&#x2F;127.0.0.1:12345&#39;); Qt中直接写C#当然不太好，不过呢，Win7/Win10 系统都带有Powershell，而powershell依赖于.net framework, 我们可以调用powershell来间接使用.net framework。 所以有了下面的代码： 12345678...QString psCmd = QString(\"powershell -noprofile -command \\\"[void][System.Diagnostics.Process]::Start('%1', '%2')\\\"\").arg(browser).arg(url.toString());bool ok = QProcess::startDetached(psCmd);qWarning() &lt;&lt; psCmd;if (!ok) &#123; qWarning() &lt;&lt; \"failed\";&#125;... 结果完美运行。 Web控制端目录结构Web端就按照Web常规流程开发。 Web部分的源码也在前文提到的github仓库，子路径是QtWeb\\WebChannelCar\\Web 如下是Web部分的目录结构： 脚本用typescript，包管理用npm，打包用webpack，编辑器用vs code, 都中规中矩。 内容比较简单，暂时不需要前端框架，手(复)写(制)的html和css。 Htmlhtml部分比较简单 12345678910111213141516171819202122232425262728293031//index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; chartset=utf-8\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"../style/style.css\" /&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"../style/layout.css\" /&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"up\" class=\"green button\"&gt;加速&lt;/button&gt; &lt;button id=\"down\" class=\"red button\"&gt;减速&lt;/button&gt; &lt;button id=\"left\" class=\"blue button\"&gt;左转&lt;/button&gt; &lt;button id=\"right\" class=\"blue button\"&gt;右转&lt;/button&gt; &lt;img id=\"img\" src=\"../img/disconnected.svg\" /&gt; &lt;div&gt; &lt;div&gt; &lt;label&gt;速度: &lt;/label&gt; &lt;label id=\"speed\"&gt;0&lt;/label&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;角度: &lt;/label&gt; &lt;label id=\"angle\"&gt;0&lt;/label&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"../out/main.js\"&gt;&lt;/script&gt;&lt;/html&gt; 样式和布局全靠css,这里就不贴了。 TypeScript脚本部分需要细说了。 src文件夹为全部脚本，目录结构如下： TypeScript中的QObject从main开始, 加点注释： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//main.tsimport WebChannelCore from \"./webchannelCore\";//window加载时回调，入口window.onload = () =&gt; &#123; //初始化WebChannel，传参为两个回调，分别对应WebChannel建立连接和连接断开。 WebChannelCore.initialize(onInit, onUninit);&#125;//WebChannel建立连接的处理function onInit() &#123; //换图标 (window as any).document.getElementById(\"img\").src = \"../img/connected.svg\"; //获取QObject对象 let car = WebChannelCore.SDK.car; //取dom树上的组件 let upBtn = (window as any).document.getElementById(\"up\"); let downBtn = (window as any).document.getElementById(\"down\"); let leftBtn = (window as any).document.getElementById(\"left\"); let rightBtn = (window as any).document.getElementById(\"right\"); let speedLabel = (window as any).document.getElementById(\"speed\"); let angleLabel = (window as any).document.getElementById(\"angle\"); //绑定按钮点击事件 upBtn.onclick = () =&gt; &#123; //调用QObject的接口 car.accelerate(); &#125; downBtn.onclick = () =&gt; &#123; car.decelerate(); &#125; leftBtn.onclick = () =&gt; &#123; car.turnLeft(); &#125; rightBtn.onclick = () =&gt; &#123; car.turnRight(); &#125; //QObject的信号连接到js 回调 car.speedChanged.connect(onSpeedChanged); car.angleChanged.connect(onAngleChanged);&#125;//WebChannel断开连接的处理function onUninit() &#123; //换图标 (window as any).document.getElementById(\"img\").src = \"../img/disconnected.svg\";&#125;//异步更新 speedasync function onSpeedChanged() &#123; let speedLabel = (window as any).document.getElementById(\"speed\"); let car = WebChannelCore.SDK.car; //获取speed，异步等待。 //注意这里改造过qwebchannel.js，才能使用await。 speedLabel.textContent = await car.getSpeed();&#125;//异步更新 angleasync function onAngleChanged() &#123; let angleLabel = (window as any).document.getElementById(\"angle\"); let car = WebChannelCore.SDK.car; //获取angle，异步等待。 //注意这里改造过qwebchannel.js，才能使用await。 angleLabel.textContent = await car.getAngle();&#125; 可以看到我们从WebChannelCore.SDK 中获取了一个car对象，之后就当作QObject来用了，包括调用它的函数、连接change信号、访问属性等。 这一切都得益于WebSocket/WebChannel. TypeScript中连接websocket接下来看一下WebChannelCore的实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//WebChannelCore.tsimport &#123; QWebChannel &#125; from './qwebchannel';type callback = () =&gt; void;export default class WebChannelCore &#123; public static SDK: any = undefined; private static connectedCb: callback; private static disconnectedCb: callback; private static socket: WebSocket; //初始化函数 public static initialize(connectedCb: callback = () =&gt; &#123; &#125;, disconnectedCb: callback = () =&gt; &#123; &#125;) &#123; if (WebChannelCore.SDK != undefined) &#123; return; &#125; //保存两个回调 WebChannelCore.connectedCb = connectedCb; WebChannelCore.disconnectedCb = disconnectedCb; try &#123; //调用link，并传入两个回调参数 WebChannelCore.link( (socket) =&gt; &#123; //socket连接成功时，创建QWebChannel QWebChannel(socket, (channel: any) =&gt; &#123; WebChannelCore.SDK = channel.objects; WebChannelCore.connectedCb(); &#125;); &#125; , (error) =&gt; &#123; //socket出错 console.log(\"socket error\", error); WebChannelCore.disconnectedCb(); &#125;); &#125; catch (error) &#123; console.log(\"socket exception:\", error); WebChannelCore.disconnectedCb(); WebChannelCore.SDK = undefined; &#125; &#125; private static link(resolve: (socket: WebSocket) =&gt; void, reject: (error: Event | CloseEvent) =&gt; void) &#123; //获取Query参数中的websocket地址 let baseUrl = \"ws://localhost:12345\"; if (window.location.search != \"\") &#123; baseUrl = (/[?&amp;]webChannelBaseUrl=([A-Za-z0-9\\-:/\\.]+)/.exec(window.location.search)![1]); &#125; console.log(\"Connectiong to WebSocket server at: \", baseUrl); //创建WebSocket let socket = new WebSocket(baseUrl); WebChannelCore.socket = socket; //WebSocket的事件处理 socket.onopen = () =&gt; &#123; resolve(socket); &#125;; socket.onerror = (error) =&gt; &#123; reject(error); &#125;; socket.onclose = (error) =&gt; &#123; reject(error); &#125;; &#125;&#125;(window as any).SDK = WebChannelCore.SDK; 这部分代码不复杂，主要是连接WebSocket，连接好之后创建一个QWebChannel。 TypeScript中的QWebChannel观察仔细的同学会发现，src文件夹下面，没有叫‘qwebchannel.ts’的文件，而是‘qwebchannel.js’,和一个‘qwebchannel.d.ts’ 这涉及到另一个话题： TypeScript中使用javaScript‘qwebchannel.js’是Qt官方提供的，在js中用足够了。 而我们这里是用TypeScript，按照TypeScript的规则，直接引入js是不行的，需要一个声明文件 xxx.d.ts 所以我们增加了一个qwebchannel.d.ts文件。 （熟悉C/C++的同学，可以把d.ts看作typescript的头文件） 内容如下： 12//qwebchannel.d.tsexport declare function QWebChannel(transport: any, initCallback: Function): void; 只是导出了一个函数。 这个函数的实现在‘qwebchannel.js’中: 1234567891011121314151617181920212223242526272829//qwebchannel.js\"use strict\";var QWebChannelMessageTypes = &#123; signal: 1, propertyUpdate: 2, init: 3, idle: 4, debug: 5, invokeMethod: 6, connectToSignal: 7, disconnectFromSignal: 8, setProperty: 9, response: 10,&#125;;var QWebChannel = function(transport, initCallback)&#123; if (typeof transport !== \"object\" || typeof transport.send !== \"function\") &#123; console.error(\"The QWebChannel expects a transport object with a send function and onmessage callback property.\" + \" Given is: transport: \" + typeof(transport) + \", transport.send: \" + typeof(transport.send)); return; &#125; ...&#125;function QObject(name, data, webChannel)&#123; ...&#125; 这个代码比较长，就不全部贴出来了。主要实现了两个类，QWebChannel和QObject。 QWebChannel就是用来接管websocket的，而QObject是用js Object模拟的 Qt的 QObject。 这一块不细说了，感兴趣的同学可以自己去研究源码。 改进qwebchannel.js以支持awaitQt默认的qwebchannel.js在实际使用过程中，有些不好的地方，就是函数的返回值不是直接返回，而是要在回调函数中获取。 比如car.getAngle要这样用： 1234let angle = 0;car.getAngle((value:number)=&gt; &#123; angle = value;&#125;); 我们的实际项目中，有大量带返回值的api，这样的用法每次都嵌套一个回调函数，很不友好，容易造成回调地狱。 我们同事的解决方案是，在typescript中把这些api再用Promise封装一层，外面用await调用。 例如这样封装一层： 1234567function getAngle () &#123; return new Promise((resolve)=&gt;&#123; car.getAngle((value:number)=&gt; &#123; resolve(value); &#125;); &#125;);&#125; 使用和前面的代码一样： 12345678//异步更新 angleasync function onAngleChanged() &#123; let angleLabel = (window as any).document.getElementById(\"angle\"); let car = WebChannelCore.SDK.car; //获取angle，异步等待。 //注意这里改造过qwebchannel.js，才能使用await。 angleLabel.textContent = await car.getAngle();&#125; 这种解决方案规避了回调地狱，但是工作量增加了。 涛哥思考良久，稍微改造一下qwebchannel.js，自动把Promise加进去，也不需要再额外封装了。 改动如下： QObject to Typescript我们在Qt 程序中写了QObject，然后暴露给了ts。 在ts这边，一般也需要提供一个声明文件，明确有哪些api可用。 例如我们的car声明： 12345678910111213//CarObject.tsdeclare class Car &#123; get speed():number; set speed(value:number); get angle():number; set angle(vlaue:number); public accelerate():void; public decelerate():void; public turnLeft():void; public turnRight():void;&#125; 这里涛哥写了一个小工具，能够解析Qt中的QObject，并生成对应的ts文件。 当然还是实验阶段，有兴趣的也可以关注一下 https://github.com/jaredtao/QObject2TypeScript","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qt实用技能","slug":"Qt实用技能","permalink":"https://jaredtao.github.io/tags/Qt%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qt(14)-Qt与Web混合开发","slug":"玩转Qt(14)-Qt与Web混合开发","date":"2020-03-04T11:44:23.000Z","updated":"2020-12-25T10:09:15.858Z","comments":true,"path":"2020/03/04/玩转Qt(14)-Qt与Web混合开发/","link":"","permalink":"https://jaredtao.github.io/2020/03/04/%E7%8E%A9%E8%BD%ACQt(14)-Qt%E4%B8%8EWeb%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/","excerpt":"","text":"前言 简介 Qt的Web方案 Quick WebGL Stream Qt WebAssembly Qt WebEngine/WebView QtWebEngine的更新情况 WebEngine的架构 WebEngine的平台要求 Windows MacOS Linux WebView WebEngine的使用 WebEngine Widget最简Demo 源代码 运行结果 最小发布包 WebEngine Qml最简Demo 源码 运行结果 最小发布包 前言这次讨论Qt与Web混合开发相关技术。 这类技术存在适用场景，例如：Qt项目使用Web大量现成的组件/方案做功能扩展， Qt项目中性能无关/频繁更新迭代的页面用html单独实现，Qt项目提供Web形式的SDK给 用户做二次开发等等，或者是Web开发人员齐全而Qt/C++人手不足，此类非技术问题， 都可以使用Qt + Web混合开发。 (不适用的请忽略本文) 简介这篇文章，会先整体介绍一下Qt的各种Web方案,再提供简单的Demo，并做一些简要的说明。 之后的一篇文章，会通过一个Web控制Qt端小车的案例，来做进一步讨论。 Qt的Web方案Qt提供的Web方案主要包括 WebEngine/WebView、Quick WebGL Stream、QtWebAssembly三种。 Quick WebGL Stream可以参考Qt官方的WebGL Stream介绍文档 https://resources.qt.io/cn/qt-quick-webgl-release-512​resources.qt.ioWebGL Stream在5.12中正式发布，其本质是一种通信技术，将已有的QtQuick程序中渲染指令和数据，通过socket传输给Web端，由WebGL实现界面渲染。 其使用方式非常的简单，无需修改源码，应用程序启动时，带上端口参数，例如： ./your-qt-application -platform webgl:port=8998(相当于应用程序变成了一个服务器端程序) 这样程序就在后端运行，看不到界面了，之后浏览器打开本地网址 localhost:8998 或者内网地址/映射后的公网地址，就能在浏览器中看到程序页面。 WebGL Stream的应用不多，Qt官方给的案例是：欧洲某工厂的大量传感器监测设备，都以WebGL Stream的方式运行Qt 程序，本身都不带显卡和显示器，而在控制中心的显卡/显示器上，通过Web打开网页的方式，查看每个设备的运行状况。因此节约了大量显卡/显示器的成本。类比于网吧的无硬盘系统。 涛哥相信，未来结合5G技术会有不错的应用场景。 Qt WebAssemblyQt WebAssembly技术，在5.13中正式发布。本质是把Qt程序编译成浏览器支持的二进制文件，由浏览器加载运行。 一方面可以将现有的Qt程序编译成Web，另一方面可以用Qt/C++来弥补Web程序的性能短板。 Qt WebAssembly在使用细节上还有一些坑的地方，需要踩一踩。后续我再写文章吧。 Qt WebEngine/WebViewQt提供了WebEngine模块以支持Web功能。 Qt WebEngine基于google的开源浏览器chromium实现，类似的项目还有cef、miniblink等等。 QtWebEngine可以看作是一个完整的chromium浏览器。 （WebView是同类的方案，稍微有些区别。后文再说。） QtWebEngine的更新情况浏览器技术十分的庞大，这里先不深入展开，先来关注一下Qt WebEngine对chromium的跟进情况。 数据来源于Qt wiki，Qt每个版本的change log Qt版本 chromium后端 chromium安全更新 5.9.0 56 5.9.1 - 59.0.3071.104 5.9.2 - 61.0.3163.79 5.9.3 - 62.0.3202.89 5.9.4 - 63.0.3239.132 5.9.5 - 65.0.3325.146 5.9.6 - 66.0.3359.170 5.9.7 - 69.0.3497.113 5.9.8 - 72.0.3626.121 5.9.9 - 78.0.3904.108 5.12.0 69 5.12.1 71.0.3578.94 5.12.2 72.0.3626.121 5.12.3 73.0.3683.75 5.12.4 74.0.3729.157 5.12.5 76.0.3809.87 5.12.6 77.0.3865.120 5.12.7 79.0.3945.130 5.14.0 77 5.14.1 79.0.3945.117 可以看到Qt在WebEngine模块，一直持续跟进Chromium的更新。 当前(2020/3/4)最新的chromium版本是80。 WebEngine的架构QtWebEngine提供了C++和Qml的接口，可以在Widget/Qml中渲染HTML、XHTML、SVG， 也支持CSS样式表和JavaScript脚本。 QtWebEngine的架构图如下 基于Chromium封装了一个WebEngineCore模块，在此之上， WebEngine Widgets模块专门用于Widget项目， WebEngine 模块用于Qml项目， WebEngineProcess则是一个单独的进程，用来渲染页面、运行js脚本。 Web在单独的进程里，我们开发的时候知道这一点就好了，不需要额外关注， 只要在发布的时候，带上QTDIR目录下的可执行程序QtWebEngineProcess即可。 (这里提一下底层实现原理，使用了进程间共享OpenGL上下文的方式, 实现多个进程的UI混合在一起) WebEngine的平台要求(以Qt5.12为参考) 首先一条是：不支持静态编译 (因为依赖的chromium、chromium本身的依赖库 不能静态编译) 接下来再看看各平台的要求和限制： Windows编译器要 Visual Studio 2017 version 15.8 以上 系统环境要 Windows 10 SDK 默认只支持X64版本，如果要x86版本，要自己编译qt源码。 MacOS MacOS 10.12以上 XCode 8.3.3以上 MacOS 10.12以上 SDK 不支持32-bit 不兼容 Mac App Store (chromium使用了私有api，App Sandbox和chromium Sandbox优先级问题) Linux编译器要 clang， 或者 gcc 5以上 需要pkg-config来探测依赖库，dbus-1和 fontconfig是必须的。 如果配置了xcb，还要额外配置相关库。 WebViewQt还提供了一个WebView组件，可以用来将Web内容嵌入到Qml程序中。(这个没有提供Widget的接口) WebView组件的实现，使用了平台原生api，在移动端意义重大，特别是在ios平台，使用 原生的web view，这样就能兼容App Store了。 在Windows/MacOS/Linux平台，则是渲染部分还是使用了WebEngine。 WebView的使用可以参考官方例子Minibrowser WebEngine的使用WebEngine Widget最简Demo源代码这里示例一个最简单的demo, 使用WebEngine Widget模块提供的QWebEngineView： 1234567//Demo.proQT += core gui webenginewidgetsCONFIG += c++11SOURCES += \\ main.cpp 注意pro文件中包含的Qt模块 12345678910111213//main.cpp#include &lt;QApplication&gt;#include &lt;QWebEngineView&gt;int main(int argc, char **argv)&#123; QApplication app(argc, argv); QWebEngineView view; view.load(QUrl(\"https://www.zhihu.com/\")); view.show(); return app.exec();&#125; 运行结果上面代码以打开知乎首页为例，运行结果如下 最小发布包涛哥尝试了在Windows平台，做出可用的最小发布包: 尺寸在170M左右。这些依赖项中，除了常见的Qt必备项platforms、Qt5Core、Qt5Gui等， Qt5WebEngineCore是最大的一个，有70M。QtWebEngineProcess.exe是新增加的一个exe程序， 前文说架构图时提到的单独进程就是这个程序实现。 resources/icudtl.dat在其它浏览器引擎中也常看到。 translations/qtwebengine_locales是WebEngine的翻译项，不带可能会发生翻译问题。 Qt5Positioning、Qt5PrintSupport一般不怎么用，但是不带这两个程序起不来。 同时发现Qml和Quick模块也是必须的，Qt5QuickWidgets也用上了。 涛哥查看源码后发现WebEngineCore模块依赖Quick和Qml模块。 WebEngine Qml最简Demo再做一个纯Qml的Demo 源码pro中增加webengine模块即可 12345678910//WebQml.proQT += core gui quick qml webengineCONFIG += c++11SOURCES += \\ main.cppRESOURCES += \\ Qrc.qrc 注意初始化。 1234567891011121314151617//main.cpp#include &lt;QGuiApplication&gt;#include &lt;QQuickView&gt;#include &lt;QtWebEngine&gt;int main(int argc, char *argv[])&#123; QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling); QGuiApplication a(argc, argv); //初始化。时机在QApp之后，Window/View构造之前。 QtWebEngine::initialize(); QQuickView view; view.setSource(QUrl(\"qrc:/main.qml\")); view.show(); return a.exec();&#125; qml导入模块，填入url 1234567891011//main.qmlimport QtQuick 2.0import QtWebEngine 1.8Item &#123; width: 800 height: 600 WebEngineView &#123; anchors.fill: parent url: \"https://www.zhihu.com\" &#125;&#125; 运行结果运行结果和上一个Demo一样 最小发布包这回可以去掉Widget模块 同时也去掉不必要的翻译文件。包大小160M左右，和前面的差别不大。","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qt实用技能","slug":"Qt实用技能","permalink":"https://jaredtao.github.io/tags/Qt%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qt(13)-安卓5.12.4环境搭建","slug":"玩转Qt(13)-安卓5.12.4环境搭建","date":"2019-12-07T16:44:23.000Z","updated":"2020-12-25T10:08:45.145Z","comments":true,"path":"2019/12/08/玩转Qt(13)-安卓5.12.4环境搭建/","link":"","permalink":"https://jaredtao.github.io/2019/12/08/%E7%8E%A9%E8%BD%ACQt(13)-%E5%AE%89%E5%8D%935.12.4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"简介Qt for android 环境搭建，以Windows平台 Qt5.12为基准。 安装Qt需要先安装Android版的Qt。 一般在Qt的安装包中都有集成，安装的时候勾上就行 安装必备工具链Android开发必备的工具链包括： Java JDK Android SDK Android NDK 下载链接分别点击QtCreator中的按钮就能跳转到 如果不能访问，需要梯子，或者找镜像网站。 这里要注意版本，和Qt5.12适配的才能用。Qt官方也没有说，都是自己试出来的。 JDK： OpenJDK没有试过，Oracle 的JDK， LTS版本有 1.8 和1.11，但是目前的Android SDK都是基于1.8开发的，1.11还用不了。 SDK： SDK下最新的就好。 NDK： Qt5.12能用的NDK是R19C，当前最新的是R20，里面工具链修改了，Qt还没有跟上，得后续版本（Qt5.12.5） 都装好就行了，不要去修改环境变量。直接在QtCreator里面选好路径即可。 更新SDK，build Tool到SDK 管理页面，安装一堆必要的工具和镜像。注意Android SDK Build Tool ， 能用的是28.0.3，最新的29用不了。 创建项目创建一个Qt项目，使用Andorid kit。 之后在项目管理页面中，点一下 “Create Template”按钮，生成一堆android相关配置文件。 之后去项目路径下，找到build.gradle文件 把buildToolsVersion改成”28.0.3” 最后编译运行就可以了。模拟器或真机连接，就不说了。","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"},{"name":"Android","slug":"Android","permalink":"https://jaredtao.github.io/tags/Android/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qt(12)-github-Actions缓存优化","slug":"玩转Qt(12)-github-Actions缓存优化","date":"2019-12-04T04:44:23.000Z","updated":"2020-12-25T10:08:23.953Z","comments":true,"path":"2019/12/04/玩转Qt(12)-github-Actions缓存优化/","link":"","permalink":"https://jaredtao.github.io/2019/12/04/%E7%8E%A9%E8%BD%ACQt(12)-github-Actions%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/","excerpt":"","text":"简介 原理 缓存actions模板 缓存文档 缓存大小限制 缓存运作流程 Qt项目的缓存优化 无缓存的配置 加缓存 环境变量还原 最终配置 简介在之前两篇文章《github-Actions自动化编译》《github-Actions自动化发行》中， 介绍了github-Actions的一些用法，其中有部分配置，已经有了缓存相关的步骤。 这里专门开一篇文章，来记录github-Actions的缓存优化相关的知识。 原理缓存actions模板github-Actions提供了缓存模板cache 缓存文档官方文档也有说明 缓存文档 缓存大致原理就是把目标路径打包存储下来，并记录一个唯一key。 下次启动时，根据key去查找。找到了就再按路径解压开。 缓存大小限制注意缓存有大小限制。对于免费用户，单个包不能超过500MB，整个仓库的缓存不能超过2G。 缓存运作流程一般我们在任务步骤中增加一个cache 123456steps: ... - use: actions/cache@v1 with: ... ... 那么在这个地方，缓存执行的操作是restore。 在steps的末尾，会自动增加一个PostCache，执行的操作是record。 Qt项目的缓存优化Qt项目每次运行Actions时，都是先通过install-qt-action模板，安装Qt，之后再获取代码，编译运行。 安装Qt这个步骤，可快可慢，涛哥在windows平台测试下来，平均要1分30秒左右。 加上cache后，平均只有25秒。 无缓存的配置先看一个Qt项目的编译配置 1234567891011121314151617181920212223242526272829303132333435363738name: Windowson: [push,pull_request]jobs: build: name: Build runs-on: windows-latest strategy: matrix: qt_ver: [5.12.6] qt_target: [desktop] qt_arch: [win64_msvc2017_64, win32_msvc2017] include: - qt_arch: win64_msvc2017_64 msvc_arch: x64 - qt_arch: win32_msvc2017 msvc_arch: x86 # 步骤 steps: # 安装Qt - name: Install Qt uses: jurplel/install-qt-action@v2.0.0 with: version: $&#123;&#123; matrix.qt_ver &#125;&#125; target: $&#123;&#123; matrix.qt_target &#125;&#125; arch: $&#123;&#123; matrix.qt_arch &#125;&#125; # 拉取代码 - uses: actions/checkout@v1 with: fetch-depth: 1 # 编译msvc - name: build-msvc shell: cmd env: vc_arch: $&#123;&#123; matrix.msvc_arch &#125;&#125; run: | call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsall.bat\" %vc_arch% qmake nmake 加缓存缓存步骤，一般尽量写steps最前面。 123456789# 步骤steps: # 缓存 - name: cacheQt id: WindowsCacheQt uses: actions/cache@v1 with: path: ../Qt/$&#123;&#123;matrix.qt_ver&#125;&#125;/$&#123;&#123;matrix.qt_arch_install&#125;&#125; key: $&#123;&#123; runner.os &#125;&#125;-Qt/$&#123;&#123;matrix.qt_ver&#125;&#125;/$&#123;&#123;matrix.qt_arch&#125;&#125; install-qt-action有默认的Qt安装路径${RUNNER_WORKSPACE}，不过这个环境变量不一定能取到。 涛哥实际测试下来，以当前路径的上一级作为Qt路径即可。 环境变量还原缓存只是把文件还原了，环境变量并没有还原，我们还需要手动还原环境变量。 install-qt-action这个模板增加了一个环境变量Qt5_Dir,值为Qt的安装路径,并把对应的bin添加到了Path。 我们要做的，就是在缓存恢复成功后，重新设置这两个变量，并去掉install-qt的步骤。 123456789- name: setupQt if: steps.WindowsCacheQt.outputs.cache-hit == 'true' shell: pwsh env: QtPath: ../Qt/$&#123;&#123;matrix.qt_ver&#125;&#125;/$&#123;&#123;matrix.qt_arch_install&#125;&#125; run: | $qt_Path=$&#123;env:QtPath&#125; echo \"::set-env name=Qt5_Dir::$qt_Path\" echo \"::add-path::$qt_Path/bin\" steps.WindowsCacheQt.outputs.cache-hit == ‘true’ 是缓存模板的输出值，可以作为后续步骤的条件判断。 最终配置写个伪配置，简单示例一下缓存流程 steps: cache setupQtif: cache-hit == ‘true’ installQtif: cache-hit = ‘false’ 实际配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879name: Windowson: # push代码时触发workflow push: # 忽略README.md paths-ignore: - 'README.md' - 'LICENSE' # pull_request时触发workflow pull_request: # 忽略README.md paths-ignore: - 'README.md' - 'LICENSE'jobs: build: name: Build # 运行平台， windows-latest目前是windows server 2019 runs-on: windows-latest strategy: # 矩阵配置 matrix: qt_ver: [5.12.6] qt_target: [desktop] # mingw用不了 # qt_arch: [win64_msvc2017_64, win32_msvc2017, win32_mingw53,win32_mingw73] qt_arch: [win64_msvc2017_64, win32_msvc2017] # 额外设置msvc_arch include: - qt_arch: win64_msvc2017_64 msvc_arch: x64 qt_arch_install: msvc2017_64 - qt_arch: win32_msvc2017 msvc_arch: x86 qt_arch_install: msvc2017 env: targetName: HelloActions-Qt.exe # 步骤 steps: - name: cacheQt id: WindowsCacheQt uses: actions/cache@v1 with: path: ../Qt/$&#123;&#123;matrix.qt_ver&#125;&#125;/$&#123;&#123;matrix.qt_arch_install&#125;&#125; key: $&#123;&#123; runner.os &#125;&#125;-Qt/$&#123;&#123;matrix.qt_ver&#125;&#125;/$&#123;&#123;matrix.qt_arch&#125;&#125; - name: setupQt if: steps.WindowsCacheQt.outputs.cache-hit == 'true' shell: pwsh env: QtPath: ../Qt/$&#123;&#123;matrix.qt_ver&#125;&#125;/$&#123;&#123;matrix.qt_arch_install&#125;&#125; run: | $qt_Path=$&#123;env:QtPath&#125; echo \"::set-env name=Qt5_Dir::$qt_Path\" echo \"::add-path::$qt_Path/bin\" # 安装Qt - name: Install Qt if: steps.WindowsCacheQt.outputs.cache-hit != 'true' # 使用外部action。这个action专门用来安装Qt uses: jurplel/install-qt-action@v2.0.0 with: # Version of Qt to install version: $&#123;&#123; matrix.qt_ver &#125;&#125; # Target platform for build target: $&#123;&#123; matrix.qt_target &#125;&#125; # Architecture for Windows/Android arch: $&#123;&#123; matrix.qt_arch &#125;&#125; # 拉取代码 - uses: actions/checkout@v1 with: fetch-depth: 1 # 编译msvc - name: build-msvc shell: cmd env: vc_arch: $&#123;&#123; matrix.msvc_arch &#125;&#125; run: | call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsall.bat\" %vc_arch% qmake nmake","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"持续集成(CI)","slug":"持续集成-CI","permalink":"https://jaredtao.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-CI/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qt(11)-github-Actions自动化发行","slug":"玩转Qt(11)-github-Actions自动化发行","date":"2019-12-03T04:44:23.000Z","updated":"2020-12-25T10:09:38.793Z","comments":true,"path":"2019/12/03/玩转Qt(11)-github-Actions自动化发行/","link":"","permalink":"https://jaredtao.github.io/2019/12/03/%E7%8E%A9%E8%BD%ACQt(11)-github-Actions%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E8%A1%8C/","excerpt":"","text":"简介 Qt项目的编译流程 Qt项目的发布流程 查找依赖 制作包 上传 定制发布流程 发布时机 打包步骤 多平台发布 最终配置 windows版的最终配置 MacOS最终配置 结果和代码 简介在上一篇文章《github-Actions自动化编译》中，介绍了github-Actions的基本用法， 本文来介绍github-Actions的自动化发布。 Qt项目的编译流程先来回顾一下,上一篇文章中的Qt项目的编译流程 安装Qt环境 这一步用第三方Action模板：install-qt-action 获取项目代码 这一步用Actions官方核心模板：actions/checkout 执行qmake、make 这一步用自定义脚本，也可以换成cmake、qbs、gn、ninja等构建工具 执行test 这一步可以引入单元测试、自动化UI测试等。暂无完善的方案，以后再说。 发布 见下文。 Qt项目的发布流程Qt程序在编译完成后，发布的大致流程是： 1、 查找依赖库 2、制作压缩包或者安装包 3、上传压缩包或者安装包到网站、网盘。 查找依赖Qt官方提供的查找依赖库的命令行工具，包括：Windows平台的Windeployqt、MacOS平台的Macosdeployqt。 在这两个平台，只使用Qt库的情况下，这两个工具足够了。 制作包做压缩包比较简单。(我们常说的‘绿色软件’，就是一个压缩包) 一般安装7z、rar之类的压缩工具，用一条命令行就行了。 涛哥这里再说一下，github-Actions给所有平台都提供了PowerShell，而PowerShell内置了压缩命令Compress-Archive。 使用也很简单，只要路径和名字，例如： 1Compress-Archive -Path .\\MyFolder 'MyRelease.zip' 做安装包，Qt官方有功能很全面的安装包制作工具：QtInstallFrameWork, 稍微翻看一下文档或者例子即可。本文先不展开了。 上传github 本身提供了’Release’功能，每个仓库都有一个’Release’页面 可以将打包好的压缩包或者安装包，直接上传上去, 供他人下载。 github-Actions还提供了 创建’Release’、上传’Release’的模板 actions/create-release actions/upload-release-asset 这两个模板的用法也很简单，在yml文件中直接use就行了，不赘述了。 定制发布流程前面介绍了一些简单的理论，接下来通过实例，教大家github-Actions的使用。 以HelloActions-Qt项目为例，做一些定制。 需求如下： 1、每次提交代码，同时在Windows、MacOS、Ubuntu、Android、IOS五个平台编译 2、每次提交tag，在windows和MacOS平台制作软件包，并发布到同一个github-‘Release’ 需求1已经实现了，着重讨论一下需求2： 发布时机‘每次提交tag’限定了发布的时机。 涛哥尝试了一番，最终得到答案。 回顾一下, Windows平台的编译配置： 1234567891011121314151617181920212223242526272829303132333435363738name: Windowson: [push,pull_request]jobs: build: name: Build runs-on: windows-latest strategy: matrix: qt_ver: [5.12.6] qt_target: [desktop] qt_arch: [win64_msvc2017_64, win32_msvc2017] include: - qt_arch: win64_msvc2017_64 msvc_arch: x64 - qt_arch: win32_msvc2017 msvc_arch: x86 # 步骤 steps: # 安装Qt - name: Install Qt uses: jurplel/install-qt-action@v2.0.0 with: version: $&#123;&#123; matrix.qt_ver &#125;&#125; target: $&#123;&#123; matrix.qt_target &#125;&#125; arch: $&#123;&#123; matrix.qt_arch &#125;&#125; # 拉取代码 - uses: actions/checkout@v1 with: fetch-depth: 1 # 编译msvc - name: build-msvc shell: cmd env: vc_arch: $&#123;&#123; matrix.msvc_arch &#125;&#125; run: | call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsall.bat\" %vc_arch% qmake nmake steps中的每一个步骤，可以有触发条件。我们可以在这里指定，只有github的事件为tag时才执行: 1234567steps: 。。。 # tag 打包 - name: package if: startsWith(github.event.ref, 'refs/tags/') run: | 。。。 打包步骤这里给出一个实际的打包步骤： 12345678910111213141516171819202122# tag 打包- name: package if: startsWith(github.event.ref, 'refs/tags/') env: VCINSTALLDIR: 'C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC' archiveName: $&#123;&#123; matrix.qt_ver &#125;&#125;-$&#123;&#123; matrix.qt_target &#125;&#125;-$&#123;&#123; matrix.qt_arch &#125;&#125; targetName: HelloActions-Qt.exe shell: pwsh run: | # 创建文件夹 New-Item -ItemType Directory $&#123;env:archiveName&#125; # 拷贝exe Copy-Item bin\\$&#123;env:targetName&#125; $&#123;env:archiveName&#125;\\ # 拷贝依赖 windeployqt --qmldir . $&#123;env:archiveName&#125;\\$&#123;env:targetName&#125; # 打包zip Compress-Archive -Path $&#123;env:archiveName&#125; $&#123;env:archiveName&#125;'.zip' # 记录环境变量packageName给后续step $name = $&#123;env:archiveName&#125; echo \"::set-env name=packageName::$name\" # 打印环境变量packageName Write-Host 'packageName:'$&#123;env:packageName&#125; 做一些说明： vs运行时 其中的VCINSTALLDIR环境变量，是给windeployqt用的。有了这个环境变量，windeployqt会去msvc的安装路径提取‘运行时安装程序’。 记录包名称 打包完以后，将包名设置为环境变量，后续的步骤就可以通过环境变量拿到包名字了。 普通的设置环境变量，在步骤执行完成后就失效了， 这里使用github-Actions的‘记录命令’set-env ，具体可以参考文档github-Actions记录命令 文档说不要用双引号，应该都是针对linux的，我试出来的PowerShell用法如下： 12$name = $&#123;env:archiveName&#125;echo \"::set-env name=packageName::$name\" 先取环境变量到一个局部变量，再在‘记录命令’中引用局部变量。 多平台发布如果只有一个平台、一种配置，直接用那两个模板就能解决问题。 这是官方给的例子upload-release-asset： 1234567891011121314151617181920212223242526steps: - name: Checkout code uses: actions/checkout@master - name: Build project # This would actually build your project, using zip for an example artifact run: | zip --junk-paths my-artifact README.md - name: Create Release id: create_release uses: actions/create-release@v1.0.0 env: GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; with: tag_name: $&#123;&#123; github.ref &#125;&#125; release_name: Release $&#123;&#123; github.ref &#125;&#125; draft: false prerelease: false - name: Upload Release Asset id: upload-release-asset uses: actions/upload-release-asset@v1.0.1 env: GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; with: upload_url: $&#123;&#123; steps.create_release.outputs.upload_url &#125;&#125; # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps asset_path: ./my-artifact.zip asset_name: my-artifact.zip asset_content_type: application/zip 在多平台 或者 多配置的情况下，同一个tag, 只有第一个执行create-release的任务可以成功，后续任务 再次执行create-release时，该tag下已经有了同名的‘Release’，所以会create失败。 这个问题折磨了涛哥好一阵子。找不到现成的解决方案，涛哥就自己实现了一种: 先用github的REST API去判断该tag下有没有‘Release’: 没有则执行create-release，并提取upload_url； 有则提取upload_url。 最后执行upload-release-asset 调用REST API，涛哥依旧使用了方便的PowerShell, 实际的配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# tag 查询github-Release- name: queryReleaseWin id: queryReleaseWin if: startsWith(github.event.ref, 'refs/tags/') shell: pwsh env: githubFullName: $&#123;&#123; github.event.repository.full_name &#125;&#125; ref: $&#123;&#123; github.event.ref &#125;&#125; run: | [string]$tag = $&#123;env:ref&#125;.Substring($&#123;env:ref&#125;.LastIndexOf('/') + 1) [string]$url = 'https://api.github.com/repos/' + $&#123;env:githubFullName&#125; + '/releases/tags/' + $&#123;tag&#125; $response=&#123;&#125; try &#123; $response = Invoke-RestMethod -Uri $url -Method Get &#125; catch &#123; Write-Host \"StatusCode:\" $_.Exception.Response.StatusCode.value__ Write-Host \"StatusDescription:\" $_.Exception.Response.StatusDescription # 没查到，输出 echo \"::set-output name=needCreateRelease::true\" return &#125; [string]$latestUpUrl = $response.upload_url Write-Host 'latestUpUrl:'$latestUpUrl if ($latestUpUrl.Length -eq 0) &#123; # 没查到，输出 echo \"::set-output name=needCreateRelease::true\" &#125;# tag 创建github-Release- name: createReleaseWin id: createReleaseWin if: startsWith(github.event.ref, 'refs/tags/') &amp;&amp; steps.queryReleaseWin.outputs.needCreateRelease == 'true' env: GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; uses: actions/create-release@v1.0.0 with: tag_name: $&#123;&#123; github.ref &#125;&#125; release_name: Release $&#123;&#123; github.ref &#125;&#125; body: $&#123;&#123; github.event.head_commit.message &#125;&#125; draft: false prerelease: false# tag 重定向upload_url到环境变量uploadUrl。- name: getLatestTagRelease if: startsWith(github.event.ref, 'refs/tags/') shell: pwsh env: githubFullName: $&#123;&#123; github.event.repository.full_name &#125;&#125; upUrl: $&#123;&#123; steps.createReleaseWin.outputs.upload_url &#125;&#125; ref: $&#123;&#123; github.event.ref &#125;&#125; run: | # upUrl不为空，导出就完事 if ($&#123;env:upUrl&#125;.Length -gt 0) &#123; $v=$&#123;env:upUrl&#125; echo \"::set-env name=uploadUrl::$v\" return &#125; # upUrl为空则重新获取 [string]$tag = $&#123;env:ref&#125;.Substring($&#123;env:ref&#125;.LastIndexOf('/') + 1) [string]$url = 'https://api.github.com/repos/' + $&#123;env:githubFullName&#125; + '/releases/tags/' + $&#123;tag&#125; $response = Invoke-RestMethod -Uri $url -Method Get [string]$latestUpUrl = $response.upload_url Write-Host 'latestUpUrl:'$latestUpUrl # 导出 echo \"::set-env name=uploadUrl::$latestUpUrl\" Write-Host 'env uploadUrl:'$&#123;env:uploadUrl&#125;# tag 上传Release- name: uploadRelease id: uploadRelease if: startsWith(github.event.ref, 'refs/tags/') env: GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; uses: actions/upload-release-asset@v1.0.1 with: upload_url: $&#123;&#123; env.uploadUrl &#125;&#125; asset_path: ./$&#123;&#123; env.packageName &#125;&#125;.zip asset_name: $&#123;&#123; env.packageName &#125;&#125;.zip asset_content_type: application/zip 最终配置windows版的最终配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157name: Windowson: # push代码时触发workflow push: # 忽略README.md paths-ignore: - 'README.md' - 'LICENSE' # pull_request时触发workflow pull_request: # 忽略README.md paths-ignore: - 'README.md' - 'LICENSE'jobs: build: name: Build # 运行平台， windows-latest目前是windows server 2019 runs-on: windows-latest strategy: # 矩阵配置 matrix: qt_ver: [5.12.6] qt_target: [desktop] qt_arch: [win64_msvc2017_64, win32_msvc2017] # 额外设置msvc_arch include: - qt_arch: win64_msvc2017_64 msvc_arch: x64 qt_arch_install: msvc2017_64 - qt_arch: win32_msvc2017 msvc_arch: x86 qt_arch_install: msvc2017 env: targetName: HelloActions-Qt.exe # 步骤 steps: # 安装Qt - name: Install Qt # 使用外部action。这个action专门用来安装Qt uses: jurplel/install-qt-action@v2.0.0 with: # Version of Qt to install version: $&#123;&#123; matrix.qt_ver &#125;&#125; # Target platform for build target: $&#123;&#123; matrix.qt_target &#125;&#125; # Architecture for Windows/Android arch: $&#123;&#123; matrix.qt_arch &#125;&#125; # 拉取代码 - uses: actions/checkout@v1 with: fetch-depth: 1 # 编译msvc - name: build-msvc shell: cmd env: vc_arch: $&#123;&#123; matrix.msvc_arch &#125;&#125; run: | call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsall.bat\" %vc_arch% qmake nmake # tag 打包 - name: package if: startsWith(github.event.ref, 'refs/tags/') env: VCINSTALLDIR: 'C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC' archiveName: $&#123;&#123; matrix.qt_ver &#125;&#125;-$&#123;&#123; matrix.qt_target &#125;&#125;-$&#123;&#123; matrix.qt_arch &#125;&#125; shell: pwsh run: | # 创建文件夹 New-Item -ItemType Directory $&#123;env:archiveName&#125; # 拷贝exe Copy-Item bin\\$&#123;env:targetName&#125; $&#123;env:archiveName&#125;\\ # 拷贝依赖 windeployqt --qmldir . $&#123;env:archiveName&#125;\\$&#123;env:targetName&#125; # 打包zip Compress-Archive -Path $&#123;env:archiveName&#125; $&#123;env:archiveName&#125;'.zip' # 记录环境变量packageName给后续step $name = $&#123;env:archiveName&#125; echo \"::set-env name=packageName::$name\" # 打印环境变量packageName Write-Host 'packageName:'$&#123;env:packageName&#125; # tag 查询github-Release - name: queryReleaseWin id: queryReleaseWin if: startsWith(github.event.ref, 'refs/tags/') shell: pwsh env: githubFullName: $&#123;&#123; github.event.repository.full_name &#125;&#125; ref: $&#123;&#123; github.event.ref &#125;&#125; run: | [string]$tag = $&#123;env:ref&#125;.Substring($&#123;env:ref&#125;.LastIndexOf('/') + 1) [string]$url = 'https://api.github.com/repos/' + $&#123;env:githubFullName&#125; + '/releases/tags/' + $&#123;tag&#125; $response=&#123;&#125; try &#123; $response = Invoke-RestMethod -Uri $url -Method Get &#125; catch &#123; Write-Host \"StatusCode:\" $_.Exception.Response.StatusCode.value__ Write-Host \"StatusDescription:\" $_.Exception.Response.StatusDescription # 没查到，输出 echo \"::set-output name=needCreateRelease::true\" return &#125; [string]$latestUpUrl = $response.upload_url Write-Host 'latestUpUrl:'$latestUpUrl if ($latestUpUrl.Length -eq 0) &#123; # 没查到，输出 echo \"::set-output name=needCreateRelease::true\" &#125; # tag 创建github-Release - name: createReleaseWin id: createReleaseWin if: startsWith(github.event.ref, 'refs/tags/') &amp;&amp; steps.queryReleaseWin.outputs.needCreateRelease == 'true' env: GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; uses: actions/create-release@v1.0.0 with: tag_name: $&#123;&#123; github.ref &#125;&#125; release_name: Release $&#123;&#123; github.ref &#125;&#125; body: $&#123;&#123; github.event.head_commit.message &#125;&#125; draft: false prerelease: false # 重定向upload_url到环境变量uploadUrl。 - name: getLatestTagRelease # tag 上一步无论成功还是失败都执行 if: startsWith(github.event.ref, 'refs/tags/') shell: pwsh env: githubFullName: $&#123;&#123; github.event.repository.full_name &#125;&#125; upUrl: $&#123;&#123; steps.createReleaseWin.outputs.upload_url &#125;&#125; ref: $&#123;&#123; github.event.ref &#125;&#125; run: | # upUrl不为空，导出就完事 if ($&#123;env:upUrl&#125;.Length -gt 0) &#123; $v=$&#123;env:upUrl&#125; echo \"::set-env name=uploadUrl::$v\" return &#125; [string]$tag = $&#123;env:ref&#125;.Substring($&#123;env:ref&#125;.LastIndexOf('/') + 1) [string]$url = 'https://api.github.com/repos/' + $&#123;env:githubFullName&#125; + '/releases/tags/' + $&#123;tag&#125; $response = Invoke-RestMethod -Uri $url -Method Get [string]$latestUpUrl = $response.upload_url Write-Host 'latestUpUrl:'$latestUpUrl echo \"::set-env name=uploadUrl::$latestUpUrl\" Write-Host 'env uploadUrl:'$&#123;env:uploadUrl&#125; # tag 上传Release - name: uploadRelease id: uploadRelease if: startsWith(github.event.ref, 'refs/tags/') env: GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; uses: actions/upload-release-asset@v1.0.1 with: upload_url: $&#123;&#123; env.uploadUrl &#125;&#125; asset_path: ./$&#123;&#123; env.packageName &#125;&#125;.zip asset_name: $&#123;&#123; env.packageName &#125;&#125;.zip asset_content_type: application/zip MacOS最终配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114name: MacOSon: push: paths-ignore: - 'README.md' - 'LICENSE' pull_request: paths-ignore: - 'README.md' - 'LICENSE'jobs: build: name: Build runs-on: $&#123;&#123; matrix.os &#125;&#125; strategy: matrix: os: [macos-latest] qt_ver: [5.12.6] qt_arch: [clang_64] env: targetName: HelloActions-Qt steps: - name: Install Qt uses: jurplel/install-qt-action@v2.0.0 with: version: $&#123;&#123; matrix.qt_ver &#125;&#125; - uses: actions/checkout@v1 with: fetch-depth: 1 - name: build macos run: | qmake make # tag 打包 - name: package if: startsWith(github.event.ref, 'refs/tags/') run: | # 拷贝依赖 macdeployqt bin/$&#123;targetName&#125;.app -qmldir=. -verbose=1 -dmg # tag 查询github-Release - name: queryRelease id: queryReleaseMacos if: startsWith(github.event.ref, 'refs/tags/') shell: pwsh env: githubFullName: $&#123;&#123; github.event.repository.full_name &#125;&#125; ref: $&#123;&#123; github.event.ref &#125;&#125; run: | [string]$tag = $&#123;env:ref&#125;.Substring($&#123;env:ref&#125;.LastIndexOf('/') + 1) [string]$url = 'https://api.github.com/repos/' + $&#123;env:githubFullName&#125; + '/releases/tags/' + $&#123;tag&#125; $response=&#123;&#125; try &#123; $response = Invoke-RestMethod -Uri $url -Method Get &#125; catch &#123; Write-Host \"StatusCode:\" $_.Exception.Response.StatusCode.value__ Write-Host \"StatusDescription:\" $_.Exception.Response.StatusDescription # 没查到，输出 echo \"::set-output name=needCreateRelease::true\" return &#125; [string]$latestUpUrl = $response.upload_url Write-Host 'latestUpUrl:'$latestUpUrl if ($latestUpUrl.Length -eq 0) &#123; # 没查到，输出 echo \"::set-output name=needCreateRelease::true\" &#125; # tag 创建github-Release - name: createReleaseWin id: createReleaseWin if: startsWith(github.event.ref, 'refs/tags/') &amp;&amp; steps.queryReleaseMacos.outputs.needCreateRelease == 'true' env: GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; uses: actions/create-release@v1.0.0 with: tag_name: $&#123;&#123; github.ref &#125;&#125; release_name: Release $&#123;&#123; github.ref &#125;&#125; body: $&#123;&#123; github.event.head_commit.message &#125;&#125; draft: false prerelease: false # 重定向upload_url到环境变量uploadUrl。 - name: getLatestTagRelease # tag 上一步无论成功还是失败都执行 if: startsWith(github.event.ref, 'refs/tags/') shell: pwsh env: githubFullName: $&#123;&#123; github.event.repository.full_name &#125;&#125; upUrl: $&#123;&#123; steps.queryReleaseMacos.outputs.upload_url &#125;&#125; ref: $&#123;&#123; github.event.ref &#125;&#125; run: | # upUrl不为空，导出就完事 if ($&#123;env:upUrl&#125;.Length -gt 0) &#123; $v=$&#123;env:upUrl&#125; echo \"::set-env name=uploadUrl::$v\" return &#125; [string]$tag = $&#123;env:ref&#125;.Substring($&#123;env:ref&#125;.LastIndexOf('/') + 1) [string]$url = 'https://api.github.com/repos/' + $&#123;env:githubFullName&#125; + '/releases/tags/' + $&#123;tag&#125; $response = Invoke-RestMethod -Uri $url -Method Get [string]$latestUpUrl = $response.upload_url Write-Host 'latestUpUrl:'$latestUpUrl echo \"::set-env name=uploadUrl::$latestUpUrl\" Write-Host 'env uploadUrl:'$&#123;env:uploadUrl&#125; # tag 上传Release - name: uploadRelease id: uploadRelease if: startsWith(github.event.ref, 'refs/tags/') env: GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; uses: actions/upload-release-asset@v1.0.1 with: upload_url: $&#123;&#123; env.uploadUrl &#125;&#125; asset_path: ./bin/$&#123;&#123; env.targetName &#125;&#125;.dmg asset_name: $&#123;&#123; env.targetName &#125;&#125;.dmg asset_content_type: application/applefile 结果和代码 代码在github HelloActions-Qt 另外在涛哥的Qml控件库TaoQuick，也使用了这一套配置 TaoQuick","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"持续集成(CI)","slug":"持续集成-CI","permalink":"https://jaredtao.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-CI/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qt(10)-github-Actions自动化编译","slug":"玩转Qt(10)-github-Actions自动化编译","date":"2019-11-19T04:44:23.000Z","updated":"2020-12-25T10:07:46.513Z","comments":true,"path":"2019/11/19/玩转Qt(10)-github-Actions自动化编译/","link":"","permalink":"https://jaredtao.github.io/2019/11/19/%E7%8E%A9%E8%BD%ACQt(10)-github-Actions%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91/","excerpt":"","text":"前言 简介 代码仓库 效果预览 使用方式 原理 Actions官方文档 Actions的默认环境 Actions语法 Actions模板 Qt项目的编译流程 Qt相关的Actions模板 install-qt-action action-setup-qt 扩展 Windows平台 默认mingw不能用 Windows平台指定shell Ubuntu平台 MacOS平台 Android平台 IOS平台 前言几个月前写过两篇持续集成的教程，当时使用的是travis和appveyor这两个第三方网址提供的服务。 由于配置比较复杂，劝退了很多同学…… 2019年8月份，github正式上线了Actions功能，提供了十分强大的CI(持续集成)/CD(持续部署)服务， 使用非常简单、方便，再加上github的Marketplace(github的应用商店)有各路大神开源的Actions模板, 完全可以抛弃那些落后的第三方服务了。 注：Actions也能在私有仓库上用(微软良心)。 简介这回涛哥将给大家提供一个简易的Qt项目的Action模板，让每一个有追求的Qter，都能轻松地用上强大的CI/CD功能。 (本文先说自动化编译，自动化发布下次说。) 代码仓库我创建了一个新的代码仓库，地址在这: https://github.com/jaredtao/HelloActions-Qt 效果预览先来看看效果吧 这是github的Actions页面 图中可以看到，最后一次提交的代码，在Windows、Ubuntu、MacOS、Android、IOS五个平台都编译通过了(通过显示绿色的对勾✔，未通过显示红色的叉❌)。 涛哥是个徽章爱好者，把这些徽章都链接进了README文件中。别人在预览代码仓库的时候，很容易就能看到仓库的编译状态。 当然，在commit页面，还可以详细查看每一次commit的代码，是否都编译通过 使用方式(这里假设各位读者会使用基本的git、github操作，不会的请去搜索相关教程) 下载涛哥的仓库HelloActions-Qt 1git clone https://github.com/jaredtao/HelloActions-Qt 拷贝文件夹’.github’到你的代码仓库根目录 在你的仓库中commit并添加.github文件夹中的文件 push你的仓库到github push完就可以了，到你的github相应仓库页面-Actions子页面查看状态吧。 没错，复制、粘贴，就这么简单。 .github/workflows文件夹中包括写好的5个模板： 你也可以根据你的需要，只选择你需要的。 原理授人以鱼，不如授人以渔 这里再来介绍一些基本的原理。 Actions官方文档可以参考 github Actions官方文档 中文文档目前翻译不全面，建议优先看英文的。 Actions的默认环境github-Actions 主要提供了windows server 2019、macos 10.15、ubuntu 18.04三个平台的docker环境， 并预装了大量开发者常用的软件,比如Java SDK、Android SDK、VisualStudio、python、golang、nodejs等， 可以在文档github Actions默认环境及预装软件 中看到详细的信息。 Actions语法github-Actions和大部分docker环境一样，使用yaml/yml格式的配置文件。 同时github-Actions还提供了一些便利的功能、函数，可以参考 github Actions配置文件语法 更多细节请大家参考文档，这里就不赘述了。 Actions模板每个github仓库，都有一个Actions页面，在这里可以创建、管理Actions 一般使用nodejs、python、golang等环境的项目，github提供了现成的Actions模板，可以 直接在Actions创建页面或者Marketplace(github的应用商店)进行搜索、引用。 有闲暇的开发者，也可以开发自己的Actions并提交到github商店，甚至可以赚点零花钱哦。 (Actions开发使用TypeScript) Qt项目的编译流程简单总结一下Qt项目的编译流程 安装Qt环境 这一步用下文的Action模板：install-qt-action 获取项目代码 这一步用Actions官方核心模板：actions/checkout@v1 执行qmake、make 这一步用自定义脚本，可以换成qbs、cmake、gn、ninja等构建工具 执行test 这一步可以引入单元测试、自动化UI测试等。以后再说。 执行deployment 等我下一篇文章 Qt相关的Actions模板 install-qt-actionQt项目暂时没有公开、完整的Actions模板,不过有一个安装Qt的Actions，解决了在不同平台安装不同版本Qt的问题。 install-qt-action github的Actions有一个非常强大的功能，就是引用外部模板。 比如要引入这个install-qt-Actions模板，只要在配置文件中添加两行即可： 1234... - name: Install Qt uses: jurplel/install-qt-action@v2... Qt的安装路径、版本、目标平台、目标架构都有默认配置，当然你也可以手动配置 123456789101112131415... - name: Install Qt uses: jurplel/install-qt-action@v2 with: # 安装目录,默认当前路径 #dir: # optional # 版本,默认最新的LTS(5.12.6) version: 5.12.6 # 编译平台。一般不修改。 #host: # optional # 目标平台。默认desktop，可选android、ios target: desktop # 架构 arch: win64_msvc2017_64... 这个Actions模板的实现，是按照Actions的工作原理（TypeScript），调用另一个python仓库aqtinstall, 把配置参数传递过去，由该库完成Qt的安装。 aqtinstall由一位日本的程序员使用python开发，直接访问Qt官方的发布仓库 http://download.qt.io/online/qtsdkrepository/ , 下载指定平台的各模块压缩包，并解压到指定目录。 直接绕过了我们平常使用的Qt安装器。 aqtinstall没有实现‘只安装指定模块’，默认全安装。希望后续能做支持，毕竟Qt全安装太大了。 action-setup-qt涛哥还发现一个开源的action，并没有进商店，功能是适配所有平台的Qt环境变量 https://github.com/Skycoder42/action-setup-qt 可以在该作者的’Json序列化库’中，看到实际应用 https://github.com/Skycoder42/QtJsonSerializer 目前是固定在Qt5.13.2版本，包含winrt、wasm等所有平台。 扩展接下来，说一下涛哥提供的模板，对各平台的配置。 以方便那些，需要对模板做修改的同学。 Windows平台涛哥在这个配置文件中，写了一些注释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# windows.ymlname: Windowson: # push代码时触发workflow push: # 忽略README.md paths-ignore: - 'README.md' - 'LICENSE' # pull_request时触发workflow pull_request: # 忽略README.md paths-ignore: - 'README.md' - 'LICENSE'jobs: build: name: Build # 运行平台， windows-latest目前是windows server 2019 runs-on: windows-latest strategy: # 矩阵配置 matrix: qt_ver: [5.9.8,5.12.6] qt_target: [desktop] # mingw用不了 # qt_arch: [win64_msvc2017_64, win32_msvc2017, win32_mingw53,win32_mingw73] qt_arch: [win64_msvc2017_64, win32_msvc2017] # 从矩阵中除外的配置 exclude: # 不存在5.9.8-win32_msvc2017的版本 - qt_ver: 5.9.8 qt_arch: win32_msvc2017 # mingw用不了 # - qt_ver: 5.9.8 # qt_arch: win32_mingw73 # - qt_ver: 5.12.6 # qt_arch: win32_mingw53 # 额外设置msvc_arch include: - qt_arch: win64_msvc2017_64 msvc_arch: x64 - qt_arch: win32_msvc2017 msvc_arch: x86 # 步骤 steps: # 安装Qt - name: Install Qt # 使用外部action。这个action专门用来安装Qt uses: jurplel/install-qt-action@v2.0.0 with: # Version of Qt to install version: $&#123;&#123; matrix.qt_ver &#125;&#125; # Target platform for build target: $&#123;&#123; matrix.qt_target &#125;&#125; # Architecture for Windows/Android arch: $&#123;&#123; matrix.qt_arch &#125;&#125; # 拉取代码 - uses: actions/checkout@v1 with: fetch-depth: 1 # 编译msvc - name: build-msvc shell: cmd env: vc_arch: $&#123;&#123; matrix.msvc_arch &#125;&#125; run: | call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsall.bat\" %vc_arch% qmake nmake 大部分配置都是显而易见的，这里对一些特殊情况做一些说明吧。 默认mingw不能用windows平台优先推荐用msvc编译，不过有些情况不得不用mingw。 github-Actions提供的Windows Server 2019环境，预装Mingw为8.1.0，版本太高了。 Qt5.9需要的mingw版本是5.3，而5.12则需要7.3，涛哥试过简单的HelloWorld程序，都会报链接失败。 所以需要使用MinGW的同学，需要自己安装了。 Windows平台指定shellgithub-Actions在Windows平台默认的shell是PowerShell，其它平台是bash。 使用msvc命令行编译项目时，一般要先调用’vcvarsxxx.bat’脚本来设置环境变量。 Powershell虽然强大，却不太方便直接调用这个bat。要么安装Powershell扩展Pcsx，要么 用一些取巧的方式： https://stackoverflow.com/questions/2124753/how-can-i-use-powershell-with-the-visual-studio-command-prompt github-Actions当然也可以直接指定使用cmd。 1234567891011... # 编译msvc - name: build-msvc shell: cmd env: vc_arch: $&#123;&#123; matrix.msvc_arch &#125;&#125; run: | call \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\VC\\Auxiliary\\Build\\vcvarsall.bat\" %vc_arch% qmake nmake... Ubuntu平台Ubuntu 平台看配置吧。 12345678910111213141516171819202122232425262728293031323334# ubuntu.ymlname: Ubuntu# Qt官方没有linux平台的x86包on: push: paths-ignore: - 'README.md' - 'LICENSE' pull_request: paths-ignore: - 'README.md' - 'LICENSE'jobs: build: name: Build runs-on: $&#123;&#123; matrix.os &#125;&#125; strategy: matrix: os: [ubuntu-16.04,ubuntu-18.04] qt_ver: [5.9.8,5.12.6] steps: - name: Install Qt uses: jurplel/install-qt-action@v2.0.0 with: version: $&#123;&#123; matrix.qt_ver &#125;&#125; - name: ubuntu install GL library run: sudo apt-get install -y libglew-dev libglfw3-dev - uses: actions/checkout@v1 with: fetch-depth: 1 - name: build ubuntu run: | qmake make MacOS平台MacOS平台和Ubuntu差别不大 12345678910111213141516171819202122232425262728293031# macos.ymlname: MacOSon: push: paths-ignore: - 'README.md' - 'LICENSE' pull_request: paths-ignore: - 'README.md' - 'LICENSE'jobs: build: name: Build runs-on: $&#123;&#123; matrix.os &#125;&#125; strategy: matrix: os: [macos-latest] qt_ver: [5.9.8,5.12.6] steps: - name: Install Qt uses: jurplel/install-qt-action@v2.0.0 with: version: $&#123;&#123; matrix.qt_ver &#125;&#125; - uses: actions/checkout@v1 with: fetch-depth: 1 - name: build macos run: | qmake make Android平台Android使用ubuntu编译，Windows那个ndk似乎没装，未尝试。 如果只使用Qt5.12.6，默认的配置可以直接用，编译前设置环境变量 ANDROID_SDK_ROOT 和ANDROID_NDK_ROOT就可以了。 Qt5.9.8要指定低版本的NDK、SDK才行，这里涛哥没有进一步尝试。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# android.ymlname: Androidon: push: paths-ignore: - 'README.md' - 'LICENSE' pull_request: paths-ignore: - 'README.md' - 'LICENSE' jobs: build: name: Build runs-on: $&#123;&#123; matrix.os &#125;&#125; strategy: matrix: os: [ubuntu-latest] # 5.9.8 版本低，需要额外设置工具链。这里暂不支持。 qt_ver: [5.12.6] qt_target: [android] # android_arm64_v8a 暂时不支持. install-qt-action 依赖的aqtinstall版本为0.5*,需要升级 # qt_arch: [android_x86,android_armv7,android_arm64_v8a] qt_arch: [android_x86,android_armv7] # exclude: # - qt_ver: 5.9.8 # qt_arch: android_arm64_v8a steps: - name: Install Qt # if: steps.cacheqt.outputs.cache-hit != 'true' uses: jurplel/install-qt-action@v2.0.0 with: # Version of Qt to install version: $&#123;&#123; matrix.qt_ver &#125;&#125; # Target platform for build target: $&#123;&#123; matrix.qt_target &#125;&#125; # Architecture for Windows/Android arch: $&#123;&#123; matrix.qt_arch &#125;&#125; - uses: actions/checkout@v1 with: fetch-depth: 1 - name: build android run: | export ANDROID_SDK_ROOT=$ANDROID_HOME export ANDROID_NDK_ROOT=$ANDROID_HOME/ndk-bundle qmake make IOS平台ios只能使用MacOS编译。 qmake的时候要指定平台、release模式等。 12345678910111213141516171819202122232425262728293031323334#ios.ymlname: IOSon: push: paths-ignore: - 'README.md' pull_request: paths-ignore: - 'README.md'jobs: build: name: Build runs-on: $&#123;&#123; matrix.os &#125;&#125; strategy: matrix: os: [macos-latest] qt_ver: [5.12.6] qt_target: [ios] steps: - name: Install Qt # if: steps.cacheqt.outputs.cache-hit != 'true' uses: jurplel/install-qt-action@v2.0.0 with: # Version of Qt to install version: $&#123;&#123; matrix.qt_ver &#125;&#125; # Target platform for build target: $&#123;&#123; matrix.qt_target &#125;&#125; - uses: actions/checkout@v1 with: fetch-depth: 1 - name: build ios run: | qmake -r -spec macx-ios-clang CONFIG+=release CONFIG+=iphoneos make","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"持续集成(CI)","slug":"持续集成-CI","permalink":"https://jaredtao.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-CI/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qt(9)-程序发布指南","slug":"玩转Qt(9)-程序发布指南","date":"2019-09-12T10:44:23.000Z","updated":"2020-11-10T04:11:32.862Z","comments":true,"path":"2019/09/12/玩转Qt(9)-程序发布指南/","link":"","permalink":"https://jaredtao.github.io/2019/09/12/%E7%8E%A9%E8%BD%ACQt(9)-%E7%A8%8B%E5%BA%8F%E5%8F%91%E5%B8%83%E6%8C%87%E5%8D%97/","excerpt":"","text":"简介 背景 Qt的安装 Qt的目录结构 Qt安装路径 Qt核心路径 HelloDeploy Window编译和发布 Window 编译 Window 发布 VS运行时库 常见的错误处理 应用程序无法正常启动 启动失败 - no Qt platform plugin OpenGL Context 创建失败 整理 简单裁剪 删减dll 删减plugins 删减qml 简介这次讨论发布Qt应用程序的知识点。 背景有很多人向涛哥询问，Qt程序发布的相关问题，网络上虽然可以搜到一大堆教程，但是可靠的比较少。 所以这次尽我所能，全面、详细地整理一些Qt程序发布的知识点，希望能帮助到更多人。 对老手来说，很多坑都踩过了，无非就是把正确的dll放在正确的路径。 对新手来说，细节上能多说几句，都将是莫大的帮助，少走弯路，节省几个小时、甚至几天都是有可能的。 如果有疏漏、错误，也欢迎大家补充、指正。 Qt的安装Qt官网下载地址在这： http://download.qt.io/official_releases 离线安装包 或者 在线安装包 都行。 关于Qt版本的选择，涛哥建议： 体验新特性，就用最新版本；项目开发，用长期支持版(LTS)的最后一个修正版本，稳定、bug最少。可以在Qt官方wiki上查看相关信息 https://wiki.qt.io/Main 目前为止(2019/9/2)，最新版为5.13.0，LTS版本有5.9 和 5.12， 而5.9最后一个修正版本是5.9.8， 5.12则是到5.12.4 例如上图是5.9.8的离线安装包，提供了windows、mac以及linux三种系统的可执行程序。 其中windows的安装程序”qt-opensource-windoiws-x86-5.9.8.exe”, 大小有2.4G，里面 包含了msvc_x86、msvc_x64、mingw、Android等多个版本的Qt工具链。在下载完成，安装 过程中可以分别勾选。其它版本也是类似的。 如何安装Qt，就不细说了，搞不定的去参考入门级教程吧… Qt的目录结构这里假设大家都装好了Qt，先来了解一下Qt的安装路径都有哪些东西。 涛哥用的是Windows 10系统，安装的Qt版本是5.12.4，以此为例来说明，其它系统和版本以实际为准。 Qt安装路径涛哥安装在了D:\\Qt\\Online 路径下, 如图: 其中“vcredist”文件夹包含了msvc2015 和 msvc2017的运行时库安装程序(后面会说怎么用,不是msvc编译器不需要) “Tools”文件夹，包括QtCreator、OpenSSL库(可选)以及两种版本MinGW(可选)。 (图中还有Qt3DStudio,可忽略) “5.12.4”文件夹，是Qt的核心路径, 里面包含多个版本的Qt工具链、头文件、动态链接库等 这里涛哥安装了msvc2017、msvc2017_64、mingw73_64以及android_x86. 注意msvc2017是x86架构的Qt库，msvc2017_64则是x64架构的。 如果有msvc2013、msvc2015也同理。 Qt核心路径接下来看一下重点，Qt的核心路径， 以msvc2017_64文件夹为例 bin文件夹包含了Qt提供的各种工具exe程序，以及动态链接库的dll 其中工具包括qmake.exe 和 windeployqt.exe，windeployqt.exe是我们今天主要讨论的工具。 动态链接库全部是两份dll，比如Qt5Cored.dll和Qt5Core.dll，文件名末尾带’d’表示debug版本的，另一个不带’d’的是release版本。 debug版本和release版本的主要区别：debug没有开编译器优化、携带了调试信息，release开了编译器优化O2,去掉了多余的信息 (图中还有pdb文件，是涛哥单独安装的，用来调试Qt源码，可以忽略) 和bin同级的，还有plugins文件夹，包含一些Qt用到的插件 比如imageformats文件夹中提供了jepg、gif、webp等图片格式的功能支持的插件，platforms文件夹则提供了平台插件，特别是 qwindows.dll这一个，在windows平台是必不可少的。 和bin同级的，另外一个文件夹是’qml’文件夹，包含Qml的各种功能模块。 和bin同级的其它文件夹，resources是WebEngine模块专用的，translations提供了 Qt内置的翻译文件，剩下的和发布无关，就不多说了。 HelloDeploy这里新建一个简单的Hello World程序，名字就叫”HelloDeploy”。 同时为了说明问题，涛哥添加一些常用的模块。 在pro文件中，QT += 那一行该写的都写上： 在main.cpp中包含一下各个模块的头文件，再分别创建一个对象实例，调用一些简单的函数： 这样一个多模块依赖的程序就写好了。 Window编译和发布Window 编译这里要特别注意，编译器的选择, 以及编译用的是debug模式还是release模式。 涛哥这里是msvc2017_x64版本 一般发布用release模式。 编译完成后，默认在build-xxxx-release/release/文件夹中会生成我们的exe程序。 我们将这个exe复制出来，新建一个release文件夹，放进去 这时候可以尝试双击运行它，会提示缺少dll Window 发布发布程序，其实就是把exe程序依赖的dll和相关资源都放在一起，保证双击运行即可。 我们前面提过的windeployqt.exe，是Qt提供的命令行工具，能帮助我们自动把需要的dll或资源复制过来。 我们先打开一个命令行 可以从开始菜单找到Qt提供的命令行 注意选对版本。这种命令行在启动时已经设置好了QT的环境变量，可以直接输入windeployqt.exe 也可以用普通的命令行，使用windeployqt.exe时带上绝对路径即可。 涛哥一般用普通的命令行，因为绝对路径不易出错。 cd到release目录 这里说一个windows启动命令行的小技巧：在release文件夹中，按住键盘shift键，然后按鼠标右键，弹出的右键菜单， 会比普通的右键菜单多一个“在此处打开命令窗口”，点击就能在release文件夹打开命令行窗口。 如果没有这个功能，就得手动输入cd指令，进入release路径。 执行windeployqt命令 这里通过绝对路径来使用windeployqt： d:\\qt\\Online\\5.12.4\\msvc2017_64\\bin\\windeployqt.exe HelloDeploy.exe HelloDeploy这个程序还用到了Qml，用到Qml的程序，要给windeployqt加上qmldir参数，写上你的Qml文件所在文件夹 (没用到qml的程序，不要加这一步) d:\\qt\\Online\\5.12.4\\msvc2017_64\\bin\\windeployqt.exe HelloDeploy.exe –qmldir .\\qml 写好windeployqt命令后按回车执行 正确执行后，release文件夹下，多了很多dll，以及一些文件夹。 这时候我们双击运行HelloDeploy.exe, 就可以正常启动了。 将整个文件夹压缩或拷贝到其它没有Qt环境的电脑上，也是可以启动的。 只要dll齐备了，制作安装包也不是问题。(后续有时间，我再写安装包制作的教程) VS运行时库如果是VS编译的程序，需要将QT路径下对应的vcredist_xxx.exe带上。 如果其它电脑上有vs运行时则可以直接运行，如果没有，就需要运行一下vs运行时安装包。 或者将运行时库里面的dll复制出来即可。 一般在VS的安装路径，都有展开的dll，可以直接拷贝。 例如，涛哥电脑上的vs2017路径如下： 按实际的路径找到这几个dll，全部拷贝即可。注意x86和x64，别拿错了。 常见的错误处理一般使用windeployqt，大部分库都能自动拷贝，不需要手动处理， 只有极少数情况下，windeployqt跑完，会缺失一些库，还要手动处理一下。 遇到这种情况，用依赖检查工具Dependencies即可快速定位问题。 Dependencies下载链接: https://github.com/lucasg/Dependencies Dependencies 下载好，点击”DependenciesGui.exe”就可以打开界面。注意是名字带Gui的那个，不带gui的“Dependencies.exe”是命令行程序。 下面列举一些常见的错误信息 应用程序无法正常启动 最容易出现这种错误的情况是，程序是64位编译出来的，而同级目录下的dll是32位的， 或者同级目录下没有dll，但是环境变量中指向了32位的dll。(所以涛哥没有设置环境变量) 32位和64位倒过来也是。 如果dll版本是匹配的，还有可能出现的情况是缺少第三方库。 这里说一个检查依赖的方法： 将HelloDeploy.exe重命名为HelloDeploy.dll，然后用Dependencies打开，就可以查看少哪些库 如上图，红色问号的表示缺少的库。 找齐了依赖的库，再把程序的扩展名改回exe即可。 启动失败 - no Qt platform plugin 这种情况，是QT路径下的 plugins/platforms/qwindows.dll文件没有复制过来。 注意这个dll文件直接复制到exe同级是不起作用的，要放在exe程序同级的platforms文件夹里，或者同级 的plugins/platforms文件夹里 OpenGL Context 创建失败 这种情况，一般是OpenGL相关的库没有复制过来，补上就好了 整理我们看到，exe同级目录下，windeployqt将一堆的文件夹放在了那里，有些混乱。 涛哥观察并验证了一下，其实可以做个简单的整理。 Qt开头的文件夹都是qml的模块，剩下的文件夹除了translations都是Qt的插件， 所以新建两个文件夹qml和plugins, 分别把qml模块和插件归入其中。 这样的结构，和QT安装路径下的结构是相似的。 这也正是Qt支持的插件加载路径、qml模块加载路径。 同级的dll则是windows系统默认的动态库加载规则，不方便修改 可以参考msdn： https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order 简单裁剪如果你熟悉Qt的各个模块，可以进行一些裁剪。以下都是些个人经验。 不熟悉请慎重！ 不熟悉请慎重！ 不熟悉请慎重！ (当然静态编译也是一种裁剪的途径) 删减dll首先可以把单元测试的dll去掉 Qt5Test.dll Qt5QuickTest.dll 如果没用到windows扩展，Qt5WinExtras.dll也可以去掉 其次，如果你不需要内置的翻译文件，translations文件夹也可以删掉 删减plugins再来看一下plugins： 其中platforms是必不可少的，剩下的HelloDeploy都没用到，可以去掉。 常见程序会用的包括: imageformats 图片格式支持 iconengines 小图标功能 sqldrivers 数据库驱动，这个保留用到的数据库足够了 其他的看情况删减。 删减qml最后看一下Qml文件夹，如果程序完全没用qml，直接删掉就好了。 按windeployqt给HelloDeploy提供的这些，逐个文件夹来说: Qt/labs 一般不推荐Qml中引入labs中的实验品，但是有些情况下功能缺失，只能引入。 如果Qml中使用了Quick.Dialog(不是labs.Dialog)，它本身还是依赖的labs中的东西，一般是folderlistmodel和settings， 这时候还是不要动labs了，就按照windeployqt给的放着。 Qt/WebSockets Qml的Websocket功能，用了就放着，没用可以删掉。 QtGraphicalEffects Qml的一些ShaderEffect特效，用了就放着，没用到可以删掉 QtMultimedia Qml的多媒体模块，用了就放着，没用到可以删掉 QtQml/Models.2 数据Model, 经常用。 QtQuick 这里面大部分都是Qml中常用的，QtQuick/Extras可以按情况删掉 QtQuick.2 常用的 QtTest 单元测试，删掉吧 QtWinExtras Windows扩展，没用到可以去掉","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qt实用技能","slug":"Qt实用技能","permalink":"https://jaredtao.github.io/tags/Qt%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"},{"name":"Qt发布","slug":"Qt发布","permalink":"https://jaredtao.github.io/tags/Qt%E5%8F%91%E5%B8%83/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qt(8)-掌握信号槽使用细节","slug":"玩转Qt(8)-掌握信号槽使用细节","date":"2019-09-02T04:44:23.000Z","updated":"2020-12-25T10:07:06.969Z","comments":true,"path":"2019/09/02/玩转Qt(8)-掌握信号槽使用细节/","link":"","permalink":"https://jaredtao.github.io/2019/09/02/%E7%8E%A9%E8%BD%ACQt(8)-%E6%8E%8C%E6%8F%A1%E4%BF%A1%E5%8F%B7%E6%A7%BD%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/","excerpt":"","text":"简介 信号与槽的声明 信号-槽的使用 信号的使用 槽函数的使用 信号-槽的”元调用” 信号和信号的参数 注册元类型 信号-槽的连接 connect函数 连接的不同写法 元方法式 函数指针式 函数重载的处理 functor式 关于functor functor connect的连接类型 connect的返回值 简介之前的文章《认清信号槽的本质》、《窥探信号槽的实现细节》讨论了一些原理， 这次我们来讨论一些信号-槽的使用细节。 信号与槽的声明要使用信号-槽功能，先决条件是继承QObject类，并在类声明中增加Q_OBJECT宏。 之后在”signals:” 字段之后声明一些函数，这些函数就是信号。 在”public slots:” 之后声明的函数，就是槽函数。 例如下面的代码: 1234567891011121314151617181920//Tom.h#pragma once#include &lt;QObject&gt;#include &lt;QDebug&gt;class Tom : public QObject&#123; Q_OBJECTpublic: Tom(QObject *parent = nullptr) : QObject(parent) &#123; &#125; void miaow() &#123; qDebug() &lt;&lt; u8\"喵!\" ; emit miao(); &#125;signals: void miao();&#125;; 123456789101112131415161718//Jerry.h#pragma once#include &lt;QObject&gt;#include &lt;QDebug&gt;class Jerry : public QObject&#123; Q_OBJECTpublic: Jerry(QObject *parent = nullptr) : QObject(parent) &#123; &#125;public slots: void runAway() &#123; qDebug() &lt;&lt; u8\"那只猫又来了，快溜！\" ; &#125;&#125;; 信号-槽的使用使用比较简单，先说一下使用。 信号的使用信号 就是普通的类成员函数，信号只要声明(declare)，不需要实现(implement)，实现由moc(元对象编译器)自动生成。 信号的触发，可以用emit，也可以直接调用函数。 例如: 123456//实例化一个tom对象Tom tom;//通过emit发射信号emit tom.miao();//直接调用信号。效果和emit一样。tom.miao(); Qt源码的qobejctdefs.h头文件中，可以看到emit宏其实是空的。 1234//qobejctdefs.h#ifndef QT_NO_EMIT# define emit#endif 槽函数的使用槽函数和普通的成员函数一样。。。 信号-槽的”元调用”信号-槽特殊的地方，是moc(元对象编译器)为其生成了一份”元信息”,可以通过QMetaObject::invokeMethod的方式调用 例如: 123456789//实例化一个tom对象Tom tom;//通过invok方式调用信号QMetaObject::invokeMethod(&amp;tom, \"miao\");//实例化一个jerry对象Jerry jerry;//通过invok方式调用槽QMetaObject::invokeMethod(&amp;jerry, \"runAway\"); 一般在知道如何声明qobject的场景，没必要多此一举用invoke。 在一些需要”运行期反射”的情况下(头文件都没有,只知道有这么个对象,和函数的名字)，invoke十分有用。 invokeMethod还可以带参数、可以获取返回值，这不是本文的重点，这里就不展开了，详细的可以参考Qt帮助文档和元对象系统。 信号和信号的参数信号可以带参数，参数的类型，必须是元对象系统能够识别的类型, 即元类型。（元对象系统后面再细说） 注册元类型Qt已经将大部分常用的基础类型，都注册进了元对象系统，可以在QMetaType类中看到。 通常写的继承于QObject的子类，本身已经附带了元信息，可以直接在信号-槽中使用。 不是继承于QObject的结构体、类等自定义类型，可以通过Q_DECLARE_METATYPE宏 和 qRegisterMetaType函数进行注册，之后就可以在信号-槽中使用。 例如： 1234567struct MyStruct&#123; int i; ...&#125;;Q_DECLARE_METATYPE(MyStruct) 或者带命名空间的： 123456namespace MyNamespace&#123; ...&#125;Q_DECLARE_METATYPE(MyNamespace::MyStruct) 这里说明一下细节，Q_DECLARE_METATYPE宏声明过后，只是生成了元信息，可以被QVariant识别，还不能 用于队列方式的信号、槽，需要用qRegisterMetaType进行注册。而qRegisterMetaType要求”全定义”，也就是 提供类的”复制构造函数”和”赋值操作符”。 前面那种简单类型，C++编译器默认提供浅拷贝的”复制构造函数”和”赋值操作符”实现，可以直接用。 1234struct MyStruct&#123; int i;&#125;; 而复杂一些的类，就要提供”全定义”。 (顺带一提，信号的参数可以是任意注册过的对象，而C++11的lambda、std::bind也是对象，只要注册过，也是可以通过信号参数发送出去的。) 信号-槽的连接 connect函数信号与槽，通过connect函数进行连接，之后就可以用信号去触发槽函数了。 连接的一般格式是Connectin = connect(obj1, signal1, obj2, slot1, connectType); 连接的不同写法connect函数重载实现了多种不同的参数写法，以Qt5.12为例，大致分为三类: 元方法式、函数指针式、functor式 元方法式元方法式是最常用的写法，函数声明如下： 12345678910 //connect(1) 字符串式信号槽 static QMetaObject::Connection connect(const QObject *sender, const char *signal, const QObject *receiver, const char *member, Qt::ConnectionType = Qt::AutoConnection); //connect(2) QMetaMethod式信号槽 static QMetaObject::Connection connect(const QObject *sender, const QMetaMethod &amp;signal, const QObject *receiver, const QMetaMethod &amp;method, Qt::ConnectionType type = Qt::AutoConnection);//connect(3) 对(1)的重载, 非static去掉receiverinline QMetaObject::Connection connect(const QObject *sender, const char *signal, const char *member, Qt::ConnectionType type = Qt::AutoConnection) const; Qt应用程序中用到最多的是connect(1)的写法，例如: 123Tom tom;Jerry jerry;connect(&amp;tom, SIGNAL(miao()), &amp;jerry, SLOT(runAway())) 其中SIGNAL、SLOT两个宏, 作用是将函数转换成字符串。 connect(1)的实现是靠字符串去查找元方法，以实现连接。 connect(2) 则是把信号槽的字符串换成了元方法QMetaMethod, 一般不会直接用这种写法。 connect(3)是对connect(1)的重载，非静态成员函数，本身有this指针，所以省略了receiver参数。 函数指针式函数指针式写法，声明如下： 1234567891011121314151617//connect(4) 连接信号到qobject的成员函数template &lt;typename Func1, typename Func2&gt; static inline QMetaObject::Connection connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, const typename QtPrivate::FunctionPointer&lt;Func2&gt;::Object *receiver, Func2 slot, Qt::ConnectionType type = Qt::AutoConnection); //connect(5) 连接信号到非成员函数。template &lt;typename Func1, typename Func2&gt; static inline typename std::enable_if&lt;int(QtPrivate::FunctionPointer&lt;Func2&gt;::ArgumentCount) &gt;= 0, QMetaObject::Connection&gt;::type connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, Func2 slot); //connect(6) 连接信号到非成员函数。比(5)多一个context,可以设置连接类型template &lt;typename Func1, typename Func2&gt; static inline typename std::enable_if&lt;int(QtPrivate::FunctionPointer&lt;Func2&gt;::ArgumentCount) &gt;= 0 &amp;&amp; !QtPrivate::FunctionPointer&lt;Func2&gt;::IsPointerToMemberFunction, QMetaObject::Connection&gt;::type connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, const QObject *context, Func2 slot, Qt::ConnectionType type = Qt::AutoConnection); connect(4)用的也比较多，用法如下: 123Tom tom;Jerry jerry;connect(&amp;tom, &amp;Tom::miao, &amp;jerry, &amp;Jerry::runAway); 信号-槽换成了C++的 取成员函数指针 的形式。 connect(4)本身的实现，比connect(1)快一些，因为省去了字符串查找的过程。 而连接建立后，从信号触发到槽函数的执行，两种写法是没有区别的。 在一些需要”运行期反射”的情况下(头文件都没有,只知道有这么个对象,和函数的名字),只能用connect(1)。 connect(5)可以连接信号到任意非成员函数指针上。除了槽函数，普通的函数也可以连接。这种连接不支持设置连接类型，可以看作是单纯的函数调用。 connect(6)是对connect(5)的重载,增加了一个context对象代替reveicer对象的作用。这种连接是可以设置连接类型的。 函数重载的处理信号-槽函数有重载的情况下，写函数指针式connect会报错，就需要类型转换。 比如：QLocalSocket有一个成员函数error,也有一个信号error,直接写connect会报错的。 Qt为我们提供了QOverload这个模板类，以解决这个问题。 12//连接重载过的函数，使用QOverload做leixing 转换connect(socket, QOverload&lt;QLocalSocket::LocalSocketError&gt;::of(&amp;QLocalSocket::error), this, &amp;XXX::onError); 编译器支持C++14，还可以用qOverload模板函数 12//连接重载过的函数，使用QOverload做leixing 转换connect(socket, qOverload&lt;QLocalSocket::LocalSocketError&gt;(&amp;QLocalSocket::error), this, &amp;XXX::onError); 还有像QNetworkReply::error、QProcess::finished等等，都有重载，用的时候要转换处理一下。 functor式关于functor问: 什么是functor？functor有什么用? 答: 在C++11之前, Qt通过自己的实现来推导函数指针及其参数，即QtPrivate::FunctionPointer, 用来处理信号-槽的连接。 C++11带来了lambda, 以及std::bind和std::function, std::function本身可以存储lambda、std::bind以及FunctionPointer。 这时候Qt已有的connect(4)、connect(5)、connect(6)是可以支持FunctionPointer的,而新出现的lambda以及std::bind是不支持的， QtPrivate::FunctionPointer推导不出这些类型。所以Qt把这些不支持的新类型(主要是lambda和std::bind)称为functor(文档和源码都这么命名)， 并增加了connect(7)和connect(8)以支持functor。 functorfunctor式写法，声明如下： 12345678910//connect(7) 连接信号到任意functor template &lt;typename Func1, typename Func2&gt; static inline typename std::enable_if&lt;QtPrivate::FunctionPointer&lt;Func2&gt;::ArgumentCount == -1, QMetaObject::Connection&gt;::type connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, Func2 slot); //connect(8) 连接信号到任意functor。比(7)多一个context,可以设置连接类型template &lt;typename Func1, typename Func2&gt; static inline typename std::enable_if&lt;QtPrivate::FunctionPointer&lt;Func2&gt;::ArgumentCount == -1, QMetaObject::Connection&gt;::type connect(const typename QtPrivate::FunctionPointer&lt;Func1&gt;::Object *sender, Func1 signal, const QObject *context, Func2 slot, Qt::ConnectionType type = Qt::AutoConnection); connect(7)可以连接信号到任意lambda、std::bind上。 connect(8)是对(7)的重载，增加了一个context对象代替reveicer对象的作用。这种连接是可以设置连接类型的。 connect的连接类型connectType为连接类型，默认为AutoConnection，即Qt自动处理，大部分情况下也不用管。个别情况，需要手动指定。 可选的连接类型有自动 AutoConnection直连 DirectConnection队列 QueuedConnection唯一连接 UniqueConnection 自动处理的逻辑是，如果发送信号的线程和receiver在同一个线程，就是DirectConnection(直接函数调用),不是同一个线程，则转换为QueuedConnection。 123456789101112131415161718&#x2F;&#x2F;引用自《Qt原理-窥探信号槽的实现细节》如果信号-槽连接方式为QueuedConnection，不论是否在同一个线程，按队列处理。如果信号-槽连接方式为Auto，且不在同一个线程，也按队列处理。如果信号-槽连接方式为阻塞队列BlockingQueuedConnection，按阻塞处理。 (注意同一个线程就不要按阻塞队列调用了。因为同一个线程，同时只能做一件事，本身就是阻塞的，直接调用就好了，如果走阻塞队列，则多了加锁的过程。如果槽中又发了同样的信号，就会出现死锁：加锁之后还未解锁，又来申请加锁。)队列处理，就是把槽函数的调用，转化成了QMetaCallEvent事件，通过QCoreApplication::postEvent放进了事件循环, 等到下一次事件分发，相应的线程才会去调用槽函数。 下面举例一些需要手动指定连接类型的场景： 例1-跨多个线程： A线程中写connect，让B线程中的信号连到C线程的槽中，希望C的槽在C中执行。 这种情况要明确指定QueuedConnection，不写的话按照Auto处理，C中的槽会在A中执行。 例2-跨线程DirectConnection (这种用法在Qml的渲染引擎SceneGraph中比较常见)。 A线程为内部代码，不能修改，一些特定的节点会有信号发出。 B线程为用户代码，有一些功能函数，希望在A线程中去执行。 这种情况，将A的信号连接到B的函数，连接方式指定为DirectConnection，就可以把B的函数插入到A线程发信号的地方了。 效果类似于子类重载父类的函数。 connect的返回值connect的返回值为QMetaObject::Connection,代表一个连接。大部分情况下，不用管返回值。 Connection可以用来验证链接是否有效，可以用来断开连接。 一般用disconnect函数就可以断开连接；而signal-functor的这种形式的连接，没有object的存在，只能用Connection断开。","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qt实用技能","slug":"Qt实用技能","permalink":"https://jaredtao.github.io/tags/Qt%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"},{"name":"信号-槽","slug":"信号-槽","permalink":"https://jaredtao.github.io/tags/%E4%BF%A1%E5%8F%B7-%E6%A7%BD/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qt(7)-窥探信号槽的实现细节","slug":"玩转Qt(7)-窥探信号槽的实现细节","date":"2019-08-30T10:44:23.000Z","updated":"2020-12-25T10:06:48.362Z","comments":true,"path":"2019/08/30/玩转Qt(7)-窥探信号槽的实现细节/","link":"","permalink":"https://jaredtao.github.io/2019/08/30/%E7%8E%A9%E8%BD%ACQt(7)-%E7%AA%A5%E6%8E%A2%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/","excerpt":"","text":"简介 猫和老鼠的故事 声明与实现 Q_OBJECT宏 信号的moc生成 信号的触发 槽和moc生成 第三方信号槽实现 简介这次讨论Qt信号-槽的实现细节。 上次的文章《认清信号槽的本质》中介绍过，信号-槽是一种对象之间的通信机制，是 Qt在标准C++之外，使用元对象编译器(MOC)实现的语法糖。 这次通过一个简单的案例，学习一些信号-槽的实现细节。 猫和老鼠的故事 还是拿上次的设定来说明：Tom有个技能叫”喵”，就是发出猫叫，而正在偷吃东西的Jerry,听见猫叫声就会逃跑。 我们用信号-槽的方式写出来。 1234567891011121314151617181920//Tom.h#pragma once#include &lt;QObject&gt;#include &lt;QDebug&gt;class Tom : public QObject&#123; Q_OBJECTpublic: Tom(QObject *parent = nullptr) : QObject(parent) &#123; &#125; void miaow() &#123; qDebug() &lt;&lt; u8\"喵!\" ; emit miao(); &#125;signals: void miao();&#125;; 123456789101112131415161718//Jerry.h#pragma once#include &lt;QObject&gt;#include &lt;QDebug&gt;class Jerry : public QObject&#123; Q_OBJECTpublic: Jerry(QObject *parent = nullptr) : QObject(parent) &#123; &#125;public slots: void runAway() &#123; qDebug() &lt;&lt; u8\"那只猫又来了，快溜！\" ; &#125;&#125;; 以上面的代码为例，要使用信号-槽功能，先决条件是继承QObject类，并在类声明中增加Q_OBJECT宏。 之后在”signals:” 字段之后声明一些函数，这些函数就是信号。 在”public slots:” 之后声明的函数，就是槽函数。 接下来看看我们的main函数: 1234567891011121314151617//main.cpp#include &lt;QCoreApplication&gt;#include \"Tom.h\"#include \"Jerry.h\"int main(int argc, char *argv[])&#123; QCoreApplication a(argc, argv); Tom tom; Jerry jerry; QObject::connect(&amp;tom, &amp;Tom::miao, &amp;jerry, &amp;Jerry::runAway); tom.miaow(); return a.exec();&#125; 信号-槽都准备好了，接下来创建两个对象实例，并使用QObject::connect将信号和槽连接起来。 最后使用emit发送信号，就会自动触发槽函数了。 运行结果： 声明与实现信号和槽的本质都是函数。 我们知道C++中的函数要有声明(declare)，也要有实现(implement), 而信号只要声明，不需要写实现。这是因为moc会为我们自动生成。 另外触发信号时，不写emit关键字，直接调用信号函数，也是没有问题的。 Q_OBJECT宏我们来看一下Q_OBJECT宏，展开如下： (不同的Qt版本有些差异，涛哥这里用的是5.12.4，以此为例) 1234567891011121314public: \\ QT_WARNING_PUSH \\ Q_OBJECT_NO_OVERRIDE_WARNING \\ static const QMetaObject staticMetaObject; \\ virtual const QMetaObject *metaObject() const; \\ virtual void *qt_metacast(const char *); \\ virtual int qt_metacall(QMetaObject::Call, int, void **); \\ QT_TR_FUNCTIONS \\private: \\ Q_OBJECT_NO_ATTRIBUTES_WARNING \\ Q_DECL_HIDDEN_STATIC_METACALL static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); \\ QT_WARNING_POP \\ struct QPrivateSignal &#123;&#125;; \\ QT_ANNOTATE_CLASS(qt_qobject, \"\") 我们看到，关键的地方，是声明了一个只读的静态成员变量staticMetaObject，以及3个public的成员函数 1234567static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); virtual int qt_metacall(QMetaObject::Call, int, void **); 还有一个private的静态成员函数qt_static_metacall 1static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **) 那么声明的这些成员变量/函数，在哪里实现？答案是moc生成的cpp文件。 信号的moc生成 如上图所示目录结构，项目编译完成后，在build文件夹中，自动生成了moc_Jerry.cpp 和 moc_Tom.cpp两个文件 其中moc_Tom.cpp内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/****************************************************************************** Meta object code from reading C++ file 'Tom.h'**** Created by: The Qt Meta Object Compiler version 67 (Qt 5.12.4)**** WARNING! All changes made in this file will be lost!*****************************************************************************/#include \"../../TomJerry/Tom.h\"#include &lt;QtCore/qbytearray.h&gt;#include &lt;QtCore/qmetatype.h&gt;#if !defined(Q_MOC_OUTPUT_REVISION)#error \"The header file 'Tom.h' doesn't include &lt;QObject&gt;.\"#elif Q_MOC_OUTPUT_REVISION != 67#error \"This file was generated using the moc from 5.12.4. It\"#error \"cannot be used with the include files from this version of Qt.\"#error \"(The moc has changed too much.)\"#endifQT_BEGIN_MOC_NAMESPACEQT_WARNING_PUSHQT_WARNING_DISABLE_DEPRECATEDstruct qt_meta_stringdata_Tom_t &#123; QByteArrayData data[3]; char stringdata0[10];&#125;;#define QT_MOC_LITERAL(idx, ofs, len) \\ Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \\ qptrdiff(offsetof(qt_meta_stringdata_Tom_t, stringdata0) + ofs \\ - idx * sizeof(QByteArrayData)) \\ )static const qt_meta_stringdata_Tom_t qt_meta_stringdata_Tom = &#123; &#123;QT_MOC_LITERAL(0, 0, 3), // \"Tom\"QT_MOC_LITERAL(1, 4, 4), // \"miao\"QT_MOC_LITERAL(2, 9, 0) // \"\" &#125;, \"Tom\\0miao\\0\"&#125;;#undef QT_MOC_LITERALstatic const uint qt_meta_data_Tom[] = &#123; // content: 8, // revision 0, // classname 0, 0, // classinfo 1, 14, // methods 0, 0, // properties 0, 0, // enums/sets 0, 0, // constructors 0, // flags 1, // signalCount // signals: name, argc, parameters, tag, flags 1, 0, 19, 2, 0x06 /* Public */, // signals: parameters QMetaType::Void, 0 // eod&#125;;void Tom::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)&#123; if (_c == QMetaObject::InvokeMetaMethod) &#123; auto *_t = static_cast&lt;Tom *&gt;(_o); Q_UNUSED(_t) switch (_id) &#123; case 0: _t-&gt;miao(); break; default: ; &#125; &#125; else if (_c == QMetaObject::IndexOfMethod) &#123; int *result = reinterpret_cast&lt;int *&gt;(_a[0]); &#123; using _t = void (Tom::*)(); if (*reinterpret_cast&lt;_t *&gt;(_a[1]) == static_cast&lt;_t&gt;(&amp;Tom::miao)) &#123; *result = 0; return; &#125; &#125; &#125; Q_UNUSED(_a);&#125;QT_INIT_METAOBJECT const QMetaObject Tom::staticMetaObject = &#123; &#123; &amp;QObject::staticMetaObject, qt_meta_stringdata_Tom.data, qt_meta_data_Tom, qt_static_metacall, nullptr, nullptr&#125; &#125;;const QMetaObject *Tom::metaObject() const&#123; return QObject::d_ptr-&gt;metaObject ? QObject::d_ptr-&gt;dynamicMetaObject() : &amp;staticMetaObject;&#125;void *Tom::qt_metacast(const char *_clname)&#123; if (!_clname) return nullptr; if (!strcmp(_clname, qt_meta_stringdata_Tom.stringdata0)) return static_cast&lt;void*&gt;(this); return QObject::qt_metacast(_clname);&#125;int Tom::qt_metacall(QMetaObject::Call _c, int _id, void **_a)&#123; _id = QObject::qt_metacall(_c, _id, _a); if (_id &lt; 0) return _id; if (_c == QMetaObject::InvokeMetaMethod) &#123; if (_id &lt; 1) qt_static_metacall(this, _c, _id, _a); _id -= 1; &#125; else if (_c == QMetaObject::RegisterMethodArgumentMetaType) &#123; if (_id &lt; 1) *reinterpret_cast&lt;int*&gt;(_a[0]) = -1; _id -= 1; &#125; return _id;&#125;// SIGNAL 0void Tom::miao()&#123; QMetaObject::activate(this, &amp;staticMetaObject, 0, nullptr);&#125;QT_WARNING_POPQT_END_MOC_NAMESPACE 可以大致看出，生成的cpp文件中，就是变量staticMetaObject以及 那几个函数的实现。 staticMetaObject是一个结构体，用来存储Tom这个类的信号、槽等元信息，并把 qt_static_metacall静态函数作为函数指针存储起来。 因为是静态成员，所以实例化多少个Tom对象，它们的元信息都是一样的。 qt_static_metacall函数提供了两种“元调用的实现”： 如果是InvokeMetaMethod类型的调用，则直接 把参数中的QObject对象， 转换成Tom类然后调用其miao函数 如果是IndexOfMethod类型的调用，即获取元函数的索引号，则计算miao函数的偏移并返回。 而moc_Tom.cpp末尾的 12345// SIGNAL 0void Tom::miao()&#123; QMetaObject::activate(this, &amp;staticMetaObject, 0, nullptr);&#125; 就是信号函数的实现。 信号的触发miao信号的实现，直接调用了QMetaObject::activate函数。其中0代表miao这个函数的索引号。 QMetaObject::activate函数的实现，在Qt源码的QObject.cpp文件中，略微复杂一些， 且不同版本的Qt，实现差异都比较大，这里总结一下大致的实现： 先找出与当前信号连接的所有对象-槽函数，再逐个处理： 这里处理的方式，分为三种： 123456789if((c-&gt;connectionType == Qt::AutoConnection &amp;&amp; !receiverInSameThread) || (c-&gt;connectionType == Qt::QueuedConnection)) &#123; // 队列处理&#125; else if (c-&gt;connectionType == Qt::BlockingQueuedConnection) &#123; // 阻塞处理 // 如果同线程，打印潜在死锁。&#125; else &#123; //直接调用槽函数或回调函数&#125; receiverInSameThread表示当前线程id和接收信号的对象的所在线程id是否相等。 如果信号-槽连接方式为QueuedConnection，不论是否在同一个线程，按队列处理。 如果信号-槽连接方式为Auto，且不在同一个线程，也按队列处理。 如果信号-槽连接方式为阻塞队列BlockingQueuedConnection，按阻塞处理。 (注意同一个线程就不要按阻塞队列调用了。因为同一个线程，同时只能做一件事， 本身就是阻塞的，直接调用就好了，如果走阻塞队列，则多了加锁的过程。如果槽中又发了 同样的信号，就会出现死锁：加锁之后还未解锁，又来申请加锁。) 队列处理，就是把槽函数的调用，转化成了QMetaCallEvent事件，通过QCoreApplication::postEvent 放进了事件循环, 等到下一次事件分发，相应的线程才会去调用槽函数。 关于事件循环，可以参考之前的文章《Qt实用技能3-理解事件循环》 槽和moc生成slot函数我们自己实现了，moc不会做额外的处理，所以自动生成的moc_Jerry.cpp文件中， 只有Q_OBJECT宏的展开，和前面的moc_Tom.cpp是一致的，不赘述了。 第三方信号槽实现信号-槽是非常优秀的通信机制，但Qt的moc实现方式，被一些人诟病，所以他们造了新的轮子,比如： https://woboq.com/blog/verdigris-qt-without-moc.html http://sigslot.sourceforge.net/ https://github.com/NoAvailableAlias/nano-signal-slot https://github.com/pbhogan/Signals","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"信号-槽","slug":"信号-槽","permalink":"https://jaredtao.github.io/tags/%E4%BF%A1%E5%8F%B7-%E6%A7%BD/"},{"name":"Qt原理","slug":"Qt原理","permalink":"https://jaredtao.github.io/tags/Qt%E5%8E%9F%E7%90%86/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qt(6)-认清信号槽的本质","slug":"玩转Qt(6)-认清信号槽的本质","date":"2019-07-23T10:44:23.000Z","updated":"2020-12-25T10:06:35.051Z","comments":true,"path":"2019/07/23/玩转Qt(6)-认清信号槽的本质/","link":"","permalink":"https://jaredtao.github.io/2019/07/23/%E7%8E%A9%E8%BD%ACQt(6)-%E8%AE%A4%E6%B8%85%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"简介 猫和老鼠的故事 对象之间的通信机制 尝试一：直接调用 尝试二：回调函数+映射表 观察者模式 Qt的信号-槽 信号-槽简介 信号-槽分两种 信号-槽的实现 元对象编译器moc moc的本质-反射 参考文献 简介这次讨论Qt信号-槽相关的知识点。 信号-槽是Qt框架中最核心的机制，也是每个Qt开发者必须掌握的技能。 网络上有很多介绍信号-槽的文章，也可以参考。 涛哥的专栏是《Qt进阶之路》，如果连信号-槽的文章都没有，将是没有灵魂的。 所以这次涛哥就由浅到深地说一说信号-槽。 猫和老鼠的故事如果一上来就讲一大堆概念和定义，读者很容易读睡着。所以涛哥从一个故事/场景开始说起。 涛哥小时候喜欢看动画片《猫和老鼠》, 里面有汤姆猫(Tom)和杰瑞鼠(Jerry)斗智斗勇的故事。。。 现在做个简单的设定：Tom有个技能叫”喵”，就是发出猫叫，而正在偷吃东西的Jerry,听见猫叫声就会逃跑。 我们尝试用C++面向对象的思想，描述这个设定。 先是定义Tom和Jerry两种对象 12345678910111213141516171819202122232425//Tom的定义class Tom&#123;public: //猫叫 void Miaow() &#123; cout &lt;&lt; \"喵!\" &lt;&lt; endl; &#125; //省略其它 ... &#125;;//Jerry的定义class Jerry&#123;public: //逃跑 void RunAway() &#123; cout &lt;&lt; \"那只猫又来了，快溜！\" &lt;&lt; endl; &#125; //省略其它 ... &#125;; 接下来模拟场景 12345678910111213141516int main(int argc, char *argv[])&#123; //实例化tom Tom tom; //实例化jerry Jerry jerry; //tom发出叫声 tom.Miaow(); //jerry逃跑 jerry.RunAway(); return 0;&#125; 这个场景看起来很简单，tom发出叫声之后手动调用了jerry的逃跑。 我们再看几种稍微复杂的场景: 场景一: 假如jerry逃跑后过段时间，又回来偷吃东西。Tom再次发出叫声，jerry再次逃跑。。。 这个场景要重复几十次。我们能否实现，只要tom的Miaow被调用了，jerry的RunAway就自动被调用，而不是每次都手动调用? 场景二: 假如jerry是藏在“厨房的柜子里的米袋子后面”，无法直接发现它(不能直接获取到jerry对象，并调用它的函数)。 这种情况下，该怎么建立 “猫叫-老鼠逃跑” 的模型？ 场景三： 假如有多只jerry，一只tom发出叫声时，所有jerry都逃跑。这种模型该怎么建立？ 假如有多只tom，任意一只发出叫声时，所有jerry都逃跑。这种模型又该怎么建立？ 场景四： 假如不知道猫的确切品种或者名字，也不知道老鼠的品种或者名字，只要 猫 这种动物发出叫声，老鼠 这种动物就要逃跑。 这样的模型又该如何建立? … 还有很多场景，就不赘述了。 对象之间的通信机制这里概括一下要实现的功能： 要提供一种对象之间的通信机制。这种机制，要能够给两个不同对象中的函数建立映射关系，前者被调用时后者也能被自动调用。 再深入一些，两个对象都互相不知道对方的存在，仍然可以建立联系。甚至一对一的映射可以扩展到多对多，具体对象之间的映射可以扩展到抽象概念之间。 尝试一：直接调用应该会有人说， Miaow()的函数中直接调用RunAway()不就行了？ 明显场景二就把这种方案pass掉了。 直接调用的问题是，猫要知道老鼠有个函数/接口叫逃跑，然后主动调用了它。 这就好比Tom叫了一声，然后Tom主动拧着Jerry的腿让它跑。这样是不合理的。(Jerry表示一脸懵逼!) 真实的逻辑是，猫的叫声在空气/介质中传播，传到了老鼠的耳朵里，老鼠就逃跑了。猫和老鼠互相都没看见呢。 尝试二：回调函数+映射表似乎是可行的。 稍微思考一下，我们要做这两件事情： 1 把RunAway函数取出来存储在某个地方 2 建立Miaow函数和RunAway的映射关系，能够在前者被调用时，自动调用后者。 RunAway函数可以用 函数指针|成员函数指针 或者C++11-function 来存储，都可以称作 “回调函数”。 (下面的代码以C++11 function的写法为主，函数指针的写法稍微复杂一些，本质一样) 我们先用一个简单的Map来存储映射关系, 就用一个字符串作为映射关系的名字 1std::map&lt;std::string, std::function&lt;void()&gt;&gt; callbackMap; 我们还要实现 “建立映射关系” 和 “调用”功能，所以这里封装一个Connections类 123456789101112131415161718192021class Connections &#123;public: //按名称“建立映射关系” void connect(const std::string &amp;name, const std::function&lt;void()&gt; &amp;callback) &#123; m_callbackMap[name] = callback; &#125; //按名称“调用” void invok(const std::string &amp;name) &#123; auto it = m_callbackMap.find(name); //迭代器判断 if (it != m_callbackMap.end()) &#123; //迭代器有效的情况，直接调用 it-&gt;second(); &#125; &#125;private: std::map&lt;std::string, std::function&lt;void()&gt;&gt; m_callbackMap;&#125;; 那么这个映射关系存储在哪里呢? 显然是一个Tom和Jerry共有的”上下文环境”中。 我们用一个全局变量来表示，这样就可以简单地模拟了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//全局共享的Connections。static Connections s_connections;//Tom的定义class Tom&#123;public: //猫叫 void Miaow() &#123; cout &lt;&lt; \"喵!\" &lt;&lt; endl; //调用一下名字为mouse的回调 s_connections.invok(\"mouse\"); &#125; //省略其它 ... &#125;;//Jerry的定义class Jerry&#123;public: Jerry() &#123; //构造函数中，建立映射关系。std::bind属于基本用法。 s_connections.connect(\"mouse\", std::bind(&amp;Jerry::RunAway, this)); &#125; //逃跑 void RunAway() &#123; cout &lt;&lt; \"那只猫又来了，快溜！\" &lt;&lt; endl; &#125; //省略其它 ... &#125;;int main(int argc, char *argv[])&#123; //模拟嵌套层级很深的场景，外部不能直接访问到tom struct A &#123; struct B &#123; struct C &#123; private: //Tom在很深的结构中 Tom tom; public: void MiaoMiaoMiao() &#123; tom.Miaow(); &#125; &#125;c; void MiaoMiao() &#123; c.MiaoMiaoMiao(); &#125; &#125;b; void Miao() &#123; b.MiaoMiao(); &#125; &#125;a; //模拟嵌套层级很深的场景，外部不能直接访问到jerry struct D &#123; struct E &#123; struct F &#123; private: //jerry在很深的结构中 Jerry jerry; &#125;f; &#125;e; &#125;d; //A间接调用tom的MiaoW，发出猫叫声 a.Miao(); return 0;&#125; 看一下运行结果： RunAway没有被直接调用，而是被自动触发。 分析：这里是以”mouse”这个字符串作为连接tom和jerry的关键。这只是一种简单、粗糙的示例实现。 观察者模式在GOF四人帮的书籍《设计模式》中，有一种观察者模式，可以比较优雅地实现同样的功能。 (顺便说一下，GOF总结的设计模式一共有23种，涛哥曾经用C++11实现了全套的，github地址是:https://github.com/jaredtao/DesignPattern) 初级的观察者模式，涛哥就不重复了。这里涛哥用C++11搭配一点模板技巧，实现一个更加通用的观察者模式。 也可以叫发布-订阅模式。 1234567891011121314151617181920212223242526272829303132333435//Subject.hpp#pragma once#include &lt;vector&gt;#include &lt;algorithm&gt;//Subject 事件或消息的主体。模板参数为观察者类型template&lt;typename ObserverType&gt;class Subject &#123;public: //订阅 void subscibe(ObserverType *obs) &#123; auto itor = std::find(m_observerList.begin(), m_observerList.end(), obs); if (m_observerList.end() == itor) &#123; m_observerList.push_back(obs); &#125; &#125; //取消订阅 void unSubscibe(ObserverType *obs) &#123; m_observerList.erase(std::remove(m_observerList.begin(), m_observerList.end(), obs)); &#125; //发布。这里的模板参数为函数类型。 template &lt;typename FuncType&gt; void publish(FuncType func) &#123; for (auto obs: m_observerList) &#123; //调用回调函数，将obs作为第一个参数传递 func(obs); &#125; &#125;private: std::vector&lt;ObserverType *&gt; m_observerList;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//main.cpp#include \"Subject.hpp\"#include &lt;functional&gt;#include &lt;iostream&gt;using std::cout;using std::endl;//CatObserver 接口 猫的观察者class CatObserver &#123;public: //猫叫事件 virtual void onMiaow() = 0;public: virtual ~CatObserver() &#123;&#125;&#125;;//Tom 继承于Subject模板类，模板参数为CatObserver。这样Tom就拥有了订阅、发布的功能。class Tom : public Subject&lt;CatObserver&gt;&#123;public: void miaoW() &#123; cout &lt;&lt; \"喵!\" &lt;&lt; endl; //发布\"猫叫\"。 //这里取CatObserver类的成员函数指针onMiaow。而成员函数指针调用时，要传递一个对象的this指针才行的。 //所以用std::bind 和 std::placeholders::_1将第一个参数 绑定为 函数被调用时的第一个参数，也就是前面Subject::publish中的obs publish(std::bind(&amp;CatObserver::onMiaow, std::placeholders::_1)); &#125;&#125;;//Jerry 继承于 CatObserverclass Jerry: public CatObserver&#123;public: //重写“猫叫事件” void onMiaow() override &#123; //发生 “猫叫”时 调用 逃跑 RunAway(); &#125; void RunAway() &#123; cout &lt;&lt; \"那只猫又来了，快溜！\" &lt;&lt; endl; &#125;&#125;;int main(int argc, char *argv[])&#123; Tom tom; Jerry jerry; //拿jerry去订阅Tom的 猫叫事件 tom.subscibe(&amp;jerry); tom.miaoW(); return 0;&#125; 任意类只要继承Subject模板类，提供观察者参数，就拥有了发布-订阅功能。 Qt的信号-槽信号-槽简介信号-槽 是Qt自定义的一种通信机制，它不同于标准C/C++ 语言。 信号-槽的使用方法，是在普通的函数声明之前，加上signal、slot标记，然后通过connect函数把信号与槽 连接起来。 后续只要调用 信号函数,就可以触发连接好的信号或槽函数。 连接的时候，前面的是发送者，后面的是接收者。信号与信号也可以连接，这种情况把接收者信号看做槽即可。 信号-槽分两种信号-槽要分成两种来看待，一种是同一个线程内的信号-槽，另一种是跨线程的信号-槽。 同一个线程内的信号-槽，就相当于函数调用，和前面的观察者模式相似，只不过信号-槽稍微有些性能损耗(这个后面细说)。 跨线程的信号-槽，在信号触发时，发送者线程将槽函数的调用转化成了一次“调用事件”，放入事件循环中。 接收者线程执行到下一次事件处理时，处理“调用事件”，调用相应的函数。 (关于事件循环，可以参考专栏上一篇文章《Qt实用技能3-理解事件循环》) 信号-槽的实现 元对象编译器moc信号-槽的实现，借助一个工具：元对象编译器MOC(Meta Object Compiler)。 这个工具被集成在了Qt的编译工具链qmake中，在开始编译Qt工程时，会先去执行MOC，从代码中 解析signals、slot、emit等等这些标准C/C++不存在的关键字，以及处理Q_OBJECT、Q_PROPERTY、 Q_INVOKABLE等相关的宏，生成一个moc_xxx.cpp的C++文件。(使用黑魔法来变现语法糖) 比如信号函数只要声明、不需要自己写实现，就是在这个moc_xxx.cpp文件中，自动生成的。 MOC之后就是常规的C/C++编译、链接流程了。 moc的本质-反射MOC的本质，其实是一个反射器。标准C++没有反射功能(将来会有)，所以Qt用moc实现了反射功能。 什么叫反射呢？ 简单来说，就是运行过程中，获取对象的构造函数、成员函数、成员变量。 举个例子来说明，有下面这样一个类声明： 1234567891011121314class Tom &#123;public: Tom() &#123;&#125; const std::string &amp; getName() const &#123; return m_name; &#125; void setName(const std::string &amp;name) &#123; m_name = name; &#125;private: std::string m_name;&#125;; 类的使用者,看不到类的声明,头文件都拿不到,不能直接调用类的构造函数、成员函数。 从配置文件/网络拿到了一段字符串“Tom”，就要创建一个Tom类的对象实例。 然后又拿到一段“setName”的字符串，就要去调用Tom的setName函数。 面对这种需求，就需要把Tom类的构造函数、成员函数等信息存储起来，还要能够被调用到。 这些信息就是 “元信息”，使用者通过“元信息”就可以“使用这个类”。这便是反射了。 设计模式中的“工厂模式”，就是一个典型的反射案例。不过工厂模式只解决了构造函数的调用，没有成员函数、成员变量等信息。 反射包括 编译期静态反射 和 运行期动态反射。。。 文章有点长了，这次先到这里，剩下的下次再讨论。 参考文献[1] Qt帮助文档, 搜索关键词 Signals &amp; Slots[2] IBM文档库 https://www.ibm.com/developerworks/cn/linux/guitoolkit/qt/signal-slot/index.html","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qt实用技能","slug":"Qt实用技能","permalink":"https://jaredtao.github.io/tags/Qt%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"},{"name":"QtCreator","slug":"QtCreator","permalink":"https://jaredtao.github.io/tags/QtCreator/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qt(5)-理解事件循环","slug":"玩转Qt(5)-理解事件循环","date":"2019-07-06T10:44:23.000Z","updated":"2020-12-25T10:06:08.979Z","comments":true,"path":"2019/07/06/玩转Qt(5)-理解事件循环/","link":"","permalink":"https://jaredtao.github.io/2019/07/06/%E7%8E%A9%E8%BD%ACQt(5)-%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","excerpt":"","text":"简介 事件与事件循环 Hello World 循环处理 类比事件循环的概念 不同操作系统的事件循环 Windows Linux X11窗口 MacOS Cocoa Application Qt的事件循环 QEventLoop类 QCoreApplication 主事件循环 Qt的事件分发和事件处理 重载事件 QEvent 事件过滤器 事件循环的运用 processEvents不阻塞UI QEventLoop模拟同步调用 简介这次讨论事件循环相关的知识点。 事件与事件循环Hello World从Hello World说起吧 123456#include &lt;stdio.h&gt;int main(int argc, char *argv[]) &#123; printf(\"Hello World\"); return 0;&#125; 这是一段大家都很熟悉的命令行程序，运行起来会在终端输出”Hello World”，之后程序就退出了。 循环处理我们稍微加点需求: 程序能够一直运行，每次用户输入一些信息并按下回车时，打印出用户的输入。直到输入的内容为“quit”时才退出。 按照这个需求，代码实现如下： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char* argv[])&#123; char input[1024]; //假设输入长度不超过1024 const char quitStr[] = \"quit\"; bool quit = false; while (false == quit) &#123; scanf_s(\"%s\", input, sizeof input); printf(\"user input: %s\\n\", input); if (0 == memcmp(input, quitStr, sizeof quitStr)) &#123; quit = true; &#125; &#125; return 0;&#125; 我们使用了一个while循环。在这个循环体内，不停地处理用户的输入。当输入的内容为”quit”时，循环终止条件被设置为true，循环将终止。 类比事件循环的概念在上面这个例子中，“用户输入并按下回车”这件事情，我们可以称作一个“事件”或者“用户输入事件”，不停的去处理“事件”的这段代码， 我们可以称作“事件循环”, 也可以叫做”消息循环”，是一回事。 一般对于带UI窗口的程序来说，“事件”是由操作系统或程序框架在不同的时刻发出的。 当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，计时器触发的时候，都会发出一个相应的事件。 我们把“事件循环”的代码 提炼/抽象 如下： 12345678910111213function loop() &#123; initialize(); bool shouldQuit = false; while(false == shouldQuit) &#123; var message = get_next_message(); process_message(message); if (message == QUIT) &#123; shouldQuit = true; &#125; &#125;&#125; 在事件循环中, 不停地去获取下一个事件，然后做出处理。直到quit事件发生，循环结束。 有“取事件”的过程，那么自然有“存储事件”的地方，要么是操作系统存储，要么是软件框架存储。 存储事件的地方，我们称作 “事件队列” Event Queue 处理事件，我们也称作 “事件分发” Event Dispatch 不同操作系统的事件循环Windows先来看一个Windows系统的事件循环示例(win32 API)： 123456789101112131415MSG msg = &#123; 0 &#125;;bool done = false;bool result = false;while (!done)&#123; if (PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; if (msg.message == WM_QUIT) &#123; done = true; &#125;&#125; 思路和前面介绍的一致 Linux X11窗口有些linux系统使用X11窗口系统，看看其窗口事件循环 12345678910111213141516171819202122232425Atom wmDeleteMessage = XInternAtom(mDisplay, \"WM_DELETE_WINDOW\", False);XSetWMProtocols(display, window, &amp;wmDeleteMessage, 1);XEvent event;bool running = true;while (running)&#123; XNextEvent(display, &amp;event); switch (event.type) &#123; case Expose: printf(\"Expose\\n\"); break; case ClientMessage: if (event.xclient.data.l[0] == wmDeleteMessage) running = false; break; default: break; &#125;&#125; 思路也是和前面一致的 MacOS Cocoa Application在Cocoa Application中, 有一种获取事件的机制，叫做runloop(一个NSRunLoop对象,它允许进程接收窗口服务的各种事件) 一般的Cocoa Application运行流程是，从runloop的事件队列中获取一个事件(NSEvent) 派发事件(NSEvent)到合适的对象(Object) 事件被处理完成后,再取下一个事件(NSEvent),直到应用退出. 思路也是和前面一致的。 Qt的事件循环Qt作为一个跨平台的UI框架，其事件循环实现原理, 就是把不同平台的事件循环进行了封装，并提供统一的抽象接口。 和Qt做了类似工作的，还有glfw、SDL等等很多开源库。 QEventLoop类QEventLoop即Qt中的事件循环类，主要接口如下： 123456int exec(QEventLoop::ProcessEventsFlags flags = AllEvents)void exit(int returnCode = 0)bool isRunning() constbool processEvents(QEventLoop::ProcessEventsFlags flags = AllEvents)void processEvents(QEventLoop::ProcessEventsFlags flags, int maxTime)void wakeUp() 其中exec是启动事件循环，调用exec以后，调用exec的函数就会被“阻塞”，直到EventLoop里面的while循环结束。 这里画个简单的示意图: exit是退出事件循环(将EventLoop中的退出标识设为true) processEvents是及时处理队列中的事件(这个很有用，后面还会讲)。 这里有个问题，exec阻塞了当前函数，还怎么退出EventLoop呢？ 答案是：在派发事件后，某个事件处理的函数中，达到事件退出条件时，调用exit函数，将EventLoop中的退出标识设为true。 这样的程序运行流程，我们叫做 “事件驱动”式的程序。 QCoreApplication 主事件循环一般的Qt程序，main函数中都有一个QCoreApplication/QGuiApplication/QApplication，并在末尾调用 exec。 12345678int main(int argc, char *argv[])&#123; QCoreApplication app(argc, argv); //或者QGuiApplication， 或者 QApplication ... ... return app.exec();&#125; Application类中，除去启动参数、版本等相关东西后，关键就是维护了一个QEventLoop，Application的exec就是QEventLoop的exec。 不过Application中的这个EventLoop，我们称作“主事件循环”Main EventLoop。 所有的事件分发、事件处理都从这里开始。 Application还提供了sendEvent和poseEvent两个函数，分别用来发送事件。 sendEvent发出的事件会立即被处理，也就是“同步”执行。 postEvent发送的事件会被加入事件队列，在下一轮事件循环时才处理，也就是“异步”执行。 还有一个特殊的sendPostedEvents，是将已经加入队列中的准备异步执行的事件立即同步执行。 Qt的事件分发和事件处理以QWidget为例来说明。 QWidget是Widget框架中，大部分UI组件的基类。QWidget类拥有一些名字为xxxEvent的虚函数,比如： 12virtual void keyPressEvent(QKeyEvent *event)virtual void keyReleaseEvent(QKeyEvent *event) keyPressEvent就表示按键按下时的处理，keyReleaseEvent表示按键松开时的处理。 主事件循环中(注册过QWidget类之后)，事件分发会在按键按下时调用QWidget的keyPressEvent函数，按键松开时调用QWidget的keyReleaseEvent函数。 重载事件有了上面的事件处理机制，我们就可以在自己的QWidget子类中，通过重载keyPressEvent、keyReleaseEvent等等事件处理函数，做一些自定义的事件处理。 QEvent每一个事件处理函数，都是带有参数的，这个参数是QEvent的子类，携带了各种事件的参数。比如 按键事件 void keyPressEvent(QKeyEvent *event) 中的QKeyEvent, 就包括了按下的按键值key、 count等等。 事件过滤器Qt还提供了事件过滤机制，在事件分发之前先过滤一部分事件。 用法如下： 123456789101112131415161718192021222324class KeyPressEater : public QObject&#123; Q_OBJECT ...protected: bool eventFilter(QObject *obj, QEvent *event) override;&#125;;bool KeyPressEater::eventFilter(QObject *obj, QEvent *event)&#123; if (event-&gt;type() == QEvent::KeyPress) &#123; QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(event); qDebug(\"Ate key press %d\", keyEvent-&gt;key()); return true; &#125; else &#123; // standard event processing return QObject::eventFilter(obj, event); &#125;&#125;。。。 monitoredObj-&gt;installEventFilter(filterObj); 自定义一个QObject子类，重载eventFilter函数。之后在要过滤的QObject对象上，调用installEventFilter函数以安装过滤器上去。 过滤器函数的返回值为bool，true表示这个事件被过滤掉了，不用再往下分发了。false表示没有过滤。 事件循环的运用processEvents不阻塞UI我们的UI界面，要持续不断地刷新（对于QWidget就是触发paintEvent事件），以保证显示流畅、能及时响应用户输入。 一般要有一个良好的帧率，比如每秒刷新60帧, 即经常说的FPS 60， 换算一下 1000 ms/ 60 ≈ 16 ms,也就是每隔16毫秒刷新一次。 而我们有时候又需要做一些复杂的计算，这些计算的耗时远远超过了16毫秒。 在没有计算完成之前，函数不会退出（相当于阻塞），事件循环得不到及时处理，就会发生UI卡住的现象。 这种场景下，就可以使用Qt为我们提供的接口，立即处理一次事件循环，来保证UI的流畅 (后续再讨论多线程) 1234567//耗时操作someWork1()//适当的位置，插入一个processEvents,保证事件循环被处理QCoreApplication::processEvents();//耗时操作someWork2() QEventLoop模拟同步调用经常会有这种场景： “触发 ”了某项操作，必须等该操作完成后才能进行“ 下一步 ” 比如：软件的登录界面，向服务器发起登录请求后，必须等收到服务器返回的登录数据，才知道登录结果并决定下一步如何执行。 这种场景，如果设计成异步调用，直接用Qt的信号/槽即可，如果要设计成同步调用，就可以使用本地QEventLoop 这里写段伪代码示例一下： 1234567891011121314151617181920bool login(const QString &amp;userName, const QString &amp;passwdHash, const QString &amp;slat)&#123; //声明本地EventLoop QEventLoop loop; bool result = false; //先连接好信号 connect(&amp;network, &amp;Network::result, [&amp;](bool r, const QString &amp;info)&#123; result = r; qDebug() &lt;&lt; info; //槽中退出事件循环 loop.quit(); &#125;); //发起登录请求 sendLoginRequest(userName, passwdHash, slat); //启动事件循环。阻塞当前函数调用，但是事件循环还能运行。 //这里不会再往下运行，直到前面的槽中，调用loop.quit之后，才会继续往下走 loop.exec(); //返回result。loop退出之前，result中的值已经被更新了。 return result;&#125;","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qt实用技能","slug":"Qt实用技能","permalink":"https://jaredtao.github.io/tags/Qt%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qml(16)-移植ShaderToy","slug":"玩转Qml(16)-移植ShaderToy","date":"2019-07-04T05:44:23.000Z","updated":"2020-11-10T04:11:32.856Z","comments":true,"path":"2019/07/04/玩转Qml(16)-移植ShaderToy/","link":"","permalink":"https://jaredtao.github.io/2019/07/04/%E7%8E%A9%E8%BD%ACQml(16)-%E7%A7%BB%E6%A4%8DShaderToy/","excerpt":"","text":"简介 源码 效果预览 穿云洞 星球之光 蜗牛 超级马里奥 关于ShaderToy 关于ShaderEffect ShaderToy原理 约定的变量 glsl版本号 glsl版本兼容 ShaderToy适配 TaoShaderToy 简介这次涛哥将会教大家移植ShaderToy的特效到Qml 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 效果预览先看几个效果图 穿云洞 星球之光 蜗牛 超级马里奥 gif录制质量较低，可编译运行TaoQuick源码或使用涛哥打包好的可执行程序，查看实际运行效果。 可执行程序下载链接(包括windows 和 MacOS平台) https://github.com/jaredtao/TaoQuick/releases 关于ShaderToy学习过计算机图形学的人，都应该知道大名鼎鼎的ShaderToy网站 用一些Shader代码和简单的纹理，就可以输出各种酷炫的图形效果和音频效果。 如果你还不知道，赶紧去看看吧https://www.shadertoy.com 顺便提一下，该网站的作者是IQ大神，这里有他的博客： http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm 本文主要讨论图形效果，音频效果以后再实现。 关于ShaderEffectQml中实现ShaderToy，最快的途径就是ShaderEffect了。 上一篇文章《Qml特效-着色器效果ShaderEffect》已经介绍过ShaderEffect了, 本文重点是移植ShaderToy。 在涛哥写这篇文章之前，已经有两位前辈做过相关的研究。 陈锦明： https://zhuanlan.zhihu.com/p/38942460 qyvlik: https://zhuanlan.zhihu.com/p/44417680 涛哥参考了他们的实现，做了一些改进、完善。 在此感谢两位前辈。 下面正文开始 ShaderToy原理OpenGL的可编程渲染管线中，着色器代码是可以动态编译、加载到GPU运行的。 而OpenGL又包括了桌面版(OpenGL Desktop)、嵌入式版(OpenGL ES)以及网页版(WebGL) ShaderToy网站是以WebGL 2.0为基础，提供内置函数、变量，并约定了一些输入变量，由用户按照约定编写着色器代码。 只要不是太老的OpenGL版本，内置函数、变量基本都是通用的。 约定的变量ShaderToy网站约定的变量如下： 1234567891011vec3 iResolution image/buffer The viewport resolution (z is pixel aspect ratio, usually 1.0)float iTime image/sound/buffer Current time in secondsfloat iTimeDelta image/buffer Time it takes to render a frame, in secondsint iFrame image/buffer Current framefloat iFrameRate image/buffer Number of frames rendered per secondfloat iChannelTime[4] image/buffer Time for channel (if video or sound), in secondsvec3 iChannelResolution[4] image/buffer/sound Input texture resolution for each channelvec4 iMouse image/buffer xy = current pixel coords (if LMB is down). zw = click pixelsampler2D iChannel&#123;i&#125; image/buffer/sound Sampler for input textures ivec4 iDate image/buffer/sound Year, month, day, time in seconds in .xyzwfloat iSampleRate image/buffer/sound The sound sample rate (typically 44100) Qml中的相应实现 123456789101112131415161718192021222324252627282930313233ShaderEffect &#123; id: shader //properties for shader //not pass to shader readonly property vector3d defaultResolution: Qt.vector3d(shader.width, shader.height, shader.width / shader.height) function calcResolution(channel) &#123; if (channel) &#123; return Qt.vector3d(channel.width, channel.height, channel.width / channel.height); &#125; else &#123; return defaultResolution; &#125; &#125; //pass readonly property vector3d iResolution: defaultResolution property real iTime: 0 property real iTimeDelta: 100 property int iFrame: 10 property real iFrameRate property vector4d iMouse; property var iChannel0; //only Image or ShaderEffectSource property var iChannel1; //only Image or ShaderEffectSource property var iChannel2; //only Image or ShaderEffectSource property var iChannel3; //only Image or ShaderEffectSource property var iChannelTime: [0, 1, 2, 3] property var iChannelResolution: [calcResolution(iChannel0), calcResolution(iChannel1), calcResolution(iChannel2), calcResolution(iChannel3)] property vector4d iDate; property real iSampleRate: 44100 ...&#125; 其中时间、日期通过Timer刷新，鼠标位置用MouseArea刷新。 同时涛哥导出了hoverEnabled、running属性和restart函数，以方便Qml中控制Shader的运行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647ShaderEffect &#123; id: shader... //properties for Qml controller property alias hoverEnabled: mouse.hoverEnabled property bool running: true function restart() &#123; shader.iTime = 0 running = true timer1.restart() &#125; Timer &#123; id: timer1 running: shader.running triggeredOnStart: true interval: 16 repeat: true onTriggered: &#123; shader.iTime += 0.016; &#125; &#125; Timer &#123; running: shader.running interval: 1000 onTriggered: &#123; var date = new Date(); shader.iDate.x = date.getFullYear(); shader.iDate.y = date.getMonth(); shader.iDate.z = date.getDay(); shader.iDate.w = date.getSeconds() &#125; &#125; MouseArea &#123; id: mouse anchors.fill: parent onPositionChanged: &#123; shader.iMouse.x = mouseX shader.iMouse.y = mouseY &#125; onClicked: &#123; shader.iMouse.z = mouseX shader.iMouse.w = mouseY &#125; &#125;...&#125; glsl版本号GLSL Versions OpenGL Version GLSL Version 2.0 110 2.1 120 3.0 130 3.1 140 3.2 150 3.3 330 4.0 400 4.1 410 4.2 420 4.3 430 GLSL ES Versions (Android, iOS, WebGL) OpenGL ES Version GLSL ES Version 2.0 100 3.0 300 glsl版本兼容ShaderToy限定了WebGL 2.0，而我们移植到Qml中，自然是希望能够在所有可以运行Qml的设备上运行ShaderToy效果。 所以要做一些glsl版本相关的处理。 涛哥研究了Qt的GraphicsEffects模块源码，它的版本处理要么默认，要么 150 core，显然是不够用的。 glsl各个版本的差异，可以参考这里 https://github.com/mattdesl/lwjgl-basics/wiki/glsl-versions 涛哥总结出了如下的代码和注释说明： 注意”#version xxx”必须是着色器的第一行，不能换行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 // 如果环境是OpenGL ES2，默认的version是 version 110, 不需要写出来。 // 比ES2更老的版本是ES 1.0 和 ES 1.1, 这种古董设备，建议还是不要玩Shader了吧。 // ES2没有texture函数，要用旧的texture2D代替 // 精度限定要写成float readonly property string gles2Ver: \"#define texture texture2Dprecision mediump float;\" // 如果环境是OpenGL ES3，version是 version 300 es // ES 3.1 ES 3.2也可以。 // ES3可以用in out 关键字，gl_FragColor也可以用out fragColor取代 // 精度限定要写成float readonly property string gles3Ver: \"#version 300 es#define varying in#define gl_FragColor fragColorprecision mediump float;out vec4 fragColor;\" // 如果环境是OpenGL Desktop 3.x，version这里参考Qt默认的version 150。大部分Desktop设备应该 // 都是150, 即3.2版本，第一个区分Core和Compatibility的版本。 // Core是核心模式，只有核心api以减轻负担。相应的Compatibility是兼容模式，保留全部API以兼容低版本。 // Desktop 3.x 可以用in out 关键字，gl_FragColor也可以用out fragColor取代 // 精度限定抹掉，用默认的。不抹掉有些情况下会报错，不能通用。 readonly property string gl3Ver: \"#version 150#define varying in#define gl_FragColor fragColor#define lowp#define mediump#define highpout vec4 fragColor;\" // 如果环境是OpenGL Desktop 2.x，version这里就用2.0的version 110，即2.0版本 // 2.x 没有texture函数，要用旧的texture2D代替 readonly property string gl2Ver: \"#version 110#define texture texture2D\" property string versionString: &#123; if (Qt.platform.os === \"android\") &#123; if (GraphicsInfo.majorVersion === 3) &#123; console.log(\"android gles 3\") return gles3Ver &#125; else &#123; console.log(\"android gles 2\") return gles2Ver &#125; &#125; else &#123; if (GraphicsInfo.majorVersion === 3 ||GraphicsInfo.majorVersion === 4) &#123; return gl3Ver &#125; else &#123; return gl2Ver &#125; &#125; &#125; readonly property string forwardString: versionString + \" varying vec2 qt_TexCoord0; varying vec4 vertex; uniform lowp float qt_Opacity; uniform vec3 iResolution; uniform float iTime; uniform float iTimeDelta; uniform int iFrame; uniform float iFrameRate; uniform float iChannelTime[4]; uniform vec3 iChannelResolution[4]; uniform vec4 iMouse; uniform vec4 iDate; uniform float iSampleRate; uniform sampler2D iChannel0; uniform sampler2D iChannel1; uniform sampler2D iChannel2; uniform sampler2D iChannel3; \" versionString 这里，主要测试了Desktop和 android设备，Desktop只要显卡不太搓，都能运行的。 Android ES3的也是全部支持，ES2的部分不能运行，比如iq大神的蜗牛Shader，使用了textureLod等一系列内置函数，就不能在ES2上面跑。 ShaderToy适配本来是不需要写顶点着色器的。如果我们想把ShaderToy做成一个任意坐标开始的Item来用，就需要适配一下坐标。 涛哥写的顶点着色器如下，仅在默认着色器的基础上，传递qt_Vertex给下一阶段的vertex 123456789101112vertexShader: \" uniform mat4 qt_Matrix; attribute vec4 qt_Vertex; attribute vec2 qt_MultiTexCoord0; varying vec2 qt_TexCoord0; varying vec4 vertex; void main() &#123; vertex = qt_Vertex; gl_Position = qt_Matrix * vertex; qt_TexCoord0 = qt_MultiTexCoord0; &#125;\" 片段着色器这里处理一下，适配出一个符合shaderToy的mainImage作为入口函数 123456789101112readonly property string startCode: \" void main(void) &#123; mainImage(gl_FragColor, vec2(vertex.x, iResolution.y - vertex.y)); &#125;\"readonly property string defaultPixelShader: \" void mainImage(out vec4 fragColor, in vec2 fragCoord) &#123; fragColor = vec4(fragCoord, fragCoord.x, fragCoord.y); &#125;\"property string pixelShader: \"\"fragmentShader: forwardString + (pixelShader ? pixelShader : defaultPixelShader) + startCode 稍微说明一下，qyvlik大佬的Shader使用gl_FragCoord作为片段坐标传进去了，这种用法的ShaderToy坐标将会占据整个Qml的窗口， 而实际ShaderToy坐标不是整个窗口的时候，超出去的地方就会被切掉，显示出来的只有一小部分。 涛哥研究了一番后，顶点着色器把vertex传过来，vertex.x就是x坐标，vertex.y坐标从上到下是0 - height，而gl_FragCoord 从下到上是0 - height， 所以要翻一下。 TaoShaderToy最后，看一下代码的全貌吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187//TaoShaderToy.qmlimport QtQuick 2.12import QtQuick.Controls 2.12/*vec3 iResolution image/buffer The viewport resolution (z is pixel aspect ratio, usually 1.0)float iTime image/sound/buffer Current time in secondsfloat iTimeDelta image/buffer Time it takes to render a frame, in secondsint iFrame image/buffer Current framefloat iFrameRate image/buffer Number of frames rendered per secondfloat iChannelTime[4] image/buffer Time for channel (if video or sound), in secondsvec3 iChannelResolution[4] image/buffer/sound Input texture resolution for each channelvec4 iMouse image/buffer xy = current pixel coords (if LMB is down). zw = click pixelsampler2D iChannel&#123;i&#125; image/buffer/sound Sampler for input textures ivec4 iDate image/buffer/sound Year, month, day, time in seconds in .xyzwfloat iSampleRate image/buffer/sound The sound sample rate (typically 44100)*/ShaderEffect &#123; id: shader //properties for shader //not pass to shader readonly property vector3d defaultResolution: Qt.vector3d(shader.width, shader.height, shader.width / shader.height) function calcResolution(channel) &#123; if (channel) &#123; return Qt.vector3d(channel.width, channel.height, channel.width / channel.height); &#125; else &#123; return defaultResolution; &#125; &#125; //pass readonly property vector3d iResolution: defaultResolution property real iTime: 0 property real iTimeDelta: 100 property int iFrame: 10 property real iFrameRate property vector4d iMouse; property var iChannel0; //only Image or ShaderEffectSource property var iChannel1; //only Image or ShaderEffectSource property var iChannel2; //only Image or ShaderEffectSource property var iChannel3; //only Image or ShaderEffectSource property var iChannelTime: [0, 1, 2, 3] property var iChannelResolution: [calcResolution(iChannel0), calcResolution(iChannel1), calcResolution(iChannel2), calcResolution(iChannel3)] property vector4d iDate; property real iSampleRate: 44100 //properties for Qml controller property alias hoverEnabled: mouse.hoverEnabled property bool running: true function restart() &#123; shader.iTime = 0 running = true timer1.restart() &#125; Timer &#123; id: timer1 running: shader.running triggeredOnStart: true interval: 16 repeat: true onTriggered: &#123; shader.iTime += 0.016; &#125; &#125; Timer &#123; running: shader.running interval: 1000 onTriggered: &#123; var date = new Date(); shader.iDate.x = date.getFullYear(); shader.iDate.y = date.getMonth(); shader.iDate.z = date.getDay(); shader.iDate.w = date.getSeconds() &#125; &#125; MouseArea &#123; id: mouse anchors.fill: parent onPositionChanged: &#123; shader.iMouse.x = mouseX shader.iMouse.y = mouseY &#125; onClicked: &#123; shader.iMouse.z = mouseX shader.iMouse.w = mouseY &#125; &#125; // 如果环境是OpenGL ES2，默认的version是 version 110, 不需要写出来。 // 比ES2更老的版本是ES 1.0 和 ES 1.1, 这种古董设备，还是不要玩Shader了吧。 // ES2没有texture函数，要用旧的texture2D代替 // 精度限定要写成float readonly property string gles2Ver: \"#define texture texture2Dprecision mediump float;\" // 如果环境是OpenGL ES3，version是 version 300 es // ES 3.1 ES 3.2也可以。 // ES3可以用in out 关键字，gl_FragColor也可以用out fragColor取代 // 精度限定要写成float readonly property string gles3Ver: \"#version 300 es#define varying in#define gl_FragColor fragColorprecision mediump float;out vec4 fragColor;\" // 如果环境是OpenGL Desktop 3.x，version这里参考Qt默认的version 150。大部分Desktop设备应该都是150 // 150 即3.2版本，第一个区分Core和Compatibility的版本。Core是核心模式，只有核心api以减轻负担。相应的Compatibility是兼容模式，保留全部API以兼容低版本。 // 可以用in out 关键字，gl_FragColor也可以用out fragColor取代 // 精度限定抹掉，用默认的。不抹掉有些情况下会报错，不能通用。 readonly property string gl3Ver: \"#version 150#define varying in#define gl_FragColor fragColor#define lowp#define mediump#define highpout vec4 fragColor;\" // 如果环境是OpenGL Desktop 2.x，version这里就用2.0的version 110，即2.0版本 // 2.x 没有texture函数，要用旧的texture2D代替 readonly property string gl2Ver: \"#version 110#define texture texture2D\" property string versionString: &#123; if (Qt.platform.os === \"android\") &#123; if (GraphicsInfo.majorVersion === 3) &#123; console.log(\"android gles 3\") return gles3Ver &#125; else &#123; console.log(\"android gles 2\") return gles2Ver &#125; &#125; else &#123; if (GraphicsInfo.majorVersion === 3 ||GraphicsInfo.majorVersion === 4) &#123; return gl3Ver &#125; else &#123; return gl2Ver &#125; &#125; &#125; vertexShader: \" uniform mat4 qt_Matrix; attribute vec4 qt_Vertex; attribute vec2 qt_MultiTexCoord0; varying vec2 qt_TexCoord0; varying vec4 vertex; void main() &#123; vertex = qt_Vertex; gl_Position = qt_Matrix * vertex; qt_TexCoord0 = qt_MultiTexCoord0; &#125;\" readonly property string forwardString: versionString + \" varying vec2 qt_TexCoord0; varying vec4 vertex; uniform lowp float qt_Opacity; uniform vec3 iResolution; uniform float iTime; uniform float iTimeDelta; uniform int iFrame; uniform float iFrameRate; uniform float iChannelTime[4]; uniform vec3 iChannelResolution[4]; uniform vec4 iMouse; uniform vec4 iDate; uniform float iSampleRate; uniform sampler2D iChannel0; uniform sampler2D iChannel1; uniform sampler2D iChannel2; uniform sampler2D iChannel3; \" readonly property string startCode: \" void main(void) &#123; mainImage(gl_FragColor, vec2(vertex.x, iResolution.y - vertex.y)); &#125;\" readonly property string defaultPixelShader: \" void mainImage(out vec4 fragColor, in vec2 fragCoord) &#123; fragColor = vec4(fragCoord, fragCoord.x, fragCoord.y); &#125;\" property string pixelShader: \"\" fragmentShader: forwardString + (pixelShader ? pixelShader : defaultPixelShader) + startCode&#125;","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"特效","slug":"特效","permalink":"https://jaredtao.github.io/tags/%E7%89%B9%E6%95%88/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(15)-着色器效果ShaderEffect","slug":"玩转Qml(15)-着色器效果ShaderEffect","date":"2019-06-22T05:44:23.000Z","updated":"2020-12-25T10:00:28.281Z","comments":true,"path":"2019/06/22/玩转Qml(15)-着色器效果ShaderEffect/","link":"","permalink":"https://jaredtao.github.io/2019/06/22/%E7%8E%A9%E8%BD%ACQml(15)-%E7%9D%80%E8%89%B2%E5%99%A8%E6%95%88%E6%9E%9CShaderEffect/","excerpt":"","text":"简介 关于文章 ShaderEffect 显示器如何显示色彩 GPU渲染流程 渲染管线图 并行管线示意图 着色器语言编码规范 着色器代码示例 示例 着色器代码 顶点着色器 片段着色器 参考文献 简介这次涛哥将会教大家一些ShaderEffect(参考QmlBook,译作：着色器效果)的相关知识。 前面的文章，给大家展示了进场动画，以及页面切换动画，大部分都使用了ShaderEffect，所以这次专门来说一下ShaderEffect。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick ShaderEffect动画只能控制组件的属性整体的变化，做特效需要精确到像素。 Qml中提供了ShaderEffect这个组件，就能实现像素级别的操作。 ShaderEffect允许我们在Qml的渲染引擎SceneGraph上，利用强大的GPU进行渲染。 使用ShaderEffect，需要有一些图形学知识，了解GPU渲染管线，了解图形API如OpenGL、DirectX等，同时也需要一些数学知识。 图形学的知识体系还是非常庞大的，要系统的学习，需要看很多书籍。入门级的比如“红宝书”《OpenGL编程指南》、“蓝宝书”《OpenGL超级宝典》…… 一篇文章是说不完的，涛哥水平也有限。所以本文从实用的角度出发，按照涛哥自己的理解，提炼一些必要的知识点，省略一些无关的细节， 让各位Qt开发者能了解GPU原理，能看懂、甚至于自己写一些简单的着色器代码，就大功告成了。说的不对的地方，也欢迎大佬来指点。 显示器如何显示色彩先来了解一下，显示器是如何显示出各种色彩的。 假如我们把显示器的画面放大100倍，就会看到很多整齐排列的像素点。 继续放大，就会发现每个像素点，由三种发光的元件组成，这三种元件分别发出红、绿、蓝三种颜色的光。三种颜色的光组合在一起， 就是人眼看到的颜色。这就是著名的RGB颜色模型。 如果把这三种光的亮度分为255个等级，就能组合出16777216种不同颜色的光。 GPU的任务，就是通过计算，给出每一个像素的红、绿、蓝 （简称r g b）三种颜色的数值，让显示器去”发出相应的光”。 (这样说可能不太严谨、不太专业，只是方便大家理解。另一方面，本文的目的， 是让大家学习如何写特效，不是去造显卡/造显示器。所以请专业人士见谅！) 注：参考[1] GPU渲染流程我们以画一个填充色的三角形为例，来说明 渲染管线图下图是一个简易的渲染管线，引用自 LearnOpenGL 画一个三角形，要经历顶点着色器、图元装配、几何着色器、片段着色器、光栅化等阶段。 其中蓝色部分是可以自定义的，自定义是指，按照图形API规范，写一段GPU能编译、运行的代码。 (这种代码就是着色器代码。可以自定义的这种渲染管线，就是可编程渲染管线，与之相对的是古老的固定渲染管线。) 这里各个阶段，分别引用一下，LearnOpenGL中的介绍(看不懂可以先跳过，看我画的图)： 1234567891011121314151617181920211 管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。2 图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。3 图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。4 几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。5 片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。 并行管线示意图概念还是挺多的，而且很多教程都有渲染管线图。但是涛哥觉得，对于我们开发Shader来说，一定要有并行的意识，然而大部分 管线图，都没有体现出GPU的并行特性。所以涛哥自己画了一个草图： 解释一下吧，CPU传入了3个顶点到GPU，GPU将这三个顶点，传递给三个顶点着色器。 这里要意识到，顶点着色器开始，就是并行处理了。GPU是很强大的SIMD架构（单指令流多数据流）。 如果我们自定义了一段顶点着色器代码，则三个顶点会同时运行这段代码。（后面的片段着色器代码，就是N个点同时运行） 顶点着色器进行处理，传递给图元装配。 图元装配阶段，进行了顶点扩充，变成N个点，N看作三角形面积所在的点。 之后N个点依次传给 几何着色器-&gt;光栅化-&gt;片段着色器，最后经过测试与混合后，输出到屏幕。 可以自定义编程的，有顶点着色器、几何着色器、片段着色器（有的地方也叫像素着色器），顺带提一下，还有另外三种： 曲面控制着色器、曲面评估着色器 和 计算着色器。 一般我们的关注点，都会在片段着色器上。涛哥之前写的12种特效，就只用了自定义的片段着色器。 著名的ShaderToy网站，也是只关注片段着色器。ShaderToy 着色器语言编码规范我们可以把着色器语言，当作运行在GPU上的C语言。 Qt的ShaderEffect支持的着色器语言包括OpenGL规范中的GLSL，和DirectX规范中的HLSL，这两种着色语法上有些细微的区别，但是可以互相转换。 我们就以glsl为主。详细的语言规范，在khronos的官网, 各个版本都有: https://www.khronos.org/registry/OpenGL/specs/gl/ 桌面版 OpenGL 版本众多，而嵌入式系统也有专用的OpenGL ES。 安卓手机、平板设备一般就是OpenGL ES，新的设备都支持ES 3.0，老的设备一般只支持到ES 2.0 OpenGL ES 的语言规范文档在这里： https://www.khronos.org/registry/OpenGL/specs/es/2.0/ 我们就用Qt默认的版本。 着色器代码示例示例这里用Qt帮助文档中的示例代码，来说明。 1234567891011121314151617181920212223242526272829303132import QtQuick 2.0Rectangle &#123; width: 200; height: 100 Row &#123; Image &#123; id: img; sourceSize &#123; width: 100; height: 100 &#125; source: \"qt-logo.png\" &#125; ShaderEffect &#123; width: 100; height: 100 property variant src: img vertexShader: \" uniform highp mat4 qt_Matrix; attribute highp vec4 qt_Vertex; attribute highp vec2 qt_MultiTexCoord0; varying highp vec2 coord; void main() &#123; coord = qt_MultiTexCoord0; gl_Position = qt_Matrix * qt_Vertex; &#125;\" fragmentShader: \" varying highp vec2 coord; uniform sampler2D src; uniform lowp float qt_Opacity; void main() &#123; lowp vec4 tex = texture2D(src, coord); gl_FragColor = vec4(vec3(dot(tex.rgb, vec3(0.344, 0.5, 0.156))), tex.a) * qt_Opacity; &#125;\" &#125; &#125;&#125; 这段代码的效果是 左边是本来的绿色的Qt的logo，右边是处理过后的灰色logo。 着色器代码ShaderEffect的vertexShader属性就是顶点着色器了，其内容是一段字符串。按照着色器规范实现的。 同样的，fragmentShader属性 即片段着色器。 我们能在着色器中看到void main函数，这个便是着色器代码的入口函数，和C语言很像。 在main之前，还有一些全局变量,我们逐条来说明一下 在顶点着色器中，有这三种不同用处的变量：uniform、attribute、varying。 这些变量的值都是从CPU传递过来的。 如果你写过原生OpenGL的代码，就会知道，其中很大一部分工作，就是在处理CPU数据传递到GPU着色器中。 而Qml的ShaderEffect简化了这些工作，只要写一个property，名字、类型和着色器中的对应上，就可以了。 顶点着色器1attribute highp vec4 qt_Vertex; attribute是”属性”变量，按照前面涛哥画的管线图来说，三个顶点着色器同时运行时，每个着色器中 的attribute值都不一样。这里的qt_Vertex，可以理解为分别是三角形的三个顶点。 highp是精度限定符，这里先忽略，具体细节可以参考语言规范文档。后面的lowp、 medium也是精度限定符。 vec4就是四维向量，类似QVector4D。 qt_Vertex是变量的名字。 这条语句的作用，就是声明一个用来存储顶点的attribute变量qt_Vertex。 uniform是统一变量，三个顶点着色器同时运行时，它们取得的uniform变量值是一样的。 varying表示这个顶点着色器的输出数据，将传递给后面的渲染管线。 12345void main() &#123; coord = qt_MultiTexCoord0; gl_Position = qt_Matrix * qt_Vertex;&#125; 这段main函数，将CPU传进来的纹理坐标qt_MultiTexCoord0数据，通过varying变量coord，传递给了下一个阶段，然后使用矩阵进行了坐标转换， 并将结果存储在glsl的内置变量gl_Position中。 片段着色器片段着色器中，就没有attribute了。uniform是一样的统一变量，varying是上一个阶段传递进来的数据。 1uniform sampler2D src; sampler2D是二维纹理。所谓纹理嘛，可以理解成一张图片，一个Image。 src这个变量，就代表外面传进来的那个Image。 sampler2D也可以是任意可视的Item(通过ShaderEffectSource传递进来) 来看一下main函数 12345void main() &#123; lowp vec4 tex = texture2D(src, coord); gl_FragColor = vec4(vec3(dot(tex.rgb,vec3(0.344, 0.5, 0.156))), tex.a) * qt_Opacity;&#125; 这里使用了纹理 1lowp vec4 tex = texture2D(src, coord); texture2D是一个内置函数，专业术语叫“对纹理进行采样”，什么意思呢？ 假如coord的值是(0,0),那就是对src指代的这张图片，取x=0、y=0的坐标点的像素，作为返回值，存储在tex变量中。 这里注意一下纹理坐标的取值范围。假如Qml中图片的大小是100x100，其取值范围从(0, 0) -&gt; (100, 100) 这里的传进来的纹理坐标，取值范围是(0, 0) -&gt; (1, 1) ，GPU为了方便计算，都进行了归1化处理。将范围缩小到0 - 1 1gl_FragColor = vec4(vec3(dot(tex.rgb, vec3(0.344, 0.5, 0.156) )), tex.a) * qt_Opacity; dot(tex.rgb, vec3(0.344, 0.5, 0.156) ) 是对两个三维向量进行了点乘。 tex.rgb是GLSL中的取值器语法。 tex是一个四维变量，可以用tex.r tex.g tex.b tex.a分别取出其中一维，也可以任意两个组合、三个 组合取值。 rgba可以取值，xyzw也可以取值， stpq也行，但只能三种选一种，不能混用。 vec4（vec3(), tex.a) 是用三维向量再加一个变量，构造四维向量。 这条语句其实是一个RGB转灰度的公式，可以自行搜索相关的资料。 gl_FragColor 是内置变量，表示所在片段着色器的最终的输出颜色。 参考文献[1] https://zhuanlan.zhihu.com/p/43467096 [2] https://learnopengl-cn.github.io/","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"特效","slug":"特效","permalink":"https://jaredtao.github.io/tags/%E7%89%B9%E6%95%88/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(14)-动画特效-梯度","slug":"玩转Qml(14)-动画特效-梯度","date":"2019-06-09T01:44:23.000Z","updated":"2020-11-10T04:11:32.855Z","comments":true,"path":"2019/06/09/玩转Qml(14)-动画特效-梯度/","link":"","permalink":"https://jaredtao.github.io/2019/06/09/%E7%8E%A9%E8%BD%ACQml(14)-%E5%8A%A8%E7%94%BB%E7%89%B9%E6%95%88-%E6%A2%AF%E5%BA%A6/","excerpt":"","text":"简介 关于文章 梯度效果预览 实现原理 简介这是《Qml特效-进场动画》系列文章的第二篇，涛哥将会教大家一些Qml进场动画相关的知识。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 梯度效果预览梯度效果，支持从四个方向梯度出现 实现原理通过数值动画，控制百分比属性percent从0 到100变化 123456789101112131415161718192021222324252627&#x2F;&#x2F;AGrad.qmlimport QtQuick 2.12import QtQuick.Controls 2.12ShaderEffect &#123; ... &#x2F;&#x2F;枚举声明四种方向 enum Direct &#123; FromLeft &#x3D; 0, FromRight &#x3D; 1, FromTop &#x3D; 2, FromBottom &#x3D; 3 &#125; property int dir: ASlowEnter.Direct.FromLeft property int percent: 0 opacity: percent &gt; 0 ? 1 : 0 NumberAnimation &#123; id: animation target: r property: &quot;percent&quot; from: 0 to: 100 alwaysRunToEnd: true loops: 1 duration: 1000 &#125; ...&#125; 在Shader中，使用glsl片段着色器实现像素的控制： 1234567891011121314151617181920212223in vec2 qt_TexCoord0;uniform float qt_Opacity;uniform sampler2D effectSource;uniform int dir;uniform int percent;out vec4 fragColor;void main()&#123; vec4 color = texture2D(effectSource, qt_TexCoord0); float p = float(percent) / 100.0f; float alpha = 1.0f; if (dir == 0 ) &#123; alpha = 1.0 - step(p, qt_TexCoord0.x); &#125; else if (dir == 1)&#123; alpha = 1.0 - step(p, 1.0 - qt_TexCoord0.x); &#125; else if (dir == 2) &#123; alpha = 1.0f - step(p, qt_TexCoord0.y); &#125; else if (dir == 3) &#123; alpha = 1.0f - step(p, 1.0 - qt_TexCoord0.y); &#125; fragColor = vec4(color.rgb, alpha);&#125; 效果比较简单，以从左向右为例(dir == 0), 说明一下: 先是把percent 归一化处理 (float p = percent / 100.0)， 纹理坐标qt_TexCoord0.x的取值范围为 0 - 1，按照Qml的坐标系统，左边为0，右边为1。 之后纹理坐标与p进行比较，坐标小于p则显示(透明度为1)，大于p则不显示(透明度为0). (也可以直接用discard丢弃片段) step是glsl内置函数，step(p, qt_TexCoord0.x) 就是x小于p返回0，大于等于p返回1。 结果正好与上面分析的相反，用1 减去即可： alpha = 1.0 - step(p, qt_TexCoord0.x); 最终输出颜色即可: fragColor = vec4(color.rgb, alpha);","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"特效","slug":"特效","permalink":"https://jaredtao.github.io/tags/%E7%89%B9%E6%95%88/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(13)-动画特效-飞入","slug":"玩转Qml(13)-动画特效-飞入","date":"2019-06-08T04:44:23.000Z","updated":"2020-11-10T04:11:32.855Z","comments":true,"path":"2019/06/08/玩转Qml(13)-动画特效-飞入/","link":"","permalink":"https://jaredtao.github.io/2019/06/08/%E7%8E%A9%E8%BD%ACQml(13)-%E5%8A%A8%E7%94%BB%E7%89%B9%E6%95%88-%E9%A3%9E%E5%85%A5/","excerpt":"","text":"简介 关于文章 飞入效果预览 实现原理 QtQuick动画系统 动画组件 动画的使用 用例一 直接声明动画 用例二 on语法 用例三 Transitions或状态机 ShaderEffect 飞入效果源码 简介这次涛哥将会教大家一些Qml动画相关的知识。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 飞入效果预览第一篇文章，就放一个简单的动画效果 实现原理进场动画，使用了QtQuick的动画系统，以及ShaderEffect特效。 Qml中有一个模块QtGraphicalEffects，提供了部分特效，就是使用ShaderEffect实现的。 使用ShaderEffect实现特效，需要有一些OpenGL/DirectX知识，了解GPU渲染管线，同时也需要一些数学知识。 QtQuick动画系统动画组件Qt动画系统，在帮助文档有详细的介绍，搜索关键词”Animation”，涛哥在这里说一些重点。 涛哥用思维导图列出了Qml中所有的动画组件: 右边带虚线框的部分比较常用，是做动画必须要掌握的，尤其是属性动画PropertyAnimation和数值动画NumberAinmation。常见的各种坐标动画、宽高动画、透明度动画、颜色动画等等，都可以用这些组件来实现。 底下的States、Behavior 和 Traisitions，也是比较常用的和动画相关的组件。可在帮助文档搜索关键词”Qt Quick States”、”Behavior”、”Animation and Transitions”。后续的文章，涛哥会专门讲解。 左边的Animator系列，属于Scene Graph渲染层面的优化，其属性Change信号只在最终值时发出，不发出中间值，使用的时候需要注意。 顶上的AnimationController，属于高端玩家，用来控制整个动画的进度。 动画的使用用例一 直接声明动画直接声明动画，指定target和property，之后可以在槽函数/js脚本中通过id控制动画的运行。 也可以通过设定loops 和 running属性来控制动画 1234567891011121314151617181920212223242526Rectangle &#123; id: flashingblob width: 75; height: 75 color: \"blue\" opacity: 1.0 MouseArea &#123; anchors.fill: parent onClicked: &#123; animateColor.start() animateOpacity.start() &#125; &#125; PropertyAnimation &#123;id: animateColor; target: flashingblob; properties: \"color\"; to: \"green\"; duration: 100&#125; NumberAnimation &#123; id: animateOpacity target: flashingblob properties: \"opacity\" from: 0.99 to: 1.0 loops: Animation.Infinite easing &#123;type: Easing.OutBack; overshoot: 500&#125; &#125;&#125; 用例二 on语法on语法可以使用动画组件，也可以用Behavior，直接on某个特定的属性即可。效果一样。 on动画中，如果直接指定了running属性，默认就会执行这个动画。 也可以不指定running属性，其它地方修改这个属性时，会自动按照动画来执行。 示例代码 on动画 123456789Rectangle &#123; width: 100; height: 100; color: &quot;green&quot; RotationAnimation on rotation &#123; loops: Animation.Infinite from: 0 to: 360 running: true &#125;&#125; 示例代码 Behavior 动画 12345678910111213141516import QtQuick 2.0Rectangle &#123; id: rect width: 100; height: 100 color: &quot;red&quot; Behavior on width &#123; NumberAnimation &#123; duration: 1000 &#125; &#125; MouseArea &#123; anchors.fill: parent onClicked: rect.width &#x3D; 50 &#125;&#125; 用例三 Transitions或状态机过渡动画和状态机动画，本质还是直接使用动画组件。只不过是把动画声明并存储起来，以在状态切换时使用。 这里先不细说了，后面会有系列文章&lt;Qml特效-页面切换动画&gt;，会专门讲解。 ShaderEffect动画只能控制组件的属性整体的变化，做特效需要精确到像素。 Qml中提供了ShaderEffect这个组件，就能实现像素级别的操作。 大名鼎鼎的ShaderToy网站，就是使用Shader实现各种像素级别的酷炫特效。 ShaderToy 作者iq大神 ShaderToy上面的特效都是可以移植到Qml中的。 使用Shader开发，需要一定的图形学知识。其中使用GLSL需要熟悉OpenGL, 使用HLSL需要熟悉DirectX。 飞入效果源码封装了一个平移进入的动画组件,能够支持从四个方向进场。 12345678910111213141516171819202122232425262728293031323334353637//ASlowEnter.qmlimport QtQuick 2.12import QtQuick.Controls 2.12import \"../..\"Item &#123; id: r property int targetX: 0 property int targetY: 0 property alias animation: animation enum Direct &#123; FromLeft = 0, FromRight = 1, FromTop = 2, FromBottom = 3 &#125; property int dir: ASlowEnter.Direct.FromBottom property int duration: 2000 //额外的距离，组件在父Item之外时，额外移动一点，避免边缘暴露在父Item的边缘 property int extDistance: 10 property var __propList: [\"x\", \"x\", \"y\", \"y\"] property var __fromList: [ -r.parent.width - r.width - extDistance, r.parent.width + r.width + extDistance, -r.parent.height - r.height - extDistance, r.parent.height + r.height + extDistance] property var __toList: [targetX, targetX, targetY, targetY] NumberAnimation &#123; id: animation target: r property: __propList[dir] from: __fromList[dir] to: __toList[dir] duration: r.duration loops: 1 alwaysRunToEnd: true &#125;&#125; 进场组件的使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//Enter.qmlimport QtQuick 2.12import QtQuick.Controls 2.12import \"../Animation/Enter\"Item &#123; anchors.fill: parent ASlowEnter &#123; id: a1 width: 160 height: 108 x: (parent.width - width) / 2 targetY: parent.height / 2 dir: ASlowEnter.Direct.FromBottom Image &#123; anchors.fill: parent source: \"qrc:/EffectImage/Img/baby.jpg\" &#125; &#125; ASlowEnter &#123; id: a2 width: 160 height: 108 x: (parent.width - width) / 2 targetY: parent.height / 2 - height dir: ASlowEnter.Direct.FromTop Image &#123; anchors.fill: parent source: \"qrc:/EffectImage/Img/baby.jpg\" &#125; &#125; ASlowEnter &#123; id: a3 width: 160 height: 108 targetX: parent.width / 2 - width * 1.5 y: (parent.height - height) / 2 dir: ASlowEnter.Direct.FromLeft Image &#123; anchors.fill: parent source: \"qrc:/EffectImage/Img/baby.jpg\" &#125; &#125; ASlowEnter &#123; id: a4 width: 160 height: 108 targetX: parent.width / 2 + width / 2 y: (parent.height - height) / 2 dir: ASlowEnter.Direct.FromRight Image &#123; anchors.fill: parent source: \"qrc:/EffectImage/Img/baby.jpg\" &#125; &#125; ParallelAnimation &#123; id: ani ScriptAction&#123; script: &#123;a1.animation.restart()&#125; &#125; ScriptAction&#123; script: &#123;a2.animation.restart()&#125; &#125; ScriptAction&#123; script: &#123;a3.animation.restart()&#125; &#125; ScriptAction&#123; script: &#123;a4.animation.restart()&#125; &#125; &#125; Component.onCompleted: &#123; ani.restart() &#125; Button &#123; anchors.right: parent.right anchors.bottom: parent.bottom text: \"replay\" onClicked: &#123; ani.restart() &#125; &#125;&#125;","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"特效","slug":"特效","permalink":"https://jaredtao.github.io/tags/%E7%89%B9%E6%95%88/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(12)-再谈动态国际化","slug":"玩转Qml(12)-再谈动态国际化","date":"2019-06-02T17:44:23.000Z","updated":"2020-12-25T09:59:26.689Z","comments":true,"path":"2019/06/03/玩转Qml(12)-再谈动态国际化/","link":"","permalink":"https://jaredtao.github.io/2019/06/03/%E7%8E%A9%E8%BD%ACQml(12)-%E5%86%8D%E8%B0%88%E5%8A%A8%E6%80%81%E5%9B%BD%E9%99%85%E5%8C%96/","excerpt":"","text":"简介 源码 效果预览 Qt本身的国际化 存在翻译不全的问题 新的方案 关于批量翻译 总结 简介本文是《玩转Qml》系列文章的第十二篇，主要讨论多国语言动态翻译。 之前分享过使用Qt自带翻译的方案，但是效果不太好。这次分享一个非官方的多国语言方案。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 效果预览看一下最终效果 (原始字符串全部为英文，中文为人工翻译。 其它语言使用的百度翻译api批量翻译，不太准确，暂时先这样) Qt本身的国际化先来回顾一下，Qt的国际化方案： C++代码中的字符串使用QObject::tr()包起来，类本身是QObject的子类时可以省略作用域“QObject::”,直接写tr qml代码中使用qsTr把字符串包起来 pro文件中添加一句TRANSLATIONS += trans_zh.qs ，这个名字起什么无所谓，关键是‘_zh’要有。 调用lrelease工具,扫描项目并生成trans_zh.qs 文件。这个文件是xml格式的，未经过翻译的，需要为这个文件做一些翻译工作。 翻译做好后，调用lupdate工具，生成trans_zh.qm文件。这个文件就是把xml压缩成了二进制。 将qm文件放在运行路径，或者资源文件里。 切换语言时， Qt/C++代码中使用QTranslater加载qm文件，QCoreApplication卸载旧的QTranslater，并安装新的QTranslater。调用QmlEngine::retranslate函数 在5.10以前的版本，Qt是不能直接动态切换语言的，要么重新启动程序，要么把所有的text都set一遍，retranslate是5.10才有的接口。 存在翻译不全的问题上面的方案，在TaoQuick中使用了。 明显的问题是，只能翻译静态的内容，动态加载的ListModel，动态切换语言时不能自动刷新。 按照Qt文档所说，Array或者其它数据结构中的内容，也不能自动刷新。 新的方案这里抛弃Qt的翻译机制，使用自己实现的方案。 1、约定要用到的字符串，全部用英文。 2、翻译文件使用json文件，一个文件翻译一种语言。 文件命名格式language_xx.json, json内容格式如下； 123456789101112131415161718192021&#123; \"lang\": \"简体中文\", \"trans\":[ &#123; \"key\": \"Chinese\", \"value\": \"简体中文\" &#125;, &#123; \"key\": \"Japanese\", \"value\": \"日语\" &#125;, &#123; \"key\": \"Korean\", \"value\": \"韩语\" &#125;, &#123; \"key\": \"Menu\", \"value\": \"菜单\" &#125;, ]&#125; 其中lang字段表示当前语言，trans字段是所有的翻译项。 3、实现核心翻译器Trans 自己实现一个Trans类，用来加载翻译包、提供翻译数据，类声明如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Trans.h#pragma once#include &lt;QObject&gt;#include &lt;QHash&gt;#include &lt;QList&gt;#include &lt;QString&gt;class Trans : public QObject&#123; Q_OBJECT //当前语言 Q_PROPERTY(QString currentLang READ currentLang WRITE setCurrentLang NOTIFY currentLangChanged) //支持的语言列表 Q_PROPERTY(QStringList languages READ languages NOTIFY languagesChanged) //空字符串。用于动态翻译时，通过change信号触发trans Q_PROPERTY(QString transString READ transString NOTIFY transStringChanged)public: explicit Trans(QObject *parent = nullptr); //加载指定文件夹 void loadFolder(const QString &amp;folder); //加载指定文件。成功时返回true，lang参数输出文件代表的语言。 bool load(QString &amp;lang, const QString &amp;filePath);public: const QString &amp;currentLang() const; const QStringList &amp;languages() const; const QString &amp;transString() const;public slots: //翻译 QString trans(const QString &amp;source) const; void setCurrentLang(const QString &amp;currentLang);signals: void currentLangChanged(const QString &amp;currentLang); void languagesChanged(const QStringList &amp;languages); void transStringChanged();protected: void setLanguages(const QStringList &amp;languages); void initEnglish();private: QString m_currentLang; // &lt;\"English\", &lt;\"key\", \"value\"&gt;&gt; QHash&lt;QString, QHash&lt;QString, QString&gt;&gt; m_map; QStringList m_languages; //always empty QString m_transString;&#125;; 其中languages是加载过后支持的所有语言，currentLang是当前语言。 trans函数是用来做翻译的，传入要翻译的字符串，根据当前语言，返回翻译后的字符串。 因为软件到处都要翻译，所以trans函数会被频繁调用，使用QHash&lt;QString, QHash&lt;QString, QString&gt;&gt;这样的 嵌套Hash数据结构，保证查询的平均复杂度为O(1). transString是一个特殊的属性，其值始终为空，在语言被切换时，会触发transStringChange信号。 这样有什么用呢？先知道这个设定，后面qml部分会详细解释。 cpp 实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106//Trans.cpp#include \"Trans.h\"#include \"FileReadWrite.h\"#include &lt;QDir&gt;const static auto cEnglisthStr = QStringLiteral(\"English\");const static auto cChineseStr = QStringLiteral(\"简体中文\");Trans::Trans(QObject* parent) : QObject(parent)&#123;&#125;void Trans::loadFolder(const QString&amp; folder)&#123; QDir dir(folder); auto infos = dir.entryInfoList(&#123; \"language_*.json\" &#125;, QDir::Files); for (auto info : infos) &#123; QString lang; load(lang, info.absoluteFilePath()); &#125; initEnglish(); auto langs = m_map.uniqueKeys(); if (langs.contains(cChineseStr)) &#123; langs.removeAll(cChineseStr); langs.push_front(cChineseStr); &#125; setLanguages(langs); if (m_map.contains(cChineseStr)) &#123; setCurrentLang(cChineseStr); &#125; else &#123; setCurrentLang(cEnglisthStr); &#125; emit transStringChanged();&#125;bool Trans::load(QString&amp; lang, const QString&amp; filePath)&#123; lang.clear(); QJsonObject rootObj; if (!TaoCommon::readJsonFile(filePath, rootObj)) &#123; return false; &#125; lang = rootObj.value(\"lang\").toString(); const auto&amp; trans = rootObj.value(\"trans\").toArray(); for (auto i : trans) &#123; auto transObj = i.toObject(); QString key = transObj.value(\"key\").toString(); QString value = transObj.value(\"value\").toString(); m_map[lang][key] = value; &#125; return true;&#125;const QString &amp;Trans::currentLang() const&#123; return m_currentLang;&#125;const QStringList &amp;Trans::languages() const&#123; return m_languages;&#125;const QString &amp;Trans::transString() const&#123; return m_transString;&#125;void Trans::initEnglish()&#123; if (!m_map.contains(cEnglisthStr)) &#123; QHash&lt;QString, QString&gt; map; if (m_map.contains(cChineseStr)) &#123; map = m_map.value(cChineseStr); &#125; else &#123; map = m_map.value(m_map.keys().first()); &#125; for (auto key : map.uniqueKeys()) &#123; m_map[cEnglisthStr][key] = key; &#125; &#125;&#125;QString Trans::trans(const QString&amp; source) const&#123; return m_map.value(m_currentLang).value(source, source);&#125;void Trans::setCurrentLang(const QString&amp; currentLang)&#123; if (m_currentLang == currentLang) return; m_currentLang = currentLang; emit currentLangChanged(m_currentLang); emit transStringChanged();&#125;void Trans::setLanguages(const QStringList&amp; languages)&#123; if (m_languages == languages) return; m_languages = languages; emit languagesChanged(m_languages); emit transStringChanged();&#125; 4、Qml中使用新的翻译语法 qml中的语法如下： 123Text &#123; text: trans.trans(\"Welcome\") + trans.transString&#125; 这是一个很常规的’Qml属性绑定’,或者叫’绑定表达式’, 这样写了以后，text的值依赖于trans.trans()函数返回值和 transString。 当text依赖的属性发出change信号时，qml引擎会重新对这个表达式求值，并把结果赋值给text。 一般情况下，text的值就是trans的返回值，后面的空值不会影响到结果。 当前语言被改变时，函数没有change信号，而transString属性的change信号会被触发，导致qml引擎会重新对这个表达式求值， 此时会重新调用trans函数，按照新的语言返回翻译结果。 Text组件的text属性变化时，会自己刷新UI。 于是，就实现了动态翻译多国语言。 对于ListModel,就把静态字符串换成动态的变量即可： 123456ListView &#123; ... delegate: Text &#123; text: trans.trans(modelData) + trans.transString &#125;&#125; 复杂一些的格式化字符串，也是没有问题的： 123Text &#123; text: trans.trans(\"Today is %1, i feel %2\").arg(trans.trans(\"Sunday\")).arg(trans.trans(\"happy\")) + trans.transString&#125; 对应的翻译文件： 123456789101112131415161718&#123; \"lang\": \"简体中文\", \"trans\": [ &#123; \"key\": \"Today is %1, i feel %2\", \"value\": \"今天是%1, 我感觉%2\" &#125;, &#123; \"key\": \"Sunday\", \"value\": \"星期天\" &#125;, &#123; \"key\": \"happy\", \"value\": \"开心\" &#125;, ... ]&#125; 关于批量翻译翻译效果不太理想，不过还是可以分享一下方法。 首先是提取出了所有要翻译的字符串： 123456789101112131415161718192021222324//key.json[ \"Chinese\", \"traditional Chinese\", \"Cantonese\", \"classical Chinese\", \"Japanese\", \"Korean\", \"French\", \"Spanish\", \"Thai\", \"Arabic\", \"Russian\", \"Portuguese\", \"German\", \"Italian\", \"Greek\", \"Dutch\", \"Polish\", \"Bulgarian\", \"Estonian\", \"Danish\", ...] 其次是写了一个PowerShell脚本，逐个调用百度翻译API，并把结果按照前面的json输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116# trans.ps1# 需要注册百度翻译的app，获得id和secret$baiduId = \"xxxxxxxxxx\"$baiduSecret = \"xxxxxxxxx\"# 列出百度翻译 支持的语言$baiduLangs = @&#123; zh=\"中文\"; # cht=\"繁体中文\"; yue=\"粤语\"; wyw=\"文言文\"; jp=\"日语\"; kor=\"韩语\"; fra=\"法语\"; spa=\"西班牙语\"; th=\"泰语\"; ara=\"阿拉伯语\"; ru=\"俄语\"; pt=\"葡萄牙语\"; de=\"德语\"; it=\"意大利语\"; el=\"希腊语\"; nl=\"荷兰语\"; # pl=\"波兰语\"; bul=\"保加利亚语\"; est=\"爱沙尼亚语\"; dan=\"丹麦语\"; fin=\"芬兰语\"; cs=\"捷克语\"; rom=\"罗马尼亚语\"; # slo=\"斯洛文尼亚语\"; # swe=\"瑞典语\"; hu=\"匈牙利语\"; # vie=\"越南语\";&#125;# 计算MD5function getHash([string]$source) &#123; $stringAsStream = [System.IO.MemoryStream]::new() $writer = [System.IO.StreamWriter]::new($stringAsStream) $writer.write($source) $writer.Flush() $stringAsStream.Position = 0 $hash = Get-FileHash -InputStream $stringAsStream -algorithm MD5 return $hash.Hash.toString().toLower()&#125;# 百度翻译的调用function baiduTrans &#123; param( [string]$q, [string]$from = 'en', [string]$to = 'zh' ) # 随机盐 $salt = Get-Random # token拼接 $signtoken = \"&#123;0&#125;&#123;1&#125;&#123;2&#125;&#123;3&#125;\" -f $baiduId, $q, $salt, $baiduSecret # 计算md5 $signtoken = getHash $signtoken # POST body $body = @&#123; q = $q from = $from to = $to appid = $baiduId salt = $salt sign = $signtoken &#125; $response = Invoke-RestMethod http://api.fanyi.baidu.com/api/trans/vip/translate -Method Post -Body $body #return $response.dst.toString() if ($null -ne $response.trans_result) &#123; return $response.trans_result[0].dst &#125; else &#123; return $q &#125;&#125;# 主函数function main() &#123; # 读取keys.json $json = Get-Content 'keys.json' -Encoding utf8 | ConvertFrom-Json # 每种语言都翻译一遍 foreach ($lang in $baiduLangs.Keys) &#123; Write-Host $lang $tlang = $baiduLangs[$lang] # 目标语言的名称，默认都用中文表示的。这里将名称翻译成对应的语言。比如：英语 就叫'English'， 日语就用'日本語' if ($lang -ne \"zh\") &#123; $tlang = baiduTrans $baiduLangs[$lang] \"zh\" $lang &#125; # 逐条翻译 $res=@() foreach ($key in $json) &#123; Write-Host $key $dst = baiduTrans $key \"en\" $lang $t = @&#123;'key'=$key; 'value'=$dst&#125; $res +=$t # 延时1秒，毕竟没有充值，被限速了，每秒只能请求1次。 Start-Sleep -Seconds 1 &#125; # 按格式输出 $obj = @&#123; \"lang\" = $tlang \"trans\" = $res &#125; $targetFileName = \"language_&#123;0&#125;.json\" -f $lang $obj | ConvertTo-Json | Set-Content $targetFileName -Encoding UTF8 &#125;&#125;# baiduTrans \"apple\" \"en\" \"zh\"main 结果如下，生成了一堆json文件 总结Qml中带个尾巴的写法，虽然有些别扭，但是够用、能达到动态翻译的目标。 如果你有更好的思路，欢迎留言交流。","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(11)-更强的拖动组件","slug":"玩转Qml(11)-更强的拖动组件","date":"2019-06-02T10:44:23.000Z","updated":"2020-12-25T09:59:13.577Z","comments":true,"path":"2019/06/02/玩转Qml(11)-更强的拖动组件/","link":"","permalink":"https://jaredtao.github.io/2019/06/02/%E7%8E%A9%E8%BD%ACQml(11)-%E6%9B%B4%E5%BC%BA%E7%9A%84%E6%8B%96%E5%8A%A8%E7%BB%84%E4%BB%B6/","excerpt":"","text":"简介本文是《玩转Qml》系列文章的第十一篇，之前的&lt;玩转Qml(2)-可以拖动的组件&gt;分享过基本的 拖动组件，这次涛哥将教大家，实现更多功能的可拖动组件。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 效果图 使用封装的组件名称是TemplateBorder。 使用很简单，在要支持拖拽的目标组件上，创建一个TemplateBorder实例即可，例如： 123456789101112131415161718192021222324Rectangle &#123; x: 100 y: 200 width: 300 height: 200 color: \"red\" smooth: true antialiasing: true MouseArea &#123; anchors.fill: parent onClicked: &#123; parent.focus = true &#125; &#125; //这里添加一个边框 TemplateBorder &#123; //注意控制大小 width: parent.width + borderMargin * 2 height: parent.height + borderMargin * 2 anchors.centerIn: parent //目标item有焦点时显示边框 visible: parent.focus &#125;&#125; 原理拖拽的前提目标组件不要用锚布局，不要用Layout布局。 拖拽需要修改目标组件的坐标和宽高，而锚布局、Layout会限定坐标或宽高。 拖拽原理拖拽本身可以使用MouseArea的 drag.target，但这个target限制为item及其子类。 有时候还需要处理无边框窗口的拖动，窗口不是item，就不能用drag.target。 所以需要一个通用的拖拽算法： 12345678910111213141516171819202122...MouseArea &#123; id: mouseArea anchors.fill: parent property int lastX: 0 property int lastY: 0 onPressedChanged: &#123; if (containsPress) &#123; //按下鼠标时记录坐标 lastX = mouseX; lastY = mouseY; &#125; &#125; onPositionChanged: &#123; if (pressed) &#123; //拖动时修改目标的坐标 parent.x += mouseX - lastX parent.y += mouseY - lastY &#125; &#125;&#125;... 锚点锚点就是在组件的左上角、右上角等八个点，分别放一个小圆圈，圆圈里面是可拖拽组件，分别控制组件的坐标、宽高。 注意每个点的计算规则都不太一样。 例如左上角，要同时计算x、y和宽高，而右上角则只计算y、和宽高： 123456789101112131415161718192021222324252627282930313233343536373839Item &#123; id: root //controller 要控制大小的目标，可以是Item，也可以是view，只要提供x、y、width、height等属性的修改 //默认值为parent property var control: parent //左上角的拖拽 TDragItem &#123; id: leftTopHandle posType: posLeftTop onPosChange: &#123; if (control.x + xOffset &lt; control.x + control.width) control.x += xOffset; if (control.y + yOffset &lt; control.y + control.height) control.y += yOffset; if (control.width - xOffset &gt; 0) control.width-= xOffset; if (control.height -yOffset &gt; 0) control.height -= yOffset; &#125; &#125; //右上角拖拽 TDragItem &#123; id: rightTopHandle posType: posRightTop x: parent.width - width onPosChange: &#123; //向左拖动时，xOffset为负数 if (control.width + xOffset &gt; 0) control.width += xOffset; if (control.height - yOffset &gt; 0) control.height -= yOffset; if (control.y + yOffset &lt; control.y + control.height) control.y += yOffset; &#125; &#125; ... ...&#125; 旋转旋转算法和拖拽类似 12345678910111213141516171819MouseArea &#123; id: rotateArea anchors.centerIn: parent property int lastX: 0 onPressedChanged: &#123; if (containsPress) &#123; lastX = mouseX; &#125; &#125; onPositionChanged: &#123; if (pressed) &#123; let t = controller.rotation +(mouseX - lastX) / 5 //这里的除以5，用来消除抖动。 t = t % 360 controller.rotation = t &#125; &#125;&#125;","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qt实用技能","slug":"Qt实用技能","permalink":"https://jaredtao.github.io/tags/Qt%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"},{"name":"Qt发布","slug":"Qt发布","permalink":"https://jaredtao.github.io/tags/Qt%E5%8F%91%E5%B8%83/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(10)-自定义Quick模块","slug":"玩转Qml(10)-自定义Quick模块","date":"2019-06-01T04:44:23.000Z","updated":"2020-12-25T09:59:00.594Z","comments":true,"path":"2019/06/01/玩转Qml(10)-自定义Quick模块/","link":"","permalink":"https://jaredtao.github.io/2019/06/01/%E7%8E%A9%E8%BD%ACQml(10)-%E8%87%AA%E5%AE%9A%E4%B9%89Quick%E6%A8%A1%E5%9D%97/","excerpt":"","text":"简介 近期讯息 Qt Design Studio TaoQuick Qt资源管理 qrc内容 编译和加载qrc 资源的引用 插件中注册资源 Qml模块 qmldir文件 示例 不用开放Qml源码 Designer支持 metainfo 带资源的组件，需要用C++扩展注册资源 安装 简介本文是《玩转Qml》系列文章的第十篇，涛哥将教大家，Qml自定义模块的知识。 特别是最近的研究结果：如何让Qml模块在Designer中拖拽使用。涛哥希望有更多的人学会这个技能。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 近期讯息(先播点新闻) Qt Design Studio2019年5月20的时候，Qt官方放出了Qt Design Studio的beta版， 免费使用/暂不开源。 下载地址在这： http://download.qt.io/development_releases/qtdesignstudio/1.2/1.2.0-beta1-community/ Qt Design Studio是主要给美工使用的一款UI工具。 Qt在Photo Shop/Sketch这两款工具中，提供了QtBridge插件，可以将设计好的资源直接导出成Qml工程。 导出的工程可以用Qt Design Studio/QtCreator打开，用托托拽拽的方式，实现各种功能、动画等等。 QtDesignStudio目前还不成熟，但未来是一片光明。等Designer做好了，就不再需要手写Qml代码，托托拽拽就能搞定界面部分。 只剩下逻辑处理和后端功能才需要写代码/写js脚本。 Qt Design Studio目前与QtCreator的差异是，前者内置了一些特殊的模块：包括 Shapes图元、Effects等， Qt Design Studio还使用了qmlproject文件作工程管理。 除此之外，功能都是一样的。帧动画编辑器在QtCreator中也是可以使用的。 TaoQuick最新的TaoQuick (tag: 0.1.6), 已经支持在QtCreator中拖拽使用了 代码仓库在这：TaoQuick (下面进入正题) Qt资源管理(有必要先说一下资源管理，这部分内容帮助文档都有，搜索关键词为”rcc” 或 “Qt Resource”) Qt提供了一个资源管理工具rcc，可以将各种资源文件压缩、打包进二进制程序。 通常用来打包各种图片、Qml文件、配置文件或数据文件等等，只要将资源文件添加到qrc文件中即可。 qrc文件是xml格式的文本文件，里面记录着添加的各种资源。 qrc内容示例 TaoResource.qrc: 12345678910&lt;!DOCTYPE RCC&gt;&lt;RCC version=\"1.0\"&gt;&lt;qresource&gt; &lt;file&gt;images/copy.png&lt;/file&gt; &lt;file&gt;images/cut.png&lt;/file&gt; &lt;file&gt;images/new.png&lt;/file&gt; &lt;file&gt;images/open.png&lt;/file&gt; &lt;file&gt;images/paste.png&lt;/file&gt; &lt;file&gt;images/save.png&lt;/file&gt;&lt;/qresource&gt;&lt;/RCC&gt; 编译和加载qrc只要在pro文件中写上 RESOURCES = TaoResource.qrc就可以了。qmake会自动将资源压缩、打包进exe/dll程序 也可以使用命令行手动编译： 1rcc -binary TaoResource.qrc -o TaoResource.rcc 或者 1rcc -binary TaoResource.qrc -o TaoResource.dll 这种方式编译出来的，是一个纯粹的资源插件，扩展名写什么都无所谓的。 可以在代码中动态加载资源、卸载资源 12QResource::registerResource(\"/path/to/TaoResource.rcc\");QResource::unRegisterResource(\"/path/to/TaoResource.rcc\"); 资源的引用使用”:/“ 或者 “qrc:/“开头的路径即可，这两者的区别涛哥未作总结，大家自己实践吧。 1cutAct &#x3D; new QAction(QIcon(&quot;:&#x2F;images&#x2F;cut.png&quot;) 插件中注册资源在Qt插件中，添加了资源的情况下，需要用宏Q_INIT_RESOURCE来注册资源 (Qt插件和前面的rcc编译出来的不一样，不是一个纯粹的资源插件，不能直接被QResource::registerResource识别) 1234567TaoClass::TaoClass() : BaseClass()&#123; Q_INIT_RESOURCE(TaoResource); QFile file(\":/images/save.png\"); ...&#125; Qml模块(这部分内容帮助文档也有，搜索关键词”QML Modules”) 设计Qml模块的大致步骤如下： 实现Qml组件 实现qmldir文件 导出Qml插件类 如果要支持designer，还要加上一步： 创建designer文件夹，编写metainfo文件 这一步暂时没有任何文档和工具，涛哥照猫画虎做出来的。以后文档肯定会出来的，现在有些功能不完善。 (参考Qt的支持Designer的Qml模块。更深入的了解，在QtCreator源码) qmldir文件(帮助文档搜索关键词 “qmldir” 或 “Module Definition qmldir…”) 示例这里以TaoQuick中的为例，我顺手加了点注释： TaoQuick/TaoQuick/qmldir: 123456789101112131415161718192021222324252627282930313233#模块名称 import使用的地方，就用这个名称module TaoQuick#插件dll文件名称，即 TaoQuick.dllplugin TaoQuick#依赖的模块depends QtQuick 2.12depends QtQuick.Controls 2.12# 这里一堆的组件TGradientBtn 1.0 BasicComponent/Button/TGradientBtn.qmlTImageBtn 1.0 BasicComponent/Button/TImageBtn.qmlTImgTextBtn 1.0 BasicComponent/Button/TImgTextBtn.qmlTTextBtn 1.0 BasicComponent/Button/TTextBtn.qmlTMoveArea 1.0 BasicComponent/Mouse/TMoveArea.qmlTTransArea 1.0 BasicComponent/Mouse/TTransArea.qmlTNormalProgress 1.0 BasicComponent/Progress/TNormalProgress.qmlTCircleProgress 1.0 BasicComponent/Progress/TCircleProgress.qmlTBusyIndicator 1.0 BasicComponent/Others/TBusyIndicator.qmlTDragItem 1.0 BasicComponent/Others/TDragItem.qmlTResizeBorder 1.0 BasicComponent/Others/TResizeBorder.qmlTToolTip 1.0 BasicComponent/Others/TToolTip.qmlTDialog 1.0 BasicComponent/Others/TDialog.qmlTPopup 1.0 BasicComponent/Others/TPopup.qmlTFPS 1.0 BasicComponent/Others/TFPS.qml# 支持designerdesignersupported 还有单例singleton、内部类型internal、C++类型描述typeinfo， 这些用法TaoQuick没有用到，就不多说了。 plugin TaoQuick这一句，表示对应的dll文件名称。dll是要写一个C++类，继承自QQmlExtensionPlugin 看一下TaoQuick中的实现 12345678910111213//taoquick_plugin.h#pragma once#include &lt;QQmlExtensionPlugin&gt;class TaoQuickPlugin : public QQmlExtensionPlugin&#123; Q_OBJECT Q_PLUGIN_METADATA(IID QQmlExtensionInterface_iid)public: void registerTypes(const char *uri) override;&#125;; 1234567//taoquick_plugin.cpp#include \"taoquick_plugin.h\"void TaoQuickPlugin::registerTypes(const char *uri)&#123; Q_UNUSED(uri); Q_INIT_RESOURCE(Qml); //注册Qml.qrc&#125; 运行时候的bin路径文件结构是这样的: TaoQuick文件夹的名字就是模块名字 不用开放Qml源码这里说一下，TaoQuick项目中还有一个qmldir文件： TaoQuick/TaoQuick/Qml/qmldir: 123456789101112131415161718TGradientBtn 1.0 BasicComponent/Button/TGradientBtn.qmlTImageBtn 1.0 BasicComponent/Button/TImageBtn.qmlTImgTextBtn 1.0 BasicComponent/Button/TImgTextBtn.qmlTTextBtn 1.0 BasicComponent/Button/TTextBtn.qmlTMoveArea 1.0 BasicComponent/Mouse/TMoveArea.qmlTTransArea 1.0 BasicComponent/Mouse/TTransArea.qmlTNormalProgress 1.0 BasicComponent/Progress/TNormalProgress.qmlTCircleProgress 1.0 BasicComponent/Progress/TCircleProgress.qmlTBusyIndicator 1.0 BasicComponent/Others/TBusyIndicator.qmlTDragItem 1.0 BasicComponent/Others/TDragItem.qmlTResizeBorder 1.0 BasicComponent/Others/TResizeBorder.qmlTToolTip 1.0 BasicComponent/Others/TToolTip.qmlTDialog 1.0 BasicComponent/Others/TDialog.qmlTPopup 1.0 BasicComponent/Others/TPopup.qmlTFPS 1.0 BasicComponent/Others/TFPS.qml 这里面module、plugin这些东西都没有，只有组件。而且这个文件是加入了qrc的，即编译进dll里面了。 前面那个qmldir，需要和dll放在同级目录，dll模块才能被Qml引擎导入。 后面这个qmldir的作用是，导出dll插件时，不用带上qml源码，直接import 这个qmldir的资源路径，就能够用里面的组件了。 也就是说，使用的地方，要写两句import 12import TaoQuick 1.0import \"qrc:/Tao/Qml/\" 这种用法不能在QtCreator高亮，运行没问题。（商业版似乎有更高级的资源内建功能，或许可以支持高亮，后续再研究） 具体的实现和用法，可以参考TaoQuick TaoQuick中的qmake语法，可以参考另一篇文章 &lt;Qt实用技能2-用好qmake&gt; Designer支持再看一下效果： 要支持Designer，需要以下步骤： 首先要在Qml路径下，创建一个designer文件夹。必须叫这个名字 其次要放一个扩展名为.metainfo的文件，里面按格式写上组件信息。名字似乎没有要求。 最后，将整个Qml文件夹拷贝到[QTDIR]/qml/路径下，并把文件夹名字改成模块名字。 TaoQuick项目的路径是这样的： metainfometainfo文件，目前没有文档、没有自动生成工具，只能手动写，语法和qml语法类似。(可以参考QtCreator源码，里面有完整的解析器) 12345678910111213141516MetaInfo &#123; Type &#123; name: \"TaoQuick.BasicComponent.Button.TGradientBtn\" icon: \"images/TGradientBtn.png\" ItemLibraryEntry &#123; name: \"TGradientBtn\" category: \"TaoQuick - Buttons\" libraryIcon: \"images/TGradientBtn.png\" version: \"1.0\" requiredImport: \"TaoQuick\" Property &#123; name: \"width\"; type: \"int\"; value: 120 &#125; Property &#123; name: \"height\"; type: \"int\"; value: 80 &#125; &#125; &#125;&#125; 顶层MetaInfo为固定写法 接下来一个Type就对应Designer中的一个可拖拽的组件： * name应该算作Qml组件文件的路径，路径分隔符用&quot;点&quot;， 路径默认从[QTDIR]/qml开始，如果有自定义qml 导入路径，应该可以从相应的路径开始查找（未尝试）。 * icon 就是小图标了，用来在Designer界面上预览。这里的images路径，默认从designer文件夹开始ItemLibraryEntry 是对这个组件更详细的描述： * name 显示在Designer上面的名字 * category 分组的名字 * libraryIcon 小图标，和前面那个一样（不懂有什么区别，先照抄） * version 版本 （TaoQuick都是1.0） * requiredImport 必要的导入的模块 * Property 属性。就是可以在Designer中调整、做帧动画的。Property支持的关键字有 name type value三个。 type 的值，暂时没有完整的支持列表，源码里面能翻到Qml的基础类型[“boolean”, “int”, “real”, “string”, “url”, “color”], Qt发行的Qml中，还能看到”binding”。 (qtcreator-4.9.0\\qt-creator-opensource-src-4.9.0\\src\\plugins\\qmldesigner\\designercore\\metainfo\\metainfo.cpp) 属性这里，应该是QtCreator还没有开发完整。Qml组件里，什么属性都不写，Designer里面一个属性都看不到。就写一个width属性，其它的导出属性也自动给列出来了。 但是Color这种，即使写了color，还是按照binding字符串处理的，不能用颜色选择器改颜色。只能等QtCreator后续版本了。 Qt自带的Rectangle一类，是从C++里面写的，Color属性是可以用颜色选择器的。Qt自带的Qml组件Color属性也是按binding处理的。 带资源的组件，需要用C++扩展注册资源前面示例那个FPS组件，用到了一张图片。图片资源要么和Qml文件放一起，用”file:///./“的方式访问，要么放进资源里，用C++注册。 所以在前面的TaoQuick安装路径中，有一个dll文件。C:\\Qt\\5.12.3\\msvc2017_64\\qml\\TaoQuick\\TaoQuick.dll 然后封装这个组件的时候，还要再import一下TaoQuick.dll, 即import TaoQuick 1.0 图片路径就用资源路径 12345678910111213141516171819202122232425262728293031323334353637383940414243//TFPS.qmlimport QtQuick 2.12import QtQuick.Controls 2.12import TaoQuick 1.0Item &#123; property int fps: 60 property int frameCount: 0 property color textColor: \"#f7e08c\" Image &#123; id: spinner source: \"qrc:/Core/Image/Others/spinner.png\" width: 32 height: 32 anchors.verticalCenter: parent.verticalCenter anchors.left: parent.left RotationAnimation on rotation &#123; from: 0 to: 360 running: true loops: Animation.Infinite duration: 1000 &#125; onRotationChanged: frameCount++ &#125; Text &#123; anchors.left: spinner.right anchors.verticalCenter: parent.verticalCenter text: \"FPS\" + fps font.pixelSize: 20 renderType: Text.NativeRendering color: textColor &#125; Timer &#123; interval: 1000 repeat: true running: true onTriggered: &#123; fps = frameCount frameCount = 0 &#125; &#125;&#125; 安装可以手动拷贝文件夹，也可以参考TaoQuick的自动化安装。 &lt;Qt实用技能2-用好qmake&gt;一文中已经说过了 只要增加一个pri文件，再执行make install即可 1234567891011121314151617181920212223//TaoQuickDesigner.pritaoquick_designer.files = $$PWD/designer/TaoQuick.metainfotaoquick_designer.path = $$[QT_INSTALL_QML]/$$&#123;uri&#125;/designertoaquick_qmldir.files = $$PWD/qmldirtoaquick_qmldir.path = $$[QT_INSTALL_QML]/$$&#123;uri&#125;taoquick_qml_buttons.files = $$PWD/BasicComponent/Button/*.qmltaoquick_qml_buttons.path = $$[QT_INSTALL_QML]/$$&#123;uri&#125;/BasicComponent/Buttontaoquick_qml_mouse.files = $$PWD/BasicComponent/Mouse/*.qmltaoquick_qml_mouse.path = $$[QT_INSTALL_QML]/$$&#123;uri&#125;/BasicComponent/Mousetaoquick_qml_others.files = $$PWD/BasicComponent/Others/*.qmltaoquick_qml_others.path = $$[QT_INSTALL_QML]/$$&#123;uri&#125;/BasicComponent/Otherstaoquick_qml_progress.files = $$PWD/BasicComponent/Progress/*.qmltaoquick_qml_progress.path = $$[QT_INSTALL_QML]/$$&#123;uri&#125;/BasicComponent/Progresstaoquick_degisner_images.files = $$PWD/designer/images/*.pngtaoquick_degisner_images.path = $$[QT_INSTALL_QML]/$$&#123;uri&#125;/designer/imagesINSTALLS += taoquick_designer toaquick_qmldir taoquick_qml_buttons taoquick_qml_mouse taoquick_qml_others taoquick_qml_progress taoquick_degisner_images","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qt(4)-用好qmake","slug":"玩转Qt(4)-用好qmake","date":"2019-05-29T10:44:23.000Z","updated":"2020-11-10T04:11:32.861Z","comments":true,"path":"2019/05/29/玩转Qt(4)-用好qmake/","link":"","permalink":"https://jaredtao.github.io/2019/05/29/%E7%8E%A9%E8%BD%ACQt(4)-%E7%94%A8%E5%A5%BDqmake/","excerpt":"","text":"简介 qmake简介 添加第三方库 示例1 - 直接链接库的全路径 示例2 - 路径中包含空格等特殊字符，用引号括起来。 示例3 - 分别指定路径和库 示例4 - 分平台条件链接 原理 影子构建 指定目标路径 指定中间件生成路径 拷贝资源 拷贝资源示例 编译前拷贝 安装 结束语 简介本文将教大家，一些qmake的实用技巧。部分地方也会说一下原理，让大家知其然，知其所以然。 工欲善其事，必先利其器。 qmake简介qmake是Qt的构建工具，主要作用是解析pro格式的项目文件、生成编译规则(Makefiles或其它)。 qmake是一个比较古老的工具，很多功能使用perl脚本实现，涛哥在其它地方就没怎么见过使用perl脚本的代码/项目。 Qt官方之前开发的Qbs，后来又宣布不再更新，现在又大力支持CMake。。。 在这样的背景下，qmake依然是当下主要的构建工具，所以qmake的一些技巧还是有必要掌握的。 qmake本身作为一个可执行程序，也是有一些参数的，但这不是本文的重点，本文的重点都在pro文件里。 pro文件中，除了常规的组织项目结构外，还可以做很多事情, 比如 指定编译选项、链接选项、制定目标生成规则、扩展编译规则 等等。 pro文件中的qmake语法，包括 变量声明和使用、内建变量、替换函数、测试函数等，帮助文档都有详细的介绍。 搜索关键词为qmake， 或者和普通的类查看帮助文档方式一样，光标放在pro文件要查看的变量上，按F1就能看到相应的说明。 涛哥就不赘述了，后面用到的会单独说明。 添加第三方库c++开发，使用第三方库也是家常便饭了，这是一个必备的技能。 这里首选的方法，是使用QtCreator提供的添加库UI。在pro文件里(或者项目文件夹), 鼠标右键-&gt;添加库，然后根据自己的需要下一步、下一步点一下即可。 熟练的人也可以直接按pro语法(perl语法)写，给LIBS变量赋值。 下面给几个示例，至于动态库/静态库的差异，大家自己实践吧。 示例1 - 直接链接库的全路径1LIBS += c:/mylibs/math.lib 我们都知道windows系统默认的路径分割符是’&#39;，但在qmake中要写成’\\‘才行。qmake也支持写成’/‘，其它unix系统又都是’/‘， 所以干脆都写成’/‘，方便处理。 示例2 - 路径中包含空格等特殊字符，用引号括起来。1LIBS += \"C:/mylibs/extra libs/extra.lib\" 示例3 - 分别指定路径和库1LIBS += \"C:/mylibs/extra libs\" -lextra 这里的LIBS指定要链接的库，’-L’是指定链接库的路径，’-l’指定要链接的库名称 名称可以省略lib前缀和 扩展名后缀，Qt会自动处理。 后缀包括 ‘.so’ ‘.dll’ ‘.dylib’ 等。 示例4 - 分平台条件链接12win32:LIBS += \"C:/mylibs/extra libs/extra.lib\"unix:LIBS += \"-L/home/user/extra libs\" -lextra 条件链接可以很方便地实现不同平台链接不同的库。 这里的 win32 unix 是在选择了不同的编译器环境时，qmake分别预置的变量。 (比如win32平台相关的变量，可以参考msvc的配置文件: [QTDIR]/mkspecs/win32-msvc/qmake.conf 和 [QTDIR]/mkspecs/common/msvc-desktop.conf) 原理Qt内置了一些perl脚本，在执行qmake解析时会包含这些脚本。其中一些脚本会来处理这个LIBS变量，将其转换成编译器/链接器的参数。 内置的脚本路径在[QTDIR]/mkspecs/features文件夹下，扩展名为prf。 后续的很多变量，也是一样的原理, 只是处理方式各不相同。 很多pro文件的语法、功能实现，都可以参考这些prf来实现。 (注意：不熟悉的同学，不要乱改prf，容易改坏) Qt程序员都知道的一件事：有时候修改了信号/槽相关的代码，不能正常运行，要重新qmake一下，才会生效。 本质上就是在重新触发[QTDIR]/mkspecs/features/moc.prf这个脚本。 (多少年了，都没有修好Moc生成问题，可见qmake的古老…) 影子构建影子构建，就是编译生成的产物和源代码在不同的文件夹。这样可以防止源代码文件夹被污染。 QtCreator默认导入pro工程时，就会生成一个影子构建路径。比如这样： 1F:\\Dev\\Qt\\build-HelloTaoQuick-Desktop_Qt_5_12_3_MSVC2017_64bit-Debug 之后编译项目时生成的中间文件及目标文件，都在这个文件夹中。 这个路径很长，而且编译器或者编译选项不同时都有可能不一样。 有时候要做一些特定的操作 比如目标exe生成到特定目录、拷贝资源文件等等，直接用这个路径会不太方便/不太可靠，我们需要一些定制。 指定目标路径1DESTDIR = $$PWD/bin 通过给DESTDIR变量赋值， 可以指定生成的lib/exe放在哪个目录下 ‘PWD’是qmake内置变量，’$$’是内置变量取值的写法。’/bin’是字符串拼接在变量后面。 更多内置变量可以参考qmake帮助文档，以及这篇文档隐藏的qmake文档 当然也可以参考那一堆prf和conf文件。 指定中间件生成路径可以通过这几个变量指定中间件生成的路径 1234567891011config(debug, debug|release) &#123; OBJECTS_DIR &#x3D; build&#x2F;debug&#x2F;obj MOC_DIR &#x3D; build&#x2F;debug&#x2F;moc RCC_DIR &#x3D; build&#x2F;debug&#x2F;rcc UI_DIR &#x3D; build&#x2F;debug&#x2F;uic&#125; else &#123; OBJECTS_DIR &#x3D; build&#x2F;release&#x2F;obj MOC_DIR &#x3D; build&#x2F;release&#x2F;moc RCC_DIR &#x3D; build&#x2F;release&#x2F;rcc UI_DIR &#x3D; build&#x2F;release&#x2F;uic&#125; config(debug, debug|release) 是一个条件表达式，可以理解为 12345if (debug &#x3D;&#x3D;&#x3D; true) &#123;&#125; else if (release &#x3D;&#x3D; true) &#123;&#125; 注意: 按照perl语法，那个左大括号’{‘不能换行,要和前面的表达式在同一行。(有人自作聪明换行，被坑了呢😄) 上面这种指定中间件路径的方式，在QtCreator中有默认路径所以没有太大意义，不过在命令行编译时这样写却很有用。 拷贝资源pro可以实现，在编译代码时，拷贝一些文件到指定的路径下 拷贝资源示例这里以TaoQuick为例,来说明： 我在TaoQuick库目录下，有个叫qmldir的文件，需要在编译代码时自动拷贝到bin目录下。(先别管这个文件干嘛的，下一篇文章会说) 关键目录结构如下： 12345678TaoQuick TaoQuick.pro - bin -TaoQuick - TaoQuickCore TaoQuickCore.pro - Qml qmldir 那么我在TaoQuickCore.pro文件中的写法如下： 12345678910!equals(_PRO_FILE_PWD_, $$DESTDIR) &#123; copy_qmldir.target = $$DESTDIR/qmldir copy_qmldir.depends = $$_PRO_FILE_PWD_/qmldir win32 &#123; copy_qmldir.target ~= s,/,\\\\\\\\,g copy_qmldir.depends ~= s,/,\\\\\\\\,g &#125; copy_qmldir.commands = $$&#123;QMAKE_COPY_FILE&#125; $$&#123;copy_qmldir.depends&#125; $$&#123;copy_qmldir.target&#125; QMAKE_EXTRA_TARGETS += copy_qmldir&#125; ‘!equals(PRO_FILE_PWD, $$DESTDIR)’ 这一句是执行条件，即: 目标路径不等于pro文件所在路径时 执行下面的操作。 剩下的事情就是在创建一个”编译目标”（Target），将这个编译目标添加到QMAKE_EXTRA_TARGETS变量中就行了。 熟悉MakeFiles的同学应该都清楚什么是”目标”。不懂MakeFiles也没关系，这里的目标就理解为自己声明的一个变量即可。 这个变量有三个很重要的”子变量”: copy_qmldir.target 指定目标文件所在的路径 (这里理解成要拷贝到哪去)copy_qmldir.depends 指定依赖文件所在的路径 (这里理解成从哪里拷贝)copy_qmldir.commands 指定拷贝操作的执行命令 (就是怎么拷贝) QMAKE_COPY_FILE 这个变量来自前面说过的隐藏的qmake文档 qmake会在解析pro文件时，自动替换成平台相应的拷贝命令。 windows 平台就是 copy /y 注意windows的copy指令，路径分隔符得写成 ‘\\‘才行。所以有了下面的特殊处理： 1234win32 &#123; copy_qmldir.target ~&#x3D; s,&#x2F;,\\\\\\\\,g copy_qmldir.depends ~&#x3D; s,&#x2F;,\\\\\\\\,g&#125; ‘s,/,\\\\,g’ 是一个正则表达式，作用是把‘/’替换成‘\\’ 。s表示开头，g表示结尾。 VAR~= REGEXP 是对变量VAR执行REGEXP这个正则表达式 编译前拷贝如果想在编译之前，先把资源拷贝完成，只需要前面的基础上，添加一句 1PRE_TARGETDEPS +&#x3D; $$copy_qmldir.target 也就是把”目标”加到 PRE_TARGETDEPS变量 1234567891011!equals(_PRO_FILE_PWD_, $$DESTDIR) &#123; copy_qmldir.target = $$DESTDIR/qmldir copy_qmldir.depends = $$_PRO_FILE_PWD_/qmldir win32 &#123; copy_qmldir.target ~= s,/,\\\\\\\\,g copy_qmldir.depends ~= s,/,\\\\\\\\,g &#125; copy_qmldir.commands = $$&#123;QMAKE_COPY_FILE&#125; $$&#123;copy_qmldir.depends&#125; $$&#123;copy_qmldir.target&#125; QMAKE_EXTRA_TARGETS += copy_qmldir PRE_TARGETDEPS += $$copy_qmldir.target&#125; 安装pro中还有一种INSTALL功能，可以执行文件拷贝。 和编译期拷贝 类似，INSTALL用起来更简单无脑一些，而且INSTALL只在执行make install指令时，才会拷贝资源。 还是以TaoQuick为例, 我有一堆文件，需要在make install时，安装到Qt的Qml路径中 如上图所示所有的文件, 除了TaoQuickDesigner.pri, 都要按照这个结构拷贝。 (这个pri文件是pro文件的一小部分，可以直接在pro中通过include引入。 pri和pro语法一样，但是qmake不直接识别pri，只识别pro pri一般用来写一些公用的部分，让多个pro公用) 拷贝整个文件夹是一种做法, 当然为了精确地控制要拷贝的内容，可以写成下面这样： 12345678910111213141516171819202122taoquick_designer.files &#x3D; $$PWD&#x2F;designer&#x2F;TaoQuick.metainfotaoquick_designer.path &#x3D; $$[QT_INSTALL_QML]&#x2F;$$&#123;uri&#125;&#x2F;designertoaquick_qmldir.files &#x3D; $$PWD&#x2F;qmldirtoaquick_qmldir.path &#x3D; $$[QT_INSTALL_QML]&#x2F;$$&#123;uri&#125;taoquick_qml_buttons.files &#x3D; $$PWD&#x2F;BasicComponent&#x2F;Button&#x2F;*.qmltaoquick_qml_buttons.path &#x3D; $$[QT_INSTALL_QML]&#x2F;$$&#123;uri&#125;&#x2F;BasicComponent&#x2F;Buttontaoquick_qml_mouse.files &#x3D; $$PWD&#x2F;BasicComponent&#x2F;Mouse&#x2F;*.qmltaoquick_qml_mouse.path &#x3D; $$[QT_INSTALL_QML]&#x2F;$$&#123;uri&#125;&#x2F;BasicComponent&#x2F;Mousetaoquick_qml_others.files &#x3D; $$PWD&#x2F;BasicComponent&#x2F;Others&#x2F;*.qmltaoquick_qml_others.path &#x3D; $$[QT_INSTALL_QML]&#x2F;$$&#123;uri&#125;&#x2F;BasicComponent&#x2F;Otherstaoquick_qml_progress.files &#x3D; $$PWD&#x2F;BasicComponent&#x2F;Progress&#x2F;*.qmltaoquick_qml_progress.path &#x3D; $$[QT_INSTALL_QML]&#x2F;$$&#123;uri&#125;&#x2F;BasicComponent&#x2F;Progresstaoquick_degisner_images.files &#x3D; $$PWD&#x2F;designer&#x2F;images&#x2F;*.pngtaoquick_degisner_images.path &#x3D; $$[QT_INSTALL_QML]&#x2F;$$&#123;uri&#125;&#x2F;designer&#x2F;imagesINSTALLS +&#x3D; taoquick_designer toaquick_qmldir taoquick_qml_buttons taoquick_qml_mouse taoquick_qml_others taoquick_qml_progress taoquick_degisner_images 自定义一个变量，然后其子变量files指定要拷贝的文件，子变量path指定目标路径。 把自定义变量加入INSTALLS变量就行了。 QT_INSTALL_QML也是一个内置变量，默认值为[QTDIR]/qml。 之后只要执行以下命令，就能完成资源拷贝。 123qmakemake make install 当然QtCreator中也能执行make install 如下图所示: 任意编译器kit都可以，项目-&gt;构建步骤-&gt;添加build步骤-&gt;Make，添加之后在make参数中输入install。最后重新构建工程，即可完成安装。 结束语以上案例，大部分都在TaoQuick项目中实践过，可以去Github参考。 TaoQuick","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qt实用技能","slug":"Qt实用技能","permalink":"https://jaredtao.github.io/tags/Qt%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"},{"name":"QtCreator","slug":"QtCreator","permalink":"https://jaredtao.github.io/tags/QtCreator/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qml(9)-Model和View","slug":"玩转Qml(9)-Model和View","date":"2019-05-24T10:44:23.000Z","updated":"2020-12-25T09:58:41.241Z","comments":true,"path":"2019/05/24/玩转Qml(9)-Model和View/","link":"","permalink":"https://jaredtao.github.io/2019/05/24/%E7%8E%A9%E8%BD%ACQml(9)-Model%E5%92%8CView/","excerpt":"","text":"简介 源码 界面、数据和逻辑分离 Qt内置的Model-View 整数做model 关于delegate View与Repeater的区别 ListModel 静态ListModel 动态ListModel XmlListModel ObjectModel C++导出Model QList QJsonArray QQmlPropertyMap ListView缺失的灵魂 搜索与排序 选中 拖拽 特效 简介本文是《玩转Qml》系列文章的第九篇，涛哥将教大家，Qml中Model和View的知识。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 界面、数据和逻辑分离界面架构的理念发展的非常快，主要在Web技术的驱动下，就有这么多架构： MVC、MVP、 MVVM、 Flux、Redux。 架构太多太复杂，只要抓住一些关键点就够了：界面、数据和逻辑要分别处理，最终要能够正确处理用户输入并显示结果。 先来看一下Qt中提供的架构： Model代表数据，View代表界面，这个Delegate嘛，就是用来定制View的显示方式和Controll的调用，也应该算进View里面去。 这样看来Qt是M-V架构 ? 其实Qt算是MVC架构，这个Controll一般是自己实现的，和Model放在一起的。 不过Qt有信号/槽机制，在QtQuick中以属性绑定的方式出现。信号/槽相当于Gof设计模式中的观察者模式，也相当于Flux中的订阅/发布模式。 涛哥按自己的实践和理解，画了一个Qt的Model-View架构草图： Qt内置的Model-ViewView包括 ListView、TableView、TreeView这三种 (ComboBox也可以算作ListView) 对应的Model包括 ListModel、TableModel、TreeModel Qt提供了一些抽象的Model类，需要自己去继承并实现接口，也有一些可以直接用。 下图是涛哥整理的Qt中model继承关系： 其中的QStringListModel不是抽象类，可以直接用在ListView中。 QStandardItemModel也不是抽象类，可以直接用在任意一种View中。 在数据量大、有性能要求的地方，需要继承QAbstractItemModel类，重新实现一个model。 对于性能要求不高的数据展示，会有一些更加方便、取巧的方式，接着往下看吧。 (友情提示：涛哥不关心QWidget，只说QtQuick/Qml) 整数做model在ListView中，一个整数作为model，就可以创建多个delegate实例。 整数作为model，也可以用在GridView、Combobox、Repeater等需要model的地方。 &lt;Qml组件化编程6-进度条定制&gt;一文中，展示渐变效果，就用的整数作为model 12345678910111213141516171819202122232425262728293031323334353637383940414243import QtQuick 2.9import QtQuick.Controls 2.5Item &#123; anchors.fill: parent GridView &#123; id: g anchors.fill: parent anchors.margins: 20 cellWidth: 160 cellHeight: 160 model: 180 //这里的数据Model直接给个整数180 clip: true property var invalidList: [27, 39, 40, 45, 71, 74, 105, 111, 119, 130, 135, 141] //这几个是不能用的，看过运行报错后手动列出来的。 delegate: Item&#123; width: 160 height: 160 Rectangle&#123; width: 150 height: 150 anchors.centerIn: parent color: \"white\" radius: 10 Text &#123; anchors.horizontalCenter: parent.horizontalCenter anchors.top: parent.top anchors.topMargin: 2 text: index + 1 &#125; Rectangle &#123; width: 100 height: width radius: width / 2 //编号在列表里的，直接渐变赋值为null，就不会在Qml运行时报警告了 gradient: g.invalidList.indexOf(modelData + 1) &lt; 0 ? modelData + 1 : null anchors.centerIn: parent anchors.verticalCenterOffset: 10 &#125; &#125; &#125; &#125;&#125; 关于delegate简单说一下delegate： 上面GridView的 model设置为180，表示这个View要产生180个相同的构件实例，按照Grid的方式布局排列。 而delegate就相当于是一个模板，用来描述这180个相同的构件长啥样。当然每个实例不可能完全长得一样，我们可以通过 绑定delegate提供的内置属性或其它属性，达到”大同小异”的目的。 delegate中一般会提供一个index和一个modelData，详细的说明需要参考相应的View文档。 View与Repeater的区别上面的GridView虽然会创建180个实例，但并不是一次创建全部的，而是只创建能看见的那几个，否则会占用很多CPU、内存和GPU资源。 而Repeater这种就是直接生成180个，并没有做任何内置处理。 (Repeater也可以通过自己控制visible的方式，实现部分创建，后面涛哥有个RingView特效会用这种方式) ListModelQml提供了ListModel这样的一个封装，可以直接在Qml中定义静态的model 静态ListModel1234567891011121314import QtQuick 2.0ListModel &#123; id: fruitModel ListElement &#123; name: \"Apple\" cost: 2.45 &#125; ListElement &#123; name: \"Orange\" cost: 3.25 &#125;&#125; 然后在ListView中使用 123456789101112ListView &#123; anchors.fill: parent model: fruitModel delegate: Item &#123; Text &#123; text: modelData.name &#125; Text &#123; text: cost &#125; &#125;&#125; 第一个text通过modelData.name获取到name值 第二个text直接用了cost，其实是modelData.cost省略了modelData。这种写法在静态的ListModel中是可以用的。 动态ListModelListModel还提供了一些动态修改数据的接口: 像append、 set、insert这些，参数里的jsobject就是js环境中的Object类型，可以参考JS手册 这里涛哥示例一下，动态添加元素 12345678910111213...onClicked: &#123; var banana = new Object() //或者这样也行，按照js语法即可 //var bababa = Object.create(null) banana[\"name\"]=\"banana\" //方括号 + key的方式设置成员 babana.cost=15 //点+名字的方式设置成员 fruitModel.append(banana) //将创建的banana添加到model&#125;... 更详细的用法，可以参考 涛哥两年前写过的一个Qml表格编辑器 里面有ListModel的JSON序列化和反序列化、动态增、删、改，Ubuntu风格的查找、Redo、UnDo等大部分功能。 TaoQuick项目的插件机制，也是通过JSON动态添加Model元素。TaoQuick XmlListModel处理xml的model，可以方便地使用XPath。 12345678XmlListModel &#123; id: feedModel source: \"http://rss.news.yahoo.com/rss/oceania\" query: \"/rss/channel/item\" XmlRole &#123; name: \"title\"; query: \"title/string()\" &#125; XmlRole &#123; name: \"link\"; query: \"link/string()\" &#125; XmlRole &#123; name: \"description\"; query: \"description/string()\" &#125;&#125; ObjectModel可视对象的集合，做为model，连Delegate都省了 12345678910111213141516import QtQuick 2.0import QtQml.Models 2.1Rectangle &#123; ObjectModel &#123; id: itemModel Rectangle &#123; height: 30; width: 80; color: \"red\" &#125; Rectangle &#123; height: 30; width: 80; color: \"green\" &#125; Rectangle &#123; height: 30; width: 80; color: \"blue\" &#125; &#125; ListView &#123; anchors.fill: parent model: itemModel &#125;&#125; C++导出Model除了以上这些，C++中导出的一些类型也可以作为数据model。 这里的导出包括Q_PROPERTY和 Q_INVOKABLE函数的返回值、槽函数的返回值，以及 setContextProperty注册到上下文的可用作model的类型。 一般使用Q_PROPERTY (本质上也是属性的get函数返回值，在js中做了转换) QListQList 字符串列表，可以直接用，不用多说了。 QList&lt;QObject*&gt; QObject列表，List中的任意一个QObject有一些属性变更时，都能通知到Qml。 QJsonArrayQJsonArray也是可以直接导出给ListView用，不过注意是只读的。 QQmlPropertyMapQQmlPropertyMap 是一个Map结构, 但是这个结构注册后，Qml中可以直接用”点 + 名字”的方式访问其中的数据 123456789101112// create our dataQQmlPropertyMap ownerData;ownerData.insert(\"name\", QVariant(QString(\"John Smith\")));ownerData.insert(\"phone\", QVariant(QString(\"555-5555\")));// expose it to the UI layerQQuickView view;QQmlContext *ctxt = view.rootContext();ctxt-&gt;setContextProperty(\"owner\", &amp;ownerData);view.setSource(QUrl::fromLocalFile(\"main.qml\"));view.show(); 1234//main.qmlText &#123; text: owner.name + \" \" + owner.phone &#125; ListView缺失的灵魂Qml这个ListView是残缺不全的，很多功能都要自己实现。 搜索与排序前面提到的QSortFilterProxyModel是一种在数据上实现排序和过滤的方法。 还有一种在View层实现搜索和过滤的方式，即DelegateModelGroup。（已经有案例在用，后续再放出代码） 当然Qt5.12的ListView/TableView提供了行和列 隐藏控制的功能，View层做搜索会更方便一些。（还没有实践） 选中按住Ctrl 再鼠标点击，多选， 再点击一下反选。 按住Shift再鼠标点击，连选。 旧的QtQuick.Controls 1中也有一个ListView，带SelectonModel功能，直接支持多选、反选。 5.12开始，QtQuick.Controls 1模块被废弃了，而Controls2中的ListView不带这功能了。只能自己记键盘按键来模拟实现。 (顺便吐槽一下，5.12直接把Controls 1的TreeView废掉了，Controls 2又没有TreeView。Controls 1的那个虽然还能用，程序跑起来就是一堆js 异常) 拖拽拖动和放置功能也得自己做。 特效ListView提供过度动画，下拉刷新一类的效果很多人已经做了，涛哥就不重复了。 (涛哥正在给TaoQuick开发高级插件TaoEffect，将会包含大量酷炫特效组件，敬请期待)","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(8)-Qml属性","slug":"玩转Qml(8)-Qml属性","date":"2019-05-22T11:44:23.000Z","updated":"2020-11-10T04:11:32.858Z","comments":true,"path":"2019/05/22/玩转Qml(8)-Qml属性/","link":"","permalink":"https://jaredtao.github.io/2019/05/22/%E7%8E%A9%E8%BD%ACQml(8)-Qml%E5%B1%9E%E6%80%A7/","excerpt":"","text":"简介 Qml内置类型 简单类型 枚举 list var var数组 var回调函数 Qml模块扩展类型 Qml属性 属性的change信号 属性绑定 动态解绑、动态绑定 条件绑定 只读属性 默认属性 属性别名 QQmlProperty 下期预告 简介本文是《玩转Qml》系列文章的第八篇，涛哥将教大家，一些Qml中属性的知识和使用技巧。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick Qml内置类型说Qml属性之前，先来看看Qml中都有哪些类型吧 Qml本身支持的类型如下图： 一共9个，可以在Qml中实用。 简单类型12345678910111213Item &#123; property bool doorIsOpened: true property int doorCount: 1 + 2 * 3 property double PI: 3.1415926 property real PI: 3.1415926 property string name: \"JaredTao\" property url address: \"https://jaredtao.github.io\"&#125; bool double int real string url 这6个简单的类型，C++中也分别有对应的类型，其中string对应QString，url对应QUrl，就不用多说了。 这里提一下，”1 + 2 * 3” 这种可以在编译期间确定的简单数值表达式， Qml引擎会自动帮你计算成7。编译进二进制文件的时候就是“7”，不是“1 + 2 * 3” (就好比C++ 中的constexpr) 枚举枚举可以通过C++注册给Qml使用。5.10以上的版本还可以直接在Qml中定义枚举。 这里分别示例一下： C++注册枚举给Qml使用 C++11的作用域枚举，也是可以的： 5.12的版本已经不用写Q_DECLARE_METATYPE(BrotherTao::Country)这一句了，旧一点的版本可能需要写上。 5.10以上版本，Qml中定义枚举: 注意 使用枚举必须带上首字母大写的Qml文件名 (这里枚举可能没有语法高亮，但是能正常用，不要担心，那是QtCreator的问题, 可以不管它) listlist就是一个列表，但是一般用来存Qml的扩展类型，不能存基础类型。基础类型想要存List，应该用下面的var。 (大部分人用不到这个list，可以跳过) 这里看一下list的用法: 123456Item &#123; states: [ State &#123; name: \"activated\" &#125;, State &#123; name: \"deactivated\" &#125; ]&#125; 这种list的实现方式，是在C++中导出了一个特殊类型的属性，即QQmlListProperty。 你也可以自己定义一个这样的属性: 1Q_PROPERTY(QQmlListProperty&lt;Fruit&gt; fruit READ fruit) C++里面按它的规则实现几个函数，并注册类型后，就可以在Qml中这样用: 12345fruit: [ Apple &#123;&#125;, Orange&#123;&#125;, Banana&#123;&#125;] 这个大部分人用不到，就不深入讲解了。 varvar就相当于js中的var，什么类型都可以存。 1234567891011121314Item &#123; property var aNumber: 100 property var aBool: false property var aString: \"Hello world!\" property var anotherString: String(\"#FF008800\") property var aColor: Qt.rgba(0.2, 0.3, 0.4, 0.5) property var aRect: Qt.rect(10, 10, 10, 10) property var aPoint: Qt.point(10, 10) property var aSize: Qt.size(10, 10) property var aVector3d: Qt.vector3d(100, 100, 100) property var anArray: [1, 2, 3, \"four\", \"five\", (function() &#123; return \"six\"; &#125;)] property var anObject: &#123; \"foo\": 10, \"bar\": 20 &#125; property var aFunction: (function() &#123; return \"one\"; &#125;)&#125; 这种坑人的东西也可以（涛哥我是坚决不会这么用的）: 12345Item &#123; property var first: &#123;&#125; // nothing = undefined property var second: &#123;&#123;&#125;&#125; // empty expression block = undefined property var third: (&#123;&#125;) // empty object&#125; C++自定义类型、js的内置类型，都可以用var。你可以在Qt的帮助文档中找到js内置类型: 这个文档可能不全面，你可以参考第三方js手册,比如mozilla-js-reference 注意，一般将var换成确切的类型会更好一些，Qml引擎处理var有一个转换的过程，会慢一些。 接下来涛哥说几个var的典型用法： var数组 如上图，数组的操作基本和js里的Array一致，参考js的手册就行了。 但是要注意的一个问题，无论是改变数组中的单个元素的值，还是增加、删除数组中某个元素，都不会触发数组本身的change信号，绑定其length属性也没有用。 没有change信号，Qml中其它与这个数组关联的地方都没法刷新了。那怎么才能让这个数组刷新呢？ 答案是 修改过后，赋值为自己 1names = names 原理很简单，拷贝了一个副本，又放回那个地址了，数组本身变了，触发change信号。 (不得不吐槽，js真挫，居然还拷贝了一份。性能肯定好不到哪去) var回调函数这个用案例来说： 如果你使用过Qml性能探查器(Profiler)，就会发现FileDialog这玩意占很多启动时间、占很多内存。 (涛哥说的是QtQuick.Dialogs里面那个，Qt.labs.platform 那里的实验品从来不用) 好的做法是，Qml工程中只创建一个，复用它。 那么问题来了，某个按钮调用了FileDialog， FileDialog按下确定的时候，怎么把结果传回按钮那里？ 这里就要用到回调函数了。按钮调用FileDialog的同时给它一个回调函数，等确定后直接执行回调函数即可。 下面是涛哥封装的TDialog组件，同时支持创建文件、打开文件、打开多个文件、打开文件夹五种用法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//TDialog.qmlimport QtQuick 2.0import QtQuick.Dialogs 1.2Item &#123; //顶层使用Item，不用FileDialog，屏蔽FileDialog内部属性和函数 enum Type &#123; CreateFile, OpenFile, OpenFiles, OpenFolder, &#125; property int __type //参考Qml源码，人为约定 双下划线开头的属性当作私有属性使用，外部不能用。 //点击确定后的回调函数 property var __acceptCallback: function(file) &#123;&#125; FileDialog &#123; id: d folder: shortcuts.home onAccepted: &#123; switch(__type) &#123; case TDialog.Type.CreateFile: __acceptCallback(d.fileUrl) break case TDialog.Type.OpenFile: __acceptCallback(d.fileUrl) break case TDialog.Type.OpenFiles: __acceptCallback(d.fileUrls) break case TDialog.Type.OpenFolder: __acceptCallback(d.folder) break &#125; &#125; &#125; function createFile(title, nameFilters, callback) &#123; __type = TDialog.Type.CreateFile d.selectExisting = false d.selectFolder = false d.selectMultiple = false d.title = title d.nameFilters = nameFilters __acceptCallback = callback d.open() &#125; function openFile(title, nameFilters, callback) &#123; __type = TDialog.Type.OpenFile d.selectExisting = true d.selectFolder = false d.selectMultiple = false d.title = title d.nameFilters = nameFilters __acceptCallback = callback d.open() &#125; function openFiles(title, nameFilters, callback) &#123; __type = TDialog.Type.OpenFiles d.selectExisting = true d.selectFolder = false d.selectMultiple = true d.title = title d.nameFilters = nameFilters __acceptCallback = callback d.open() &#125; function openFolder(title, callback) &#123; __type = TDialog.Type.OpenFolder d.selectExisting = true d.selectFolder = true d.selectMultiple = false d.title = title __acceptCallback = callback d.open() &#125;&#125; 下面是使用的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import QtQuick 2.12import QtQuick.Window 2.12import QtQuick.Controls 2.5Window &#123; visible: true width: 640 height: 480 title: qsTr(\"Hello Dialog\") TDialog &#123; id: globalDialog &#125; Row &#123; spacing: 10 Button &#123; text: \"create file\" onClicked: &#123; globalDialog.createFile(\"create\", [\"All files (*.*)\"], function(file)&#123; console.log(\"create file\", file) &#125;) &#125; &#125; Button &#123; text: \"open Image\" onClicked: &#123; globalDialog.openFile(\"Open one image\", [\"Image files (*.png *.jpg *.bmp)\"], function(file)&#123; console.log(\"Open one image\", file) &#125;) &#125; &#125; Button &#123; text: \"open Image\" onClicked: &#123; globalDialog.openFiles(\"Open mulit images\", [\"Image files (*.png *.jpg *.bmp)\"], function(files)&#123; console.log(\"Open mulit images\", files) &#125;) &#125; &#125; Button &#123; text: \"open folder\" onClicked: &#123; globalDialog.openFolder(\"Open one folder\", function(file)&#123; console.log(\"Open one folder\", file) &#125;) &#125; &#125; &#125;&#125; TDialog功能收录在最新的TaoQuick项目中， 可以参考源代码，或者到github Release页面下载发布包进行体验。(之前MacOS不能用的问题已经修复) Qml模块扩展类型Qml扩展类型有很多，比如QtQuick模块提供的类型如下： 1234date Date valuepoint Value with x and y attributesrect Value with x, y, width and height attributessize Value with width and height attributes 还有一个非常有用的类型，是QtQml模块提供的Qt： 这个Qt自带了很多方法，前面几章提到的Qt.darker和Qt.lighter都是来自这里。 还有这几个也很实用： Qt.openUrlExternally 可以直接打开一个网址，会自动调用系统的默认浏览器，并跳转到相应的界面 也可以打开一个本地的文件或文件夹，会自动调用系统程序。比如打开一个.txt文件会自动用记事本打开，打开一个文件夹会自动用文件管理器。 Qt.callLater 可以延迟执行，延迟到Qml引擎的事件循环返回(可以用来规避一些隐藏的bug)。 Qml属性前面介绍类型的过程中，其实已经用了简单的属性定义。 这里再补充一些前面没有提到的。 属性的change信号写一个普通的属性，隐含的自动生成了一个change信号，信号名字一般是onXxxChanged 1234Item &#123; property int value: 12 &#x2F;&#x2F;这里定义一个属性，并赋初值 &#x2F;&#x2F;隐含的已经定义了一个change信号: onValueChanged&#125; 属性绑定12345678Item &#123; id: root property int value1: 12 Item &#123; property int value2: root.value1 * 10 + 4 //属性初值，依赖另一个属性。这就形成了一种绑定关系 &#125;&#125; 这里的value2依赖于value1的值，就产生了绑定 所谓的绑定，就是Qml引擎自动做了一个 信号-槽 连接：当onValue1Changed信号发出时，执行 value2 = value1 * 10 + 4。 就是说value1变了，value2会自动跟着变。 动态解绑、动态绑定有时候并不希望两个属性之间，一直是这种绑定状态，需要暂时断开一下绑定关系(解绑)。 这时候只要重新赋值即可解绑，比如 1234567891011121314Item &#123; id: item1 property int value1: 12 Item &#123; id: item2 property int value2: item1.value1 * 10 + 4 //属性初值，依赖另一个属性。这就形成了一种绑定关系 &#125; Button &#123; onClicked: &#123; item2.value = 1024; //重新赋值，绑定关系被破坏，不会再随着value1的改变而改变。 &#125; &#125;&#125; 解绑后，又需要再次绑定，是不是重新赋值回item1.value1就行了呢？ 答案是不对的，再次绑定要用绑定表达式Qt.binding() 1234567891011121314151617181920Item &#123; id: item1 property int value1: 12 Item &#123; id: item2 property int value2: item1.value1 * 10 + 4 &#x2F;&#x2F;属性初值，依赖另一个属性。这就形成了一种绑定关系 &#125; Button &#123; onClicked: &#123; item2.value &#x3D; 1024; &#x2F;&#x2F;重新赋值，绑定关系被破坏，不会再随着value1的改变而改变。 &#125; &#125; Button &#123; onClicked: &#123; item2.value &#x3D; item1.value1 * 10 + 4 &#x2F;&#x2F;这个是赋值表达式，只执行一次，不是绑定表达式。 item2.value &#x3D; Qt.binding(function() &#123; return item1.value1 * 10 + 4;&#125;) &#x2F;&#x2F;这个是绑定表达式。 &#125; &#125;&#125; 条件绑定Qml中还提供了一种功能，叫条件绑定 Binding。前面的动态解绑、再绑定可以用下面的方式实现: 123456789101112131415161718192021222324252627Item &#123; id: item1 property int value1: 12 Item &#123; id: item2 property int value2 &#125; Binding &#123; target: item2 property: &quot;value2&quot; value: item1.value1 * 10 + 4 when: needBind &#125; property bool needBind: true Button &#123; onClicked: &#123; needBind &#x3D; false; &#x2F;&#x2F;条件绑定 关闭 item2.value &#x3D; 1024; &#x2F;&#x2F;重新赋值。 &#125; &#125; Button &#123; onClicked: &#123; needBind &#x3D; true; &#x2F;&#x2F;条件绑定打开 &#125; &#125;&#125; 只读属性只读属性就是只能读，不能修改，不产出Change信号。只要在前面写上readonly即可 1readonly property int maxCPUCount: 8 默认属性默认属性一般用在组件封装中,比如要封装一个TaoLabel的组件,这个组件有个Text类型的默认属性叫someText 123456// TaoLabel.qmlimport QtQuick 2.0Text &#123; default property Text someText text: \"Hello, \" + someText.text&#125; 那么在外面实例化组件的时候，就可以在TaoLabel内部放一个子Text组件，它会自动关联到someText。 12345Item &#123; TaoLable &#123; Text &#123;text: &quot;world&quot;&#125; &#125;&#125; 属性别名别名属性一般用来导出组件内部的属性给外部直接修改 123456Item &#123; property alias text: t.text Text &#123; id: t &#125;&#125; 效果与下面的等价，但是别名少一层变量的声明和绑定，效率更高一些。 12345678Item &#123; id: root property string text Text &#123; id: t text: root.text &#125;&#125; QQmlProperty《Qml组件化编程5-Qml与C++交互》一文中，提到了C++访问Qml的两种方式，这里再补充第三种，就是QQmlProperty 假如有这样的Qml文件， 1234// MyItem.qmlimport QtQuick 2.0Text &#123; text: \"A bit of text\" &#125; 那么在c++种，就可以通过QQmlProperty访问其属性 1234567891011#include &lt;QQmlProperty&gt;#include &lt;QGraphicsObject&gt;...QQuickView view(QUrl::fromLocalFile(\"MyItem.qml\"));QQmlProperty property(view.rootObject(), \"font.pixelSize\");qWarning() &lt;&lt; \"Current pixel size:\" &lt;&lt; property.read().toInt();property.write(24);qWarning() &lt;&lt; \"Pixel size should now be 24:\" &lt;&lt; property.read().toInt(); QQmlProperty不仅可以用来访问Qml中的属性，还可以调用其信号、js函数。 下期预告下一篇文章，将会介绍C++中的属性导出，重点讲解ListView、TableView、TreeView能用的属性。 敬请期待。","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(7)-自绘组件","slug":"玩转Qml(7)-自绘组件","date":"2019-05-19T04:33:44.000Z","updated":"2020-12-25T09:58:07.041Z","comments":true,"path":"2019/05/19/玩转Qml(7)-自绘组件/","link":"","permalink":"https://jaredtao.github.io/2019/05/19/%E7%8E%A9%E8%BD%ACQml(7)-%E8%87%AA%E7%BB%98%E7%BB%84%E4%BB%B6/","excerpt":"","text":"简介 源码 自绘方案 QPainter QWidget+QPainter 示例 QQuickPaintedItem+QPainter 示例 关于QPainter Qml Canvas Qml Shapes QOpenGLWidget / QOpenGLWindow Qml SceneGraph Qml QQuickFrameBufferObject Qml ShaderEffect QVulkanWindow 简介本文是《玩转Qml》系列文章的第七篇，涛哥会罗列Qt中的所有自绘方案，并提供一些案例和说明。 Qt自带的组件，外观都是固定的，一般可以通过qss/Qml style等方式进行定制。 如果要实现外观特殊的组件，就需要自己绘制了。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 自绘方案Qt中的自绘方案有这么一些： QWidget+QPainter / QQuickPaintedItem+QPainter Qml Canvas Qml Shapes QOpenGLWidget / QOpenGLWindow Qml QQuickFrameBufferObject Qml SceneGraph Qml ShaderEffect QVulkanWindow (GraphicsView和QWidget的绘制类似，就不讨论了) QPainterQPainter是一个功能强大的画笔，QWidget中的各种控件如QPushButton、QLable等都是用QPainter画出来的。 (QWidget的控件在绘制时，还增加了qss样式表，让UI定制变得更加方便。) QWidget+QPainter 示例QWidget中使用QPainter的方法，是重载paintEvent事件，这里示例绘制一个进度条: 12345678910111213141516171819//MainWindow.h#pragma once#include &lt;QMainWindow&gt;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = 0); ~MainWindow();protected: void paintEvent(QPaintEvent *event) override; void timerEvent(QTimerEvent *event) override;private: QList&lt;QColor&gt; mColorList; int mCurrent = 0;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//MainWindow.cpp#include \"MainWindow.h\"#include &lt;QPainter&gt;#include &lt;QtMath&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; resize(400, 300); mColorList &lt;&lt; QColor(51, 52, 54) &lt;&lt; QColor(75, 85, 86) &lt;&lt; QColor(87, 103, 103) &lt;&lt; QColor(95, 119, 121) &lt;&lt; QColor(101, 132, 134) &lt;&lt; QColor(104, 146, 145) &lt;&lt; QColor(104, 158, 158) &lt;&lt; QColor(101, 169, 168) &lt;&lt; QColor(92, 182, 180) &lt;&lt; QColor(79, 194, 191); //每秒触发60次定时器，即刷新率60FPS startTimer(1000 / 60);&#125;MainWindow::~MainWindow()&#123;&#125;void MainWindow::timerEvent(QTimerEvent *) &#123; mCurrent =(mCurrent + 3) % 360; update();&#125;void MainWindow::paintEvent(QPaintEvent *event)&#123; QPainter painter(this); painter.setRenderHints(QPainter::Antialiasing|QPainter::TextAntialiasing); //原点x坐标 qreal a = 100; //原点y坐标 qreal b = 100; //半径 qreal r = 80; //每个小圆的半径递增值 qreal roffset = 2; //每个小圆的角度递增值 qreal angleOffset = 30; qreal currentangle = mCurrent ; for (int i = 0; i &lt; mColorList.length(); i++) &#123; qreal r0 = i * roffset; qreal angle = currentangle + i * angleOffset; qreal x0 = r * cos(qDegreesToRadians(angle)) + a; qreal y0 = r * sin(qDegreesToRadians(angle)) + b; painter.setPen(mColorList[i]); painter.setBrush(QBrush(mColorList[i])); painter.drawEllipse(x0 - r0, y0 - r0, 2 * r0, 2 * r0); &#125;&#125; QQuickPaintedItem+QPainter 示例QQuickPaintedItem继承自QQuickItem，而QQuickItem就是Qml中的Item。 QQuickPaintedItem通过重载paint函数,就可以使用QPainter绘制。 自定义的QQuickPaintedItem子类需要注册到Qml中才能使用，注册类型或者注册实例都可以，具体可以参考《 Qml组件化编程5-Qml与C++交互》 这里示例QQuickPaintedItem 中使用 QPainter绘制一个阴阳八卦: 1234567891011121314151617//PBar.h#pragma once#include &lt;QQuickPaintedItem&gt;class PBar : public QQuickPaintedItem&#123; Q_OBJECTpublic: PBar(QQuickItem *parent = nullptr); void paint(QPainter *painter) override; void timerEvent(QTimerEvent *event) override;private: QList&lt;QColor&gt; mColorList; int mCurrent = 0;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//PBar.cpp#include \"PBar.h\"#include &lt;QPainter&gt;#include &lt;QtMath&gt;PBar::PBar(QQuickItem *parent) : QQuickPaintedItem (parent)&#123; mColorList &lt;&lt; QColor(51, 52, 54) &lt;&lt; QColor(75, 85, 86) &lt;&lt; QColor(87, 103, 103) &lt;&lt; QColor(95, 119, 121) &lt;&lt; QColor(101, 132, 134) &lt;&lt; QColor(104, 146, 145) &lt;&lt; QColor(104, 158, 158) &lt;&lt; QColor(101, 169, 168) &lt;&lt; QColor(92, 182, 180) &lt;&lt; QColor(79, 194, 191); //每秒触发60次定时器，即刷新率60FPS startTimer(1000 / 60);&#125;void PBar::paint(QPainter *painter)&#123; //原点x坐标 qreal a = 100; //原点y坐标 qreal b = 100; //半径 qreal r = 80; qreal r1 = r / 2; qreal r2 = r / 6; qreal currentangle = mCurrent; painter-&gt;save(); painter-&gt;setRenderHints(QPainter::Antialiasing|QPainter::TextAntialiasing); //red 部分 &#123; painter-&gt;setBrush(QBrush(QColor(128, 1, 1))); QPainterPath path(QPointF(a + r * cos(qDegreesToRadians( currentangle )), b - r * sin(qDegreesToRadians(currentangle )))); path.arcTo(a - r, b - r, r * 2, r * 2, currentangle, 180); path.arcTo(a + r1 * cos(qDegreesToRadians(currentangle + 180)) - r1, b - r1 * sin(qDegreesToRadians(currentangle + 180)) - r1, r1 * 2, r1 * 2, currentangle + 180, 180); path.arcTo(a + r1*cos(qDegreesToRadians(currentangle)) - r1, b - r1 * sin(qDegreesToRadians(currentangle)) - r1, r1 * 2, r1 * 2, currentangle + 180, -180 ); painter-&gt;drawPath(path); &#125; //blue 部分 &#123; painter-&gt;setBrush(QBrush(QColor(1, 1, 128))); QPainterPath path(QPointF(a + r * cos(qDegreesToRadians( currentangle )), b - r * sin(qDegreesToRadians(currentangle )))); path.arcTo(a - r, b - r, r * 2, r * 2, currentangle, -180); path.arcTo(a + r1 * cos(qDegreesToRadians(currentangle + 180)) - r1, b - r1 * sin(qDegreesToRadians(currentangle + 180)) - r1, r1 * 2, r1 * 2, currentangle + 180, 180); path.arcTo(a + r1*cos(qDegreesToRadians(currentangle)) - r1, b - r1 * sin(qDegreesToRadians(currentangle)) - r1, r1 * 2, r1 * 2, currentangle + 180, -180 ); painter-&gt;drawPath(path); &#125; &#123; // red 小圆 painter-&gt;setBrush(QBrush(QColor(128, 1, 1))); QPainterPath path; path.addEllipse(a + r1 * cos(qDegreesToRadians(currentangle)) - r2, b - r1 * sin(qDegreesToRadians(currentangle )) - r2, r2 * 2, r2 * 2); painter-&gt;drawPath(path); &#125; &#123; //blue 小圆 painter-&gt;setBrush(QBrush(QColor(1, 1, 128))); QPainterPath path; path.addEllipse(a + r1 * cos(qDegreesToRadians(180 + currentangle)) - r2, b - r1 * sin(qDegreesToRadians(180 + currentangle)) - r2, r2 * 2, r2 * 2); painter-&gt;drawPath(path); &#125; painter-&gt;restore();&#125;void PBar::timerEvent(QTimerEvent *event)&#123; (void)event; mCurrent =(mCurrent + 3) % 360; update();&#125; 123456789101112131415161718192021//main.cpp#include &lt;QGuiApplication&gt;#include &lt;QQmlApplicationEngine&gt;#include \"PBar.h\"int main(int argc, char *argv[])&#123; QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling); QGuiApplication app(argc, argv); qmlRegisterType&lt;PBar&gt;(\"PBar\", 1, 0, \"PBar\"); QQmlApplicationEngine engine; const QUrl url(QStringLiteral(\"qrc:/main.qml\")); QObject::connect(&amp;engine, &amp;QQmlApplicationEngine::objectCreated, &amp;app, [url](QObject *obj, const QUrl &amp;objUrl) &#123; if (!obj &amp;&amp; url == objUrl) QCoreApplication::exit(-1); &#125;, Qt::QueuedConnection); engine.load(url); return app.exec();&#125; 1234567891011121314//main.qmlimport QtQuick 2.0import QtQuick.Window 2.0import PBar 1.0Window &#123; visible: true width: 640 height: 480 title: qsTr(\"Hello PBar\") PBar &#123; anchors.fill: parent &#125;&#125; 关于QPainterQPainter底层使用CPU做光栅化渲染，这种方式在没有GPU的设备中能够很好地工作。 (我的好友”Qt侠-刘典武”就是这方面的实战专家，他手上有将近150个精美的自绘组件，比官方还要多，有需要的同学可以联系他 QQ517216493) 然而时代在飞速发展，很多设备都带上了GPU，QPainter在GPU设备上，将不能发挥GPU的全部实力。 (刘典武也在积极跟进GPU绘制) 这里提一下，有个叫QUItCoding的组织，开发了一套QNanoPainter，接口和QPainter一致， 在大部分场景下都拥有不错的性能。其底层是基于nanovg的GPU加速。 不过QNanoPainter并没有合并进Qt官方，具体原因不清楚, 有可能是因为性能并不是100%达标的。 Qml CanvasQml中提供了Canvas组件，接口和html中的Canvas基本一致，可以直接copy html中的Canvas代码(极少部分不能用)。 当然QPainter实现的功能，也都可以移植到Canvas中。 Canvas渲染性能并不太好，如果有性能要求，还是不要用Canvas了。 这里示例绘制一个笑脸 123456789101112131415161718192021222324252627282930//main.qmlimport QtQuick 2.0import QtQuick.Window 2.0Window &#123; visible: true width: 640 height: 480 title: qsTr(\"Hello Canvas\") Canvas &#123; id: canvas anchors.fill: parent onPaint: &#123; var ctx = canvas.getContext('2d'); ctx.beginPath(); ctx.arc(75,75,50,0,Math.PI*2,true); // 绘制 ctx.moveTo(110,75); ctx.arc(75,75,35,0,Math.PI,false); // 口(顺时针) ctx.moveTo(65,65); ctx.arc(60,65,5,0,Math.PI*2,true); // 左眼 ctx.moveTo(95,65); ctx.arc(90,65,5,0,Math.PI*2,true); // 右眼 ctx.stroke(); &#125; &#125;&#125; Qml ShapesQt5.10开始，Qml增加了Quick.Shapes功能。这是目前官方提供的自绘途径中，兼顾性能和易用性的最佳选择。 Shapes底层为GPU渲染(基于SceneGraph)，QPainter能绘制的基础图元，都可以用Shapes实现。Shapes再配合上Qml中的 属性绑定和属性动画，可以轻易实现各式各样的动态、酷炫的UI。 (后续的自定义组件，涛哥将会优先使用Shapes。) 这里示例实现一个任意圆角的Rectangle组件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// TRoundRect.qmlimport QtQuick 2.12import QtQuick.Controls 2.5import QtQuick.Shapes 1.12Shape &#123; id: root //左上角是否圆角 property bool leftTopRound: true //左下角是否圆角 property bool leftBottomRound: true //右上角是否圆角 property bool rightTopRound: true //右下角是否圆角 property bool rightBottomRound: true //圆角半径 property real radius //颜色 property color color: \"red\" //多重采样抗锯齿 layer.enabled: true layer.samples: 8 //平滑处理 smooth: true //反走样抗锯齿 antialiasing: true ShapePath &#123; fillColor: color startX: leftTopRound ? radius : 0 startY: 0 fillRule: ShapePath.WindingFill PathLine &#123; x: rightTopRound ? root.width - radius : root.width y: 0 &#125; PathArc &#123; x: root.width y: rightTopRound ? radius : 0 radiusX: rightTopRound ? radius : 0 radiusY: rightTopRound ? radius : 0 &#125; PathLine &#123; x: root.width y: rightBottomRound ? root.height - radius : root.height &#125; PathArc &#123; x: rightBottomRound ? root.width - radius : root.width y: root.height radiusX: rightBottomRound ? radius : 0 radiusY: rightBottomRound ? radius : 0 &#125; PathLine &#123; x: leftBottomRound ? radius : 0 y: root.height &#125; PathArc &#123; x: 0 y: leftBottomRound ? root.height - radius : root.height radiusX: leftBottomRound ? radius : 0 radiusY: leftBottomRound ? radius : 0 &#125; PathLine &#123; x: 0 y: leftTopRound ? radius : 0 &#125; PathArc &#123; x: leftTopRound ? radius : 0 y: 0 radiusX: leftTopRound ? radius : 0 radiusY: leftTopRound ? radius : 0 &#125; &#125;&#125; 看一下TRoundRect的用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import QtQuick 2.0import QtQuick.Controls 2.5Rectangle &#123; width: 800 height: 600 Rectangle &#123; //背景红色，衬托一下 x: 10 width: 100 height: 160 color: \"red\" &#125; TRoundRect &#123; id: roundRect x: 40 y: 10 width: 200 height: 160 radius: 40 leftTopRound: lt.checked rightTopRound: rt.checked leftBottomRound: lb.checked rightBottomRound: rb.checked color: \"#A0333666\" //半透明色 &#125; Grid &#123; x: 300 y: 10 columns: 2 spacing: 10 CheckBox &#123; id: lt text: \"LeftTop\" checked: true &#125; CheckBox &#123; id: rt text: \"RightTop\" checked: true &#125; CheckBox &#123; id: lb text: \"LeftBottom\" checked: true &#125; CheckBox &#123; id: rb text: \"rightBottom\" checked: true &#125; &#125;&#125; QOpenGLWidget / QOpenGLWindow有的同学学习过OpenGL这类图形渲染API，Qt为OpenGL提供了便利的窗口和上下文环境。 QOpenGLWidget用来在QWidget框架中集成OpenGL渲染，QOpenGLWindow用在Qml框架。 使用方法都是子类重载下面三个函数： 12345void initializeGL();void paintGL();void resizeGL(int w, int h); 这里可以参考官方的示例： QOpenGLWidget示例 QOpenGLWindow示例 Qt对OpenGL系列的函数都做了封装，一般使用QOpenGLFunctions就够了，QOpenGLFunctions是基于OpenGL ES 2.0 API的跨平台实现，删减了个别API。 相应的有一个未删减的OpenGLES2 的封装：QOpenGLFunctions_ES2。 当然为了兼容所有OpenGL版本，Qt分别封装了相应的类 有特殊版本需要的时候，可以把QOpenGLFunctions换成相应的类。 还有一个OpenGL ES3.0的封装， QOpenGLExtraFunctions，可以在支持OpenGL ES 3.0的设备上使用。 使用这些functions，一定要在有OpenGL上下文环境的地方，先调用一下initializeOpenGLFunctions。有些版本的init有返回值的，要注意判断并处理。 Qml SceneGraphQml基于GPU实现了一套渲染框架，这个框架就是SceneGraph。 SceneGraph提供了很多GPU渲染相关的功能，以方便进行自绘制，都是以QSG开头的类，如下图所示： 使用方式是在QQuickItem的子类中，重载updatePaintNode函数： 12345678910QSGNode *TaoItem::updatePaintNode(QSGNode *node, UpdatePaintNodeData *)&#123; QSGSimpleRectNode *n = static_cast&lt;QSGSimpleRectNode *&gt;(node); if (!n) &#123; n = new QSGSimpleRectNode(); n-&gt;setColor(Qt::red); &#125; n-&gt;setRect(boundingRect()); return n;&#125; 在使用Qml框架的程序中，使用这些QSG功能，将自定义渲染直接加入SceneGraph框架的渲染流程，无疑是性能最优的。 不过问题在于，这些QSG有点难以使用。需要有一定的OpenGL或DirectX相关图形学知识，并理解SceneGraph的节点交换机制，才能用好。 而懂OpenGL的人，有更好的选择，就是直接使用OpenGL的API。下面的QQuickFrameBufferObject就是一种途径。 Qml QQuickFrameBufferObjectQQuickFramebufferObject继承于QQuickItem(Qml中将它当作一个Item就可以了)，用来在一个framebuffer object(FBO)上做渲染， SceneGraph框架会将这个FBO渲染到屏幕上。 使用的方式是，实现一个QQuickFramebufferObject::Renderer类。 这个类里面始终是拥有OpenGL上下文环境的，内存也是被SceneGraph框架管理的，只要理解了渲染流程，用起来还是很方便的。 涛哥在Qml中集成 视频播放器 和 3D模型渲染的时候，就使用了这个FBO。 可以参考这两个例子： Qml渲染3D模型 FFmpeg解码，Qml/OpenGL转码渲染 Qml ShaderEffect学习过图形学的人，都应该听说过大名鼎鼎的Shadertoy 只要一点奇妙的Shader代码，就能渲染出各种酷炫的效果。 Qml中提供了ShaderEffect组件，就可以用来做ShaderToy那样的特效。 可以参考qyvlik的代码仓库： qyvlik-ShaderToy.qml 以及我很久以前写的例子： Tao-ShaderToy 360能量球 Qml中还有个神奇的ShaderEffectSource，可以用在普通Item的layer.effect中， 比如这个例子，就用ShaderEffectSource做了倒影特效: 倒影特效 QVulkanWindowOpenGL的下一代，已经进化为vulkan了。 Qt 5.10开始，也提供了vulkan的支持。 涛哥水平有限，这次只提一下，就先不展开说了。","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qt(3)-用好QtCreator","slug":"玩转Qt(3)-用好QtCreator","date":"2019-05-18T10:44:23.000Z","updated":"2020-11-10T04:11:32.860Z","comments":true,"path":"2019/05/18/玩转Qt(3)-用好QtCreator/","link":"","permalink":"https://jaredtao.github.io/2019/05/18/%E7%8E%A9%E8%BD%ACQt(3)-%E7%94%A8%E5%A5%BDQtCreator/","excerpt":"","text":"简介 环境说明 QtCreator折叠全部代码 QtCreator属性生成 QtCreator注释代码 QtCreator代码片段 QtCreator代码格式化 QtCreator会话管理 结尾 简介这次涛哥将教大家，一些QtCreator的实用技巧。 工欲善其事，必先利其器。 环境说明下文以Windows平台的QtCreator为参考，其它平台的菜单栏入口和快捷键 请以实际为准。 QtCreator版本以Qt5.6.x及以上安装包所带的都行，再旧的版本不讨论。 QtCreator折叠全部代码折叠全部代码,支持C++和Qml。操作方式为： 光标焦点放在代码文本中，之后 菜单栏: 编辑-&gt;Advanced-&gt;Toggle Fold All 这个功能没有快捷键 QtCreator属性生成经常需要给自定义的QObject类写一些属性，QtCreator是可以自动生成get、set函数以及change信号的。 只要写上Q_PROPERTY那一行，光标放在Q_PROPERTY上, 用右键菜单 -&gt; Refactor -&gt; Generate Missing Q_PROPERTY Memory 即可生成。 也可以使用快捷键，光标放在Q_PROPERTY上，按Alt + Enter。 QtCreator注释代码快捷键，注释当前行代码或者当前选中的多行代码 Ctrl + / 已经注释掉的，再按一次取消注释。 QtCreator代码片段前面的Q_PROPERTY自动生成，其实就是一种代码片段。 比如经常要写这样一段代码 1234if (pObj) &#123; delete pObj; pObj = nullptr;&#125; 其中的pObj出现了多次，在不同的地方只是pObj这个名字不同，其它if 和 delete操作一模一样。 可以把这段代码封装成模板函数，也可以做成QtCreator的代码片段。(不建议定义宏, 不类型安全和不方便调试) 模板是这样的： 123456789template&lt;class T&gt;safeDelete (T *pObj) &#123; if (pObj) &#123; delete pObj; pObj = nullptr; &#125;&#125; 代码片段是在写代码时就把实际的代码生成出来了，模板是编译的时候才去生成。所以代码片段可以加快编译速度。 代码片段是这么做的，在菜单的 工具-&gt;选项 弹出选项窗口，然后到文本编辑器-&gt;片段-&gt;下拉选C++ 添加一个片段，起名字叫safeD，并填上内容 1234if ($$) &#123; delete $$; $$ = nullptr;&#125; 写好后点击确定。再回到代码中，输入safeD，按回车就会自动补全前面的片段。 光标出现在$$的地方，有一个高亮颜色，此时只要输入一个名字，按下回车键，后续的地方自动替换成输入的名字了。 QtCreator代码格式化都9102年了，如果还有人跟你计较大括号要不要换行、指针符号靠左还是靠右这种问题，请用自动格式化工具怼他/她。 QtCreator支持很多种格式化工具，涛哥用的是clang-format。VisualStudio 2017、2019、以及VSCode也支持clang-format 的,都不需要额外安装任何插件。配置起来很简单，只要在项目pro文件同级目录下，放一个配置好的.clang-format的文件就行了。 团队合作的时候，使用同一个.clang-format配置文件，大家的代码格式就都一致了。 clang-format有默认的google、llvm等格式可选，也可以自定义。下面是一个涛哥使用的自定义配置文件，并做了详细的注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218---# 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProtoLanguage: Cpp# BasedOnStyle: WebKit# 访问说明符(public、private等)的偏移AccessModifierOffset: -4# 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行)AlignAfterOpenBracket: AlwaysBreak# 连续赋值时，对齐所有等号AlignConsecutiveAssignments: false# 连续声明时，对齐所有声明的变量名AlignConsecutiveDeclarations: false# 左对齐逃脱换行(使用反斜杠换行)的反斜杠AlignEscapedNewlines: Right# 水平对齐二元和三元表达式的操作数AlignOperands: true# 对齐连续的尾随的注释AlignTrailingComments: true# 允许函数声明的所有参数在放在下一行AllowAllParametersOfDeclarationOnNextLine: true# 允许短的块放在同一行AllowShortBlocksOnASingleLine: false# 允许短的case标签放在同一行AllowShortCaseLabelsOnASingleLine: false# 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), AllAllowShortFunctionsOnASingleLine: Empty# 允许短的if语句保持在同一行AllowShortIfStatementsOnASingleLine: false# 允许短的循环保持在同一行AllowShortLoopsOnASingleLine: false# 总是在定义返回类型后换行(deprecated)AlwaysBreakAfterDefinitionReturnType: None# 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数),# AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)AlwaysBreakAfterReturnType: None# 总是在多行string字面量前换行AlwaysBreakBeforeMultilineStrings: false# 总是在template声明后换行AlwaysBreakTemplateDeclarations: true# false表示函数实参要么都在同一行，要么都各自一行BinPackArguments: false# false表示所有形参要么都在同一行，要么都各自一行BinPackParameters: false# 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效BraceWrapping: # class定义后面 AfterClass: true # 控制语句后面 AfterControlStatement: true # enum定义后面 AfterEnum: true # 函数定义后面 AfterFunction: true # 命名空间定义后面 AfterNamespace: true # ObjC定义后面 AfterObjCDeclaration: false # struct定义后面 AfterStruct: true # union定义后面 AfterUnion: true # extern 定义后面 AfterExternBlock: true # catch之前 BeforeCatch: true # else 之前 BeforeElse: true # 缩进大括号 IndentBraces: false SplitEmptyFunction: true SplitEmptyRecord: true SplitEmptyNamespace: true# 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)BreakBeforeBinaryOperators: All# 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似),# Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似),# Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom# 注：这里认为语句块也属于函数BreakBeforeBraces: Allman# 继承列表的逗号前换行BreakBeforeInheritanceComma: false# 在三元运算符前换行BreakBeforeTernaryOperators: true# 在构造函数的初始化列表的逗号前换行BreakConstructorInitializersBeforeComma: false# 初始化列表前换行BreakConstructorInitializers: BeforeComma# Java注解后换行BreakAfterJavaFieldAnnotations: falseBreakStringLiterals: true# 每行字符的限制，0表示没有限制ColumnLimit: 160# 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变CommentPragmas: &#39;^ IWYU pragma:&#39;# 紧凑 命名空间CompactNamespaces: false# 构造函数的初始化列表要么都在同一行，要么都各自一行ConstructorInitializerAllOnOneLineOrOnePerLine: true# 构造函数的初始化列表的缩进宽度ConstructorInitializerIndentWidth: 4# 延续的行的缩进宽度ContinuationIndentWidth: 4# 去除C++11的列表初始化的大括号&#123;后和&#125;前的空格Cpp11BracedListStyle: false# 继承最常用的指针和引用的对齐方式DerivePointerAlignment: false# 关闭格式化DisableFormat: false# 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)ExperimentalAutoDetectBinPacking: false# 固定命名空间注释FixNamespaceComments: true# 需要被解读为foreach循环而不是函数调用的宏ForEachMacros: - foreach - Q_FOREACH - BOOST_FOREACHIncludeBlocks: Preserve# 对#include进行排序，匹配了某正则表达式的#include拥有对应的优先级，匹配不到的则默认优先级为INT_MAX(优先级越小排序越靠前)，# 可以定义负数优先级从而保证某些#include永远在最前面IncludeCategories: - Regex: &#39;^&quot;(llvm|llvm-c|clang|clang-c)&#x2F;&#39; Priority: 2 - Regex: &#39;^(&lt;|&quot;(gtest|gmock|isl|json)&#x2F;)&#39; Priority: 3 - Regex: &#39;.*&#39; Priority: 1IncludeIsMainRegex: &#39;(Test)?$&#39;# 缩进case标签IndentCaseLabels: trueIndentPPDirectives: None# 缩进宽度IndentWidth: 4# 函数返回类型换行时，缩进函数声明或函数定义的函数名IndentWrappedFunctionNames: falseJavaScriptQuotes: LeaveJavaScriptWrapImports: true# 保留在块开始处的空行KeepEmptyLinesAtTheStartOfBlocks: true# 开始一个块的宏的正则表达式MacroBlockBegin: &#39;&#39;# 结束一个块的宏的正则表达式MacroBlockEnd: &#39;&#39;# 连续空行的最大数量MaxEmptyLinesToKeep: 1# 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), AllNamespaceIndentation: All# 使用ObjC块时缩进宽度ObjCBlockIndentWidth: 4# 在ObjC的@property后添加一个空格ObjCSpaceAfterProperty: true# 在ObjC的protocol列表前添加一个空格ObjCSpaceBeforeProtocolList: truePenaltyBreakAssignment: 2PenaltyBreakBeforeFirstCallParameter: 19# 在一个注释中引入换行的penaltyPenaltyBreakComment: 300# 第一次在&lt;&lt;前换行的penaltyPenaltyBreakFirstLessLess: 120# 在一个字符串字面量中引入换行的penaltyPenaltyBreakString: 1000# 对于每个在行字符数限制之外的字符的penaltyPenaltyExcessCharacter: 1000000# 将函数的返回类型放到它自己的行的penaltyPenaltyReturnTypeOnItsOwnLine: 60# 指针和引用的对齐: Left, Right, MiddlePointerAlignment: Right#RawStringFormats: # - Delimiter: pb# Language: TextProto# BasedOnStyle: google# 允许重新排版注释ReflowComments: false# 允许排序#includeSortIncludes: trueSortUsingDeclarations: true# 在C风格类型转换后添加空格SpaceAfterCStyleCast: false# 模板关键字后面添加空格SpaceAfterTemplateKeyword: true# 在赋值运算符之前添加空格SpaceBeforeAssignmentOperators: true# 开圆括号之前添加一个空格: Never, ControlStatements, AlwaysSpaceBeforeParens: ControlStatements# 在空的圆括号中添加空格SpaceInEmptyParentheses: false# 在尾随的评论前添加的空格数(只适用于&#x2F;&#x2F;)SpacesBeforeTrailingComments: 1# 在尖括号的&lt;后和&gt;前添加空格SpacesInAngles: false# 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格SpacesInContainerLiterals: true# 在C风格类型转换的括号中添加空格SpacesInCStyleCastParentheses: false# 在圆括号的(后和)前添加空格SpacesInParentheses: false# 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响SpacesInSquareBrackets: false# 标准: Cpp03, Cpp11, AutoStandard: Cpp11# tab宽度TabWidth: 4# 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, AlwaysUseTab: Never... 怎么使用呢？QtCreator中打开要格式化的代码文件，按快捷键 Ctrl + I 就是格式化当前行。 Ctrl + A选中全部内容，再按Ctrl + I就是格式化全部。 VS是把.clang-format文件放在和sln文件同级目录即可，快捷键一般是 先按Ctrl + K 再按Ctrl + D VSCode是打开的文件夹根目录有.clang-format即可，格式化一般在右键菜单。 QtCreator会话管理QtCreator的”会话管理”和”最近使用”功能配合，是涛哥接触过的所有IDE/Editor中，管理项目最好用的，没有之一。 包括VisualStudio、VSCode、AndroidStudio、XCode、Unity3D Editor等等，都只有”最近使用”，没有”会话管理”。 如上图，左边是会话列表，右边是最近使用列表。 会话管理的最大用处是，同时打开多个Qt项目，以及快速切换并还原状态。 涛哥用示例来说明: 涛哥正在开发TaoQuick项目，这个项目包含两个不同路径下的pro项目, 每个项目分别有自己的子项目。 当我正在调试TaoView.cpp文件，并且打了断点的时候，有小伙伴来问我关于另一个项目HelloCI的一些问题。 这时候我需要把代码切换到HelloCI项目，有些人可能会想着再打开一个QtCreator，当然这样也行，就是 窗口太多了容易搞混了。涛哥更信赖“会话管理”功能，切换到HelloCI这个会话，做了一些处理。 完了之后，涛哥又切换回了TaoQuick这个会话，QtCreator就自动恢复到了刚才看的代码TaoView.cpp，而且断点也还在。 又过了一段时间，涛哥需要重启一下电脑，重启后打开QtCreator，直接点开TaoQuick这个会话，又给我切换回 刚才调试的TaoQuick.cpp文件了，项目结构展开和重启之前是一样的,只有断点没有了。 简而言之，大家把平常用的多个相关的项目，放进一个会话里面，就可以放心地关掉QtCreator。下一次想打开的时候，只要点一下会话就可以了。 结尾这次就分享这么多了，以上内容，大部分都可以在TaoQuick的代码仓库中看到 https://github.com/jaredtao/taoquick","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qt实用技能","slug":"Qt实用技能","permalink":"https://jaredtao.github.io/tags/Qt%E5%AE%9E%E7%94%A8%E6%8A%80%E8%83%BD/"},{"name":"QtCreator","slug":"QtCreator","permalink":"https://jaredtao.github.io/tags/QtCreator/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qml(6)-进度条定制","slug":"玩转Qml(6)-进度条定制","date":"2019-05-18T04:44:23.000Z","updated":"2020-12-25T09:57:52.074Z","comments":true,"path":"2019/05/18/玩转Qml(6)-进度条定制/","link":"","permalink":"https://jaredtao.github.io/2019/05/18/%E7%8E%A9%E8%BD%ACQml(6)-%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%AE%9A%E5%88%B6/","excerpt":"","text":"简介 先看预览图 新的渐变效果 条形进度条 圆形进度条 简介本文是《玩转Qml》系列文章的第六篇，涛哥将教大家，进度条组件的定制。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 先看预览图 新的渐变效果Qt 5.12 加入了新的渐变效果，一共180种，效果来自这个网站https://webgradients.com 按照帮助文档的介绍，可以通过下面这两种方式使用 123456789Rectangle &#123; y: 0; width: 80; height: 80 gradient: Gradient.NightFade&#125;Rectangle &#123; y: 0; width: 80; height: 80 gradient: \"NightFade\"&#125; 涛哥立即想到了，枚举不就是数字嘛 123456789101112Rectangle &#123; y: 0; width: 80; height: 80 gradient: 1&#125;Rectangle &#123; y: 0; width: 80; height: 80 gradient: 2&#125;Rectangle &#123; y: 0; width: 80; height: 80 gradient: 3&#125; 试了一下，这样也是可以啊，哈哈。 于是涛哥就把180种渐变效果都拉出来看看。 Qt只支持水平和垂直的渐变，其中有小部分是不能用的，所以只有165个能用。 看一下展示全部渐变的Qml代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243import QtQuick 2.9import QtQuick.Controls 2.5Item &#123; anchors.fill: parent GridView &#123; id: g anchors.fill: parent anchors.margins: 20 cellWidth: 160 cellHeight: 160 model: 180 //这里的数据Model直接给个数字180 clip: true property var invalidList: [27, 39, 40, 45, 71, 74, 105, 111, 119, 130, 135, 141] //这几个是不能用的，看过运行报错后手动列出来的。 delegate: Item&#123; width: 160 height: 160 Rectangle&#123; width: 150 height: 150 anchors.centerIn: parent color: \"white\" radius: 10 Text &#123; anchors.horizontalCenter: parent.horizontalCenter anchors.top: parent.top anchors.topMargin: 2 text: index + 1 &#125; Rectangle &#123; width: 100 height: width radius: width / 2 //编号在列表里的，直接渐变赋值为null，就不会在Qml运行时报警告了 gradient: g.invalidList.indexOf(modelData + 1) &lt; 0 ? modelData + 1 : null anchors.centerIn: parent anchors.verticalCenterOffset: 10 &#125; &#125; &#125; &#125;&#125; 条形进度条普通进度条的原理，就是有一个比较长的矩形做背景，在上面放一个颜色不同的矩形，其宽度跟着百分比变化, 100%时宽度与背景一致。 可以写一个很简要的进度条。 12345678910111213141516Rectangle &#123; id: back width: 300 height: 50 radius: height / 2 color: \"white\" property int percent: 0 Rectangle &#123; id: front //宽度是 背景宽度 * 百分比 width: percent / 100 * parent.width height: parent.height radius: parent.radius color: \"red\" &#125;&#125; 再添加一点元素，在右侧放一个文本，表示百分比，或者放图片。甚至给进度条加个闪光特效。 经过一系列的加工，封装成一个综合的组件，最终结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//NormalProgressBar.qmlimport QtQuick 2.12import QtQuick.Controls 2.12Item &#123; id: r property int percent: 0 implicitWidth: 200 implicitHeight: 16 //枚举， 表示右侧Bar的类型 enum BarType &#123; Text, //右侧放文本 SucceedOrFailed, //右侧放图片表示成功和失败，没有100%就是失败 NoBar //右侧不放东西 &#125; //只读属性，内置一些颜色 readonly property color __backColor: \"#f5f5f5\" readonly property color __blueColor: \"#1890ff\" readonly property color __succeedColor: \"#52c41a\" readonly property color __failedColor: \"#f5222d\" //背景色，默认值 property color backgroundColor: __backColor //前景色 property color frontColor: &#123; switch (barType) &#123; case TNormalProgress.BarType.SucceedOrFailed: return percent === 100 ? __succeedColor : __failedColor default: return __blueColor &#125; &#125; //文字 property string text: String(\"%1%\").arg(percent) //渐变 0-180 除掉不能用的，165种渐变任你选 property int gradientIndex: -1 //闪烁特效 property bool flicker: false //右侧Bar类型 property var barType: TNormalProgress.BarType.Text Text &#123; id: t enabled: barType === TNormalProgress.BarType.Text visible: enabled text: r.text anchors.verticalCenter: parent.verticalCenter anchors.right: parent.right &#125; Image &#123; id: image source: percent === 100 ? \"qrc:/Core/Image/ProgressBar/ok_circle.png\" : \"qrc:/Core/Image/ProgressBar/fail_circle.png\" height: parent.height width: height enabled: barType === TNormalProgress.BarType.SucceedOrFailed visible: enabled anchors.right: parent.right &#125; property var __right: &#123; switch (barType) &#123; case TNormalProgress.BarType.Text: return t.left case TNormalProgress.BarType.SucceedOrFailed: return image.left default: return r.right &#125; &#125; Rectangle &#123; //背景 id: back anchors.left: parent.left anchors.right: __right anchors.rightMargin: 4 height: parent.height radius: height / 2 color: backgroundColor Rectangle &#123; //前景 id: front width: percent / 100 * parent.width height: parent.height radius: parent.radius color: frontColor gradient: gradientIndex === -1 ? null : gradientIndex Rectangle &#123; //前景上的闪光特效 id: flick height: parent.height width: 0 radius: parent.radius color: Qt.lighter(parent.color, 1.2) enabled: flicker visible: enabled NumberAnimation on width &#123; running: visible from: 0 to: front.width duration: 1000 loops: Animation.Infinite; &#125; &#125; &#125; &#125;&#125; 圆形进度条将一个Rectangle做成圆形: 宽高相等，半径为宽度一半。 再把 颜色设置为透明，边框不透明，边框加粗一点，就是一个圆环了。 123456789Rectangle &#123; id: back width: 120 height: width radius: width / 2 color: \"transparent\" border.width: 10 border.color: \"white\"&#125; 接下来给圆环贴上一个圆形渐变色，渐变按照百分比来做。 123456789101112131415161718192021import QtGraphicalEffects 1.12Rectangle &#123; id: back width: 120 height: width radius: width / 2 color: \"transparent\" border.width: 10 border.color: \"white\" property int percent: 0 ConicalGradient &#123; anchors.fill: back source: back gradient: Gradient &#123; GradientStop &#123; position: 0.0; color: \"white\" &#125; GradientStop &#123; position: percent / 100 ; color: \"red\" &#125; GradientStop &#123; position: percent / 100 + 0.001; color: \"white\" &#125; GradientStop &#123; position: 1.0; color: \"white\" &#125; &#125; &#125;&#125; 渐变从0 到 percent处都是有渐变颜色的, 再从percent + 0.001 到1.0处，都是背景色，这样就是一个简易的圆形进度条了。 不过这里percent为100的情况，圆形渐变处理不了，我们可以特殊处理，直接让背景圆环变成前景色就行了。(既然都100%了，背景肯定是全部被遮住了，那就让背景做前景，藏掉真正的前景) 123456789101112131415161718192021222324```qmlimport QtGraphicalEffects 1.12Rectangle &#123; id: back width: 120 height: width radius: width / 2 color: \"transparent\" border.width: 10 border.color: percent === 100 ? \"red\" : \"white\" //百分比为100时显示为前景,否则显示为背景 property int percent: 0 ConicalGradient &#123; anchors.fill: back source: back enabled: percent != 100 //百分比不为100时有效 visible: enabled //百分比不为100时有效 gradient: Gradient &#123; GradientStop &#123; position: 0.0; color: \"white\" &#125; GradientStop &#123; position: percent / 100 ; color: \"red\" &#125; GradientStop &#123; position: percent / 100 + 0.001; color: \"white\" &#125; GradientStop &#123; position: 1.0; color: \"white\" &#125; &#125; &#125;&#125; 再加点料,封装成组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//CircleProgressBar.qmlimport QtQuick 2.12import QtQuick.Controls 2.12import QtGraphicalEffects 1.12Item &#123; id: r property int percent: 0 enum BarType &#123; Text, SucceedOrFailed, NoBar &#125; readonly property color __backColor: \"#f5f5f5\" readonly property color __blueColor: \"#1890ff\" readonly property color __succeedColor: \"#52c41a\" readonly property color __failedColor: \"#f5222d\" property color backgroundColor: __backColor property color frontColor: &#123; switch (barType) &#123; case TNormalProgress.BarType.SucceedOrFailed: return percent === 100 ? __succeedColor : __failedColor default: return __blueColor &#125; &#125; property string text: String(\"%1%\").arg(percent) property var barType: TNormalProgress.BarType.Text Rectangle &#123; id: back color: \"transparent\" anchors.fill: parent border.color: percent === 100 ? frontColor : backgroundColor border.width: 10 radius: width / 2 &#125; Text &#123; id: t enabled: barType === TNormalProgress.BarType.Text visible: enabled text: r.text anchors.centerIn: parent verticalAlignment: Text.AlignVCenter horizontalAlignment: Text.AlignHCenter &#125; Image &#123; id: image source: percent === 100 ? \"qrc:/Core/Image/ProgressBar/ok.png\" : \"qrc:/Core/Image/ProgressBar/fail.png\" enabled: barType === TNormalProgress.BarType.SucceedOrFailed visible: enabled scale: 2 anchors.centerIn: parent &#125; ConicalGradient &#123; anchors.fill: back source: back enabled: percent != 100 visible: enabled smooth: true antialiasing: true gradient: Gradient &#123; GradientStop &#123; position: 0.0; color: frontColor &#125; GradientStop &#123; position: percent / 100 ; color: frontColor &#125; GradientStop &#123; position: percent / 100 + 0.001; color: backgroundColor &#125; GradientStop &#123; position: 1.0; color: backgroundColor &#125; &#125; &#125;&#125; 最后，来个合影 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112Item &#123; id: r anchors.fill: parent Grid &#123; id: g anchors.fill: parent anchors.margins: 10 columns: 2 spacing: 10 Column &#123; width: g.width / 2 - 10 height: g.height /2 - 10 spacing: 10 TNormalProgress &#123; width: parent.width backgroundColor: gConfig.reserverColor NumberAnimation on percent &#123; from: 0; to: 100; duration: 5000; running: true; loops: Animation.Infinite&#125; &#125; TNormalProgress &#123; width: parent.width backgroundColor: gConfig.reserverColor flicker: true percent: 50 &#125; TNormalProgress &#123; width: parent.width backgroundColor: gConfig.reserverColor barType: TNormalProgress.BarType.SucceedOrFailed percent: 70 &#125; TNormalProgress &#123; width: parent.width backgroundColor: gConfig.reserverColor barType: TNormalProgress.BarType.SucceedOrFailed percent: 100 &#125; TNormalProgress &#123; width: parent.width backgroundColor: gConfig.reserverColor barType: TNormalProgress.BarType.NoBar percent: 50 gradientIndex: 12 &#125; &#125; Row &#123; width: g.width / 2 - 10 height: g.height /2 - 10 spacing: 10 TCircleProgress &#123; width: 120 height: 120 backgroundColor: gConfig.reserverColor NumberAnimation on percent &#123; from: 0; to: 100; duration: 5000; running: true; loops: Animation.Infinite&#125; &#125; TCircleProgress &#123; width: 120 height: 120 backgroundColor: gConfig.reserverColor barType: TNormalProgress.BarType.SucceedOrFailed percent: 75 &#125; TCircleProgress &#123; width: 120 height: 120 backgroundColor: gConfig.reserverColor barType: TNormalProgress.BarType.SucceedOrFailed percent: 100 &#125; &#125; Row &#123; width: g.width / 2 - 10 height: g.height /2 - 10 spacing: 10 TCircleProgress &#123; width: 120 height: 120 backgroundColor: gConfig.reserverColor text: String(\"%1天\").arg(percent) NumberAnimation on percent &#123; from: 0; to: 100; duration: 5000; running: true; loops: Animation.Infinite&#125; &#125; TCircleProgress &#123; id: ppppp width: 120 height: 120 backgroundColor: gConfig.reserverColor barType: TNormalProgress.BarType.SucceedOrFailed SequentialAnimation &#123; running: true loops: Animation.Infinite NumberAnimation &#123; target: ppppp property: \"percent\" from: 0 to: 100 duration: 3000 &#125; PauseAnimation &#123; duration: 500 &#125; &#125; &#125; TCircleProgress &#123; width: 120 height: 120 backgroundColor: gConfig.reserverColor percent: 100 &#125; &#125; &#125;&#125; 效果如下：","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(5)-Qml与C++交互","slug":"玩转Qml(5)-Qml与C++交互","date":"2019-05-17T12:37:33.000Z","updated":"2020-11-10T04:11:32.857Z","comments":true,"path":"2019/05/17/玩转Qml(5)-Qml与C++交互/","link":"","permalink":"https://jaredtao.github.io/2019/05/17/%E7%8E%A9%E8%BD%ACQml(5)-Qml%E4%B8%8EC++%E4%BA%A4%E4%BA%92/","excerpt":"","text":"简介 源码 C++访问Qml findChild QQmlComponent Qml访问C++ 注册类并使用 注册实例并使用 简介本文是《玩转Qml》系列文章的第五篇，涛哥将教大家，Qml与C++的交互。 Qml已经有很多功能，不过终归会有不够用或不适用的地方，需要通过与C++的交互进行功能扩展。 这回涛哥尝试把所有Qml与C++交互相关的知识点都写出来，做一个透彻、全面的总结。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick C++访问Qmlc++访问Qml有两种方式： findChild和 QQmlComponent。 findChild了解Qt的人都知道，Qt的很多对象是QObject的子类，这些QObject只要设置了parent，就是有父子关系的，会产生一棵 “对象树”。 只要有了根节点，树上的任意节点都可以通过findChild的方式获取到。 写个简单的TaoObject，来示意一下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class TaoObject&#123;public: //构造函数，传递parent进来 TaoObject(TaoObject *parent = nullptr) : m_pParent(parent) &#123; if (m_pParent) &#123; m_pParent-&gt;appendChild(this); &#125; &#125; //析构函数，析构children。即子对象自动回收机制。 ~TaoObject() &#123; for (auto *pObj : m_children) &#123; delete pObj; &#125; m_children.clear(); &#125; //获取name const QString &amp;getName() const &#123; return m_name; &#125; //设置name void setName(const QString &amp;name) &#123; m_name = name; &#125; //查找子Object TaoObject *findChild(const QString &amp;name) &#123; //先检查自己的名字，是否匹配目标名字 if (m_name == name) &#123; return this; &#125; //遍历子Object，查找 for (auto pObj : m_children) &#123; //递归调用，深度优先的搜索 auto resObj = pObj-&gt;findChild(name); if (resObj) &#123; return resObj; &#125; &#125; return nullptr; &#125;protected: void appendChild(TaoObject *child) &#123; m_children.push_back(child); &#125;private: //存储名字 QString m_name; //子对象列表 std::vector&lt;TaoObject *&gt; m_children; //父对象指针 TaoObject *m_pParent = nullptr;&#125;; Qml的基本元素,大多是继承于QQuickItem，而QQuickItem继承于QObject。 所以Qml大多数对象都是QObject的子类，也是可以通过findChild的方式获取到对象指针。 拿到了QObject，可以通过qobject_cast转换成具体的类型来使用，也可以直接用QObject的invok方法。 例如有如下Qml代码: 1234567891011121314151617Item &#123; id: root ... Rectangle &#123; id: centerRect objectName: \"centerRect\" //必不可少的objectName property bool canSee: visible //自定义属性，可以被C++ invok访问 signal sayHello() //自定义信号1，可以被C++ invok调用 signal sayHelloTo(name) //自定义信号2，带参数。可以被C++ invok调用。参数的名字要起好，后面通过这个名字来使用参数 function rotateToAngle(angle) //自定义js函数，旋转至指定角度。可以被C++ invok调用。 &#123; rotation = angle return true; &#125; &#125; ...&#125; 那么在C++ 中访问的方式是： 如果用QQuickView加载qml，就是 1234QQuickView view;...QObject *centerObj = view.rootObject()-&gt;findChild&lt;QObject *&gt;(\"centerRect\");if (!centerObj) &#123; return;&#125; 如果用QQmlEngine加载qml，就是1234QQmlEngine engine;...QObject *centerObj = engine.rootObject()-&gt;findChild&lt;QObject *&gt;(\"centerRect\");if (!centerObj) &#123; return;&#125; (QObject类型也可以换成QQuickItem 或者其它) 拿到了对象指针，接下来就好办了 访问其属性 1bool canSee = centerObj-&gt;property(\"canSee\").toBool(); 发射其信号(其实就是函数调用) 12QObject::invokeMethod(centerObj, \"sayHello\");QObject::invokeMethod(centerObj, \"sayHelloTo\", Q_ARG(QString, \"Tao\")) 调用其js函数,可以传参数过去,可以取得返回值 12bool ok;QObject::invokeMethod(centerObj, \"rotateToAngle\", Q_RETURN_ARG(bool, ok), Q_ARG(qreal 180)); 这里再补充一下, Qml中给自定义的信号写槽或连接到别的槽(Qml中的槽就是js函数): 12345678910111213141516171819202122232425262728293031Item &#123; id: root ... Rectangle &#123; id: centerRect objectName: \"centerRect\" //必不可少的objectName signal sayHello() //自定义信号1 signal sayHelloTo(name) //自定义信号2，带参数。参数的名字要起好，后面通过这个名字来使用参数 function rotateToAngle(angle) //自定义js函数，旋转至指定角度 &#123; rotation = angle &#125; onSayHello: &#123; //信号1的槽 console.log(\"hello\") &#125; onSayHelloTo: &#123; //信号2的槽，直接用信号定义时的参数名字name作为关键字访问参数 console.log(\"hello\", name) &#125; Component.onCompleted: &#123; //信号2 连接到 root的函数。参数会自动匹配。 sayHello.connect(root.rootSayHello) &#125; &#125; ... function rootSayHello(name) &#123; console.log(\"root: hello\", name) &#125;&#125; QQmlComponentC++中的QQmlComponent可以用来动态加载Qml文件，并可以创建多个实例， 对应Qml中的Component。Qml中还有一个Loader，也可以动态加载并创建单个实例。 (QQmlComponent这种方式不太多见，不过涛哥之前参与过开发一个框架，使用的就是QQmlComponent动态加载Qml， 完全在c++中控制界面的加载，加载效率、内存占用上都比纯Qml优秀。) 来看一个例子： 1234567// Circle.qmlRectangle &#123; width: 300 height: width radius: width / 2 color: \"red\"&#125; 123456QQmlEngine engine;QQmlComponent component(&amp;engine, QUrl::fromLocalFile(\"Circle.qml\"));QObject *circleObject = component.create();QQuickItem *item = qobject_cast&lt;QQuickItem*&gt;(circleObject);int width = item-&gt;width(); 拿到对象指针，就和前面的一样了，这里不再赘述了。 Qml访问C++Qml要访问C++的内容，需要先从C++把要访问的内容注册进Qml。 先说说能用哪些： 注册过后，Qml中可以访问的内容，包括 Q_INVOKABLE 修饰的函数、枚举、 QObject的属性 信号 槽 Q_INVOKABLE 函数可以用在普通的结构体或者类中，但是这种用法不常见/不方便。常见的是在QObject的子类中，给非槽函数设置为Q_INVOKABLE 枚举的注册Qt帮助文档很详细，而且5.10以后可以在qml中定义枚举了，这里涛哥就不展开了。 QObject的属性 信号 槽，都是可以通过注册后，在qml中使用的。信号、槽都可以带参数，槽可以有返回值。 1234567891011121314151617class BrotherTao : public QObject &#123; Q_OBJECT //这个宏一定要写上。不写可能的后果是，moc生成失败，信号 槽实现不了，编译过不了。 Q_PROPERTY(QString name READ name WRITE setName NOTIFY nameChanged) //自定义属性，操作包括： 读、写和通知。Qml可以读写、获取通知public: ... //唱歌 Q_INVOKABLE void sing(); //invok函数，可以被Qml调用。可以带参数和返回值public slots: //打游戏，参数为次数，返回值为得分。 int playGame(int count); //槽函数，可以被Qml调用。可以带参数和返回值signals: //肚子饿了。参数为想吃的东西。 void hungry(const QString &amp;foodName); //信号，可以被Qml接收。 ...&#125;; 这里要说的是，属性、函数参数、返回值的类型，都需要是Qml能识别的类型。 Qt的常用类型已经在Qt内部注册好了，自定义的需要单独注册。 再说说怎么用： 注册分为两种：注册类型和注册实例。 注册类并使用1qmlRegisterTyle&lt;BrotherTao&gt;(\"BrotherTao\",1, 0, \"BrotherTao\"); 123456789101112131415161718192021222324252627import BrotherTao 1.0Item &#123; BrotherTao &#123; //实例化一个对象 id: tao onHungry: &#123; //给信号写个槽函数 if (foodName === \"蛋炒饭\") &#123; //示意一下，不要在意吃啥。 console.log(\"涛哥要吃蛋炒饭\") &#125; else if (foodName === \"水饺\") &#123; console.log(\"涛哥要吃水饺\") &#125; &#125; &#125; ... Button &#123; onClicked: &#123; //这个按钮按下的时候，涛哥开始唱歌 tao.sing(); &#125; &#125; Button &#123; onClicked: &#123; //这个按钮按下的时候，涛哥开始打游戏 let score = tao.sing(3); console.log(\"涛哥打游戏次数\"， 3， \"得分为\", score) &#125; &#125;&#125; 注册实例并使用1234567891011BrotherTao tao; //C++中创建的实例//如果用QQ'u'ic'kView加载QmlQQuickView view;...view.rootContext()-&gt;setContextProperty(\"tao\", &amp;tao); //注意这个名字不要用大写字母开头，规则和Qml中的id不能用大写字母开头一样。//如果用QQmlEngine加载QmlQQmlEngine engine;...engine..rootContext()-&gt;setContextProperty(\"tao\", &amp;tao); //注意这个名字不要用大写字母开头，规则和Qml中的id不能用大写字母开头一样。 123456789101112131415161718192021222324252627//这种不用再import了Item &#123; Connections &#123; //通过connectins连接信号 target: tao //指定target onHungry: &#123; //给信号写个槽函数 if (foodName === \"蛋炒饭\") &#123; //示意一下，不要在意吃啥。 console.log(\"涛哥要吃蛋炒饭\") &#125; else if (foodName === \"水饺\") &#123; console.log(\"涛哥要吃水饺\") &#125; &#125; &#125; ... Button &#123; onClicked: &#123; //这个按钮按下的时候，涛哥开始唱歌 tao.sing(); &#125; &#125; Button &#123; onClicked: &#123; //这个按钮按下的时候，涛哥开始打游戏 let score = tao.sing(3); console.log(\"涛哥打游戏次数\"， 3， \"得分为\", score) &#125; &#125;&#125;","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(4)-I18n动态国际化","slug":"玩转Qml(4)-I18n动态国际化","date":"2019-05-12T15:44:23.000Z","updated":"2020-12-25T09:56:59.601Z","comments":true,"path":"2019/05/12/玩转Qml(4)-I18n动态国际化/","link":"","permalink":"https://jaredtao.github.io/2019/05/12/%E7%8E%A9%E8%BD%ACQml(4)-I18n%E5%8A%A8%E6%80%81%E5%9B%BD%E9%99%85%E5%8C%96/","excerpt":"","text":"简介 效果预览 源码中输出中文 Qt本身的国际化 翻译工作 实现动态翻译 加载翻译文件 Qml中切换语言 多国语言版本 简介本文是《玩转Qml》系列文章的第四篇，涛哥将教大家，如何在Qml中实现动态国际化。 i18n 是 internationalization(国际化) 的首尾字符加中间的 18 个字符。随着产品越做越大，要推向国际的时候，国际化这一步 是必不可少的。i18n 的方案有很多，这里只讨论在Qt/Qml中的方案。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 效果预览看一下最终效果 目前支持的语言包括： 中文 英文 日文 韩文 法文 俄文 德文 西班牙文 葡萄牙文 意大利文 越南文 阿拉伯文 (其中阿拉伯文是从右往左写的，qml默认的处理看起来不完全正确。 涛哥对阿拉伯也不是很熟，就不深入研究了。) 源码中输出中文先说一下源码中输出中文的问题。 在文件本身的编码是utf-8的前提下，以下三种方式都可以直接输出中文。 1qInfo() &lt;&lt; u8\"山有木兮木有枝，心悦君兮君不知。\"; 1qInfo() &lt;&lt; QStringLiteral(\"黄河远上白云间，一片孤城万仞山。\"); 1qInfo() &lt;&lt; QString::fromLocal8Bit(\"人生若只如初见，何事秋风悲画扇。\"); u8是c++11标准支持的字符串字面量写法，可以参考https://zh.cppreference.com/w/cpp/language/string_literal QStringLiteral是Qt特有的宏，用来在编译期生成字符串字面量，效果和u8类似。 QString::fromLocal8Bit可以在运行过程中，动态处理中文字符串。 Qt本身的国际化Qt的国际化, 相关文章太多了，Qt帮助文档也有，涛哥这里列出重点 C++代码中的字符串使用QObject::tr()包起来，类本身是QObject的子类时可以省略作用域“QObject::”,直接写tr qml代码中使用qsTr把字符串包起来 pro文件中添加一句TRANSLATIONS += trans_zh.qs ，这个名字起什么无所谓，关键是‘_zh’要有。 调用lrelease工具,扫描项目并生成trans_zh.qs 文件。这个文件是xml格式的，未经过翻译的，需要为这个文件做一些翻译工作。后面说怎么做翻译。 翻译做好后，调用lupdate工具，生成trans_zh.qm文件。这个文件就是把xml变成了二进制。 将qm文件放在运行路径，或者资源文件里。 切换语言时， Qt/C++代码中使用QTranslater加载qm文件，QCoreApplication卸载旧的QTranslater，并安装新的QTranslater。调用QmlEngine::retranslate函数 在5.10以前的版本，Qt是不能直接动态切换语言的，要么重新启动程序，要么把所有的text都set一遍，retranslate是5.10才有的接口。 涛哥这次的方案，以retranslate为主，5.10以前还有各路大神的动态切换语言方案，不在本次文章的讨论范围。 翻译工作Qt提供了可视化的工具，即QTDIR/bin路径下的linguist.exe，可以直接打开我们拿到的trans_zh.qs文件。这个工具可以由程序员之外不懂xml的专业翻译人士使用。 涛哥在这里就使用自动化的翻译工具来做这个事情，比如使用 百度翻译API 或 有道翻译API。 为此，涛哥使用go语言写了一个小工具，能接入百度和有道的翻译API，并且能读取Qt的qs文件、完成翻译后再写回qs文件。 小工具已经开源 Qt-Transer 当然这种小工具Qt也能做，涛哥使用go纯属兴趣。 实现动态翻译加载翻译文件需要在Qt/C++代码中实现，并提供给qml调用。这里以中文和英文为例，涛哥直接写在了自定义QQuivkView的代码里。 123456789101112131415//TaoView.hclass TaoView : public QQuickView&#123; Q_OBJECTpublic: explicit TaoView(QWindow *parent = nullptr); Q_INVOKABLE void reTrans(const QString &amp;lang); //这是通过invokable导出的函数public slots:private: QTranslator m_enTrans; //英文的翻译 QTranslator m_zhTrans; //中文的翻译 QString m_lang; //记录当前语言&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243// TaoView.cpp#include \"stdafx.h\"#include \"TaoView.h\"#include &lt;QTranslator&gt;#include &lt;QQmlEngine&gt;TaoView::TaoView(QWindow *parent) : QQuickView(parent)&#123; setFlag(Qt::FramelessWindowHint); setResizeMode(SizeRootObjectToView); setColor(QColor(Qt::transparent)); //构造函数直接加载翻译文件 bool ok = m_enTrans.load(\"trans_en.qm\"); bool ok2 = m_zhTrans.load(\"trans_zh.qm\"); qWarning() &lt;&lt; ok &lt;&lt; ok2; //默认安装中文 QCoreApplication::installTranslator(&amp;m_zhTrans); m_lang = QStringLiteral(\"中文简体\");&#125;void TaoView::reTrans(const QString &amp;lang)&#123; if (m_lang == lang) &#123; return; &#125; //切换语言 m_lang = lang; if ( lang == QStringLiteral(\"中文简体\")) &#123; QCoreApplication::removeTranslator(&amp;m_enTrans); QCoreApplication::installTranslator(&amp;m_zhTrans); engine()-&gt;retranslate(); &#125; else if (lang == \"English\") &#123; QCoreApplication::removeTranslator(&amp;m_zhTrans); QCoreApplication::installTranslator(&amp;m_enTrans); engine()-&gt;retranslate(); &#125;&#125; Qml中切换语言和文章3 Qml组件化编程3-动态切换皮肤 类似, 在标题栏按钮中做一个切换按钮 123456789101112131415161718192021222324252627282930313233// TitleBar.qmlTImageBtn &#123; width: 20 height: 20 anchors.verticalCenter: parent.verticalCenter imageUrl: containsMouse ? \"qrc:/Image/Window/lang_white.png\" : \"qrc:/Image/Window/lang_gray.png\" onClicked: &#123; pop.show() &#125; TPopup &#123; id: pop barColor: gConfig.reserverColor backgroundWidth: 100 backgroundHeight: 80 contentItem: ListView &#123; id: langListView anchors.fill: parent anchors.margins: 2 model: [\"中文简体\", \"English\"] //语言列表，这里不需要qsTr delegate: TTextBtn &#123; width: langListView.width height: 36 text: modelData color: containsMouse ? \"lightgray\" : pop.barColor onClicked: &#123; pop.hide() //调用Q_INVOKABLE导出的函数，reTrans view.reTrans(modelData) &#125; &#125; &#125; &#125;&#125; 多国语言版本前面的代码只有中文和英文，已经可以说明问题了。 这里再把最终版本的多国语言的贴出来。 这是头文件 12345678910111213141516171819202122232425262728//TaoView.h#pragma once#include &lt;QQuickView&gt;#include &lt;memory&gt;class TaoView : public QQuickView&#123; Q_OBJECT Q_PROPERTY(QStringList languageList READ languageList NOTIFY languageListChanged)public: explicit TaoView(QWindow *parent = nullptr); Q_INVOKABLE void reTrans(const QString &amp;lang); const QStringList &amp;languageList() const &#123; return m_languageList; &#125;signals: void reTransed(); void languageListChanged();private: QString m_lang; QMap&lt;QString, std::shared_ptr&lt;QTranslator&gt;&gt; m_transMap; QTranslator *m_pLastLang = nullptr; QStringList m_languageList;&#125;; 这是cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//TaoView.cpp#include \"stdafx.h\"#include \"TaoView.h\"#include &lt;QTranslator&gt;#include &lt;QQmlEngine&gt;TaoView::TaoView(QWindow *parent) : QQuickView(parent)&#123; setFlag(Qt::FramelessWindowHint); setResizeMode(SizeRootObjectToView); setColor(QColor(Qt::transparent)); m_languageList &lt;&lt; u8\"中文简体\" &lt;&lt; u8\"English\" &lt;&lt; u8\"日本語\" &lt;&lt; u8\"한국어\" &lt;&lt; u8\"Français\" &lt;&lt; u8\"Español\" &lt;&lt; u8\"Portugués\" &lt;&lt; u8\"In Italiano\" &lt;&lt; u8\"русский язык\" &lt;&lt; u8\"Tiếng Việt\" &lt;&lt; u8\"Deutsch\" &lt;&lt; u8\" عربي ، \"; QStringList fileList; fileList &lt;&lt; \"trans_zh.qm\" &lt;&lt; \"trans_en.qm\" &lt;&lt; \"trans_ja.qm\" &lt;&lt; \"trans_ko.qm\" &lt;&lt; \"trans_fr.qm\" &lt;&lt; \"trans_es.qm\" &lt;&lt; \"trans_pt.qm\" &lt;&lt; \"trans_it.qm\" &lt;&lt; \"trans_ru.qm\" &lt;&lt; \"trans_vi.qm\" &lt;&lt; \"trans_de.qm\" &lt;&lt; \"trans_ar.qm\"; for (auto i = 0; i &lt; m_languageList.length(); ++i) &#123; auto trans = std::make_shared&lt;QTranslator&gt;(); bool ok = trans-&gt;load(fileList.at(i)); qWarning() &lt;&lt; m_languageList.at(i) &lt;&lt; fileList.at(i) &lt;&lt; ok; m_transMap[m_languageList.at(i)] = trans; &#125; m_pLastLang = m_transMap[m_languageList.at(0)].get(); QCoreApplication::installTranslator(m_pLastLang); m_lang = m_languageList.at(0); emit languageListChanged();&#125;void TaoView::reTrans(const QString &amp;lang)&#123; if (m_lang == lang) &#123; return; &#125; m_lang = lang; QCoreApplication::removeTranslator(m_pLastLang); m_pLastLang = m_transMap[lang].get(); QCoreApplication::installTranslator(m_pLastLang); engine()-&gt;retranslate(); emit reTransed();&#125; 还有qml 123456789101112131415161718192021222324252627282930313233.... TImageBtn &#123; width: 20 height: 20 anchors.verticalCenter: parent.verticalCenter imageUrl: containsMouse ? \"qrc:/Image/Window/lang_white.png\" : \"qrc:/Image/Window/lang_gray.png\" onClicked: &#123; pop.show() &#125; TPopup &#123; id: pop barColor: gConfig.reserverColor backgroundWidth: 100 backgroundHeight: 400 contentItem: ListView &#123; id: langListView anchors.fill: parent anchors.margins: 2 model: view.languageList //这里换成了list属性 delegate: TTextBtn &#123; width: langListView.width height: 36 text: modelData color: containsMouse ? \"lightgray\" : pop.barColor onClicked: &#123; pop.hide() view.reTrans(modelData) &#125; &#125; &#125; &#125; &#125;....","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(3)-换皮肤","slug":"玩转Qml(3)-换皮肤","date":"2019-05-12T04:44:23.000Z","updated":"2020-12-25T09:56:42.490Z","comments":true,"path":"2019/05/12/玩转Qml(3)-换皮肤/","link":"","permalink":"https://jaredtao.github.io/2019/05/12/%E7%8E%A9%E8%BD%ACQml(3)-%E6%8D%A2%E7%9A%AE%E8%82%A4/","excerpt":"","text":"简介 效果预览 必要的基础 QObject自定义属性 全局单例 实现 皮肤的配置和原理 皮肤选择器 带三角形尖尖的弹窗组件 简介本文是《玩转Qml》系列文章的第三篇，涛哥将教大家，如何在Qml中实现动态换皮肤。顺带会分享一些Qt小技巧。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 效果预览效果类似于网易云音乐 顺便说一下，这是涛哥创建的TaoQuick项目，后续的各种组件、效果会全部集中在这个项目里。 文章中涉及的代码，都会先贴出来。整个工程的代码，在积累到一定程度后，会开放在github上。 必要的基础可能有读者会疑惑，涛哥前两篇文章还在讲如何封装基础组件，这第三篇直接就来换皮肤？是不是跨度有点大？ 其实换皮肤是一个很基础的功能，如果要做最好在项目初期就做起来，后期想要做换皮肤会困难一些（工作量大）。 如果你的项目做了很多组件化的封装，再做换皮肤会轻松一些。 QObject自定义属性Qml中有一个类型叫QtObject，涛哥非常喜欢使用这个类型。 以前在写Qt/C++代码中的自定义QObject时，经常需要写一些自定义的Q_PROPERTY,以及实现set、get函数、change信号 如果纯手工写，挺累人的，涛哥曾写过自动生成器，相信很多人也写过类似的工具。 后来涛哥发现，QtCreator有自动生成的功能，只要写上Q_PROPERTY那一行，再用右键菜单生成即可， 高效率人士也可以使用快捷键，光标放在Q_PROPERTY上，按Alt + Enter。 有时候需要把set函数的参数改成const T &amp;类型来减少内存拷贝，并把函数实现移动到cpp文件中。(这都是C++的诟病) 然而，在Qml中，有更加方便的QtObject, 123456789101112131415161718192021Item &#123; QtObject &#123; //定义一个QtObject，相当于Qt/c++代码中的QObject id: dataObj property string name: \"Hello\" //这就定义了一个string类型的属性name，初始值设为\"Hello\" //定义完了，已经自带了onNameChanged信号。name被重新赋值时会触发信号 //给这个信号写一个处理函数，就相当于连接上了槽函数。 onNameChanged: &#123; console.info(\"name:\", name) &#125; &#125; ... Button &#123; ... onClicked: &#123; //演示: 按钮按下时，修改前面QtObject的name属性 dataObj.name = \"World\"; &#125; &#125; ...&#125; (哈哈，工作量和心理负担一下子减轻了很多，头发的数量也能保住了。再也不想回去写Qt/C++的属性了。) 全局单例涛哥写了一个单独的qml文件，顶层就是一个QtObject类型，里面会有一大堆属性。 颜色、字体一类的配置都在这里。 123456789// GlobalConfig.qmlimport QtQuick 2.0QtObject &#123; property color titleBackground: \"#c62f2f\" //标题栏的背景色 property color background: \"#f6f6f6\" //标题栏之外的部分的背景色 property color reserverColor: \"#ffffff\" //与背景色相反的对比色 property color textColor: \"black\" //文本颜色 &#125; 然后在main.qml中实例化它 123456789// main.qmlItem &#123; width: 800 height: 600 GlobalConfig &#123; id: gConfig &#125; ...&#125; Qml有个特性，子页面实例可以通过id访问父页面中的实例，读 写其属性、调用其函数。 在main.qml中实例化的对象，相当于是全局的了，它的id是可以在所有main.qml的子页面中访问到的。 （当然还有一种方式，通过qmldir指定单例，这种留着后面再说） 实现皮肤的配置和原理下面是TaoQuick中使用的gConfig 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// GlobalConfig.qmlQtObject &#123; property color titleBackground: \"#c62f2f\" property color background: \"#f6f6f6\" property color reserverColor: \"#ffffff\" property color textColor: \"black\" property color splitColor: \"gray\" property int currentTheme: 0 onCurrentThemeChanged: &#123; var t = themes.get(currentTheme) titleBackground = t.titleBackground background = t.background textColor = t.textColor &#125; readonly property ListModel themes: ListModel &#123; ListElement &#123; name: qsTr(\"一品红\") titleBackground: \"#c62f2f\" background: \"#f6f6f6\" textColor: \"#5c5c5c\" &#125; ListElement &#123; name: qsTr(\"高冷黑\") titleBackground: \"#191b1f\" background: \"#222225\" textColor: \"#adafb2\" &#125; ListElement &#123; name: qsTr(\"淑女粉\") titleBackground: \"#faa0c5\" background: \"#f6f6f6\" textColor: \"#5c5c5c\" &#125; ListElement &#123; name: qsTr(\"富贵金\") titleBackground: \"#fed98f\" background: \"#f6f6f6\" textColor: \"#5c5c5c\" &#125; ListElement &#123; name: qsTr(\" 清爽绿\") titleBackground: \"#58c979\" background: \"#f6f6f6\" textColor: \"#5c5c5c\" &#125; ListElement &#123; name: qsTr(\"苍穹蓝\") titleBackground: \"#67c1fd\" background: \"#f6f6f6\" textColor: \"#5c5c5c\" &#125; &#125;&#125; 涛哥在所有的Page页面中，相关颜色设置都绑定到gConfig的相应属性上。 那么换皮肤，只需要修改gConfig中的颜色相关属性即可。因为修改属性时会触发change信号，而所有的Page都绑定了 gConfig的属性，会自动在发生change时重新读属性，修改后的颜色自动就生效了。 这里顺带说一下，主题的颜色相关属性越少越好，因为太多了不容易识别、不好维护， 之前的文章《玩转Qml(1)-从按钮开始》中提到的Qt.lighter和Qt.darker, 就是一种减少颜色属性数量的神器。 皮肤选择器再来看一下，涛哥参考 网易云音乐 做的皮肤选择器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869TImageBtn &#123; //图片按钮，参考文章1 width: 20 height: 20 anchors.verticalCenter: parent.verticalCenter imageUrl: containsMouse ? \"qrc:/Image/Window/skin_white.png\" : \"qrc:/Image/Window/skin_gray.png\" onClicked: &#123; skinBox.show() &#125; TPopup &#123; //自定义的弹窗，带三角尖尖的那个。 id: skinBox barColor: gConfig.reserverColor backgroundWidth: 280 backgroundHeight: 180 contentItem: GridView &#123; anchors.fill: parent anchors.margins: 10 model: gConfig.themes cellWidth: 80 cellHeight: 80 delegate: Item &#123; width: 80 height: 80 Rectangle &#123; //表示主题色的色块 anchors.fill: parent anchors.margins: 4 height: width color: model.titleBackground &#125; Rectangle &#123; //主题色边框，鼠标悬浮时显示 anchors.fill: parent color: \"transparent\" border.color: model.titleBackground border.width: 2 visible: a.containsMouse &#125; Text &#123; //主题名字 anchors &#123; left: parent.left bottom: parent.bottom leftMargin: 8 bottomMargin: 8 &#125; color: \"white\" text: model.name &#125; Rectangle &#123; //右下角圆圈圈，当前选中的主题 x: parent.width - width y: parent.height - height width: 20 height: width radius: width / 2 color: model.titleBackground border.width: 3 border.color: gConfig.reserverColor visible: gConfig.currentTheme === index &#125; MouseArea &#123; //鼠标状态 id: a anchors.fill: parent hoverEnabled: true onClicked: &#123; //切主题操作 gConfig.currentTheme = index &#125; &#125; &#125; &#125; &#125;&#125; 带三角形尖尖的弹窗组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// TPopup.qmlimport QtQuick 2.9import QtQuick.Controls 2.5Item &#123; id: root anchors.fill: parent property alias popupVisible: popup.visible property alias contentItem: popup.contentItem property color barColor: \"white\" property alias backgroundItem: background property real backgroundWidth: 200 property real backgroundHeight: 160 property color borderColor: barColor property real borderWidth: 0 property real verticalOffset: 20 //矩形旋转45度，一半被toolTip遮住(重合)，另一半三角形和ToolTip组成一个带箭头的ToolTip Rectangle &#123; id: bar visible: popup.visible rotation: 45 width: 16 height: 16 color: barColor //水平居中 anchors.horizontalCenter: parent.horizontalCenter //垂直方向上，由ToolTip的y值，决定位置 anchors.verticalCenter: parent.bottom anchors.verticalCenterOffset: verticalOffset &#125; Popup &#123; id: popup width: backgroundWidth height: backgroundHeight background: Rectangle &#123; id: background color: barColor radius: 8 border.color:borderColor border.width: borderWidth &#125; &#125; function show() &#123; popup.x = (root.width - popup.width) / 2 popup.y = root.height + verticalOffset popupVisible = true &#125; function hide() &#123; popupVisible = false &#125;&#125;","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(2)-可以拖动的组件","slug":"玩转Qml(2)-可以拖动的组件","date":"2019-05-11T04:22:33.000Z","updated":"2020-12-25T09:56:24.402Z","comments":true,"path":"2019/05/11/玩转Qml(2)-可以拖动的组件/","link":"","permalink":"https://jaredtao.github.io/2019/05/11/%E7%8E%A9%E8%BD%ACQml(2)-%E5%8F%AF%E4%BB%A5%E6%8B%96%E5%8A%A8%E7%9A%84%E7%BB%84%E4%BB%B6/","excerpt":"","text":"简介 拖动组件 拖动改变坐标 拖动改变大小 融合 多级组件和Qml应用的框架结构 自定义窗口 无边框 可拖动窗口 自定义标题栏 效果 简介本文是《玩转Qml》系列文章的第二篇，涛哥将教大家，如何在Qml中实现可拖动组件，通过拖动 改变组件的大小和位置；以及实现定制窗体（无边框和标题栏）, 并把拖动组件应用在顶层窗体。 源码《玩转Qml》系列文章，配套了一个优秀的开源项目:TaoQuick github https://github.com/jaredtao/TaoQuick 访问不了或者速度太慢，可以用国内的镜像网站gitee https://gitee.com/jaredtao/TaoQuick 拖动组件拖动改变坐标 拖动改变坐标的原理很简单，鼠标移动的时候改变目标Item的坐标即可。 说话的功夫，涛哥就造了个轮子出来 (其实是太常用了，涛哥已经写了很多遍) 1234567891011121314151617181920212223242526272829303132333435import QtQuick 2.9import QtQuick.Controls 2.5Item &#123; width: 800 height: 600 Rectangle &#123; id: moveItem //注意拖动目标不要使用锚布局或者Layout，而是使用相对坐标 x: 100 y: 100 width: 300 height: 200 color: \"lightblue\" MouseArea &#123; anchors.fill: parent property real lastX: 0 property real lastY: 0 onPressed: &#123; //鼠标按下时，记录鼠标初始位置 lastX = mouseX lastY = mouseY &#125; onPositionChanged: &#123; if (pressed) &#123; //鼠标按住的前提下，坐标改变时，计算偏移量，应用到目标item的坐标上即可 moveItem.x += mouseX - lastX moveItem.y += mouseY - lastY &#125; &#125; &#125; &#125;&#125; 上面例子中的MouseArea是拖动区域，Rectangle是要拖动的目标Item。 为了实现高度的可复用性，涛哥将MouseArea独立封装成一个组件,并提供一个control属性， 让外部使用组件实例的时候指定要拖动的目标。 12345678910111213141516171819202122232425262728293031// TMoveArea.qmlimport QtQuick 2.9MouseArea &#123; id: root property real lastX: 0 property real lastY: 0 property bool mask: false //有时候外面需要屏蔽拖动，导出一个mask属性， 默认false。 property var control: parent //导出一个control属性，指定要拖动的目标， 默认就用parent好了。注意目标要有x和y属性并且可修改 onPressed: &#123; lastX = mouseX; lastY = mouseY; &#125; onContainsMouseChanged: &#123; //修改一下鼠标样式，以示区别 if (containsMouse) &#123; cursorShape = Qt.SizeAllCursor; &#125; else &#123; cursorShape = Qt.ArrowCursor; &#125; &#125; onPositionChanged: &#123; if (!mask &amp;&amp; pressed &amp;&amp; control) &#123; control.x +=mouseX - lastX control.y +=mouseY - lastY &#125; &#125;&#125; TMoveArea组件的用法 1234567891011121314151617Item &#123; anchors.fill: parent Rectangle &#123; x: 100 y: 200 width: 400 height: 300 color: \"darkred\" //实例化一个MoveArea TMoveArea &#123; //指定control为parent。 其实默认就是parent，写出来示意一下 control: parent anchors.fill: parent &#125; &#125;&#125; 一般来说，将 1property var control: parent 中的var换成确切的类型比如Item会更好一些，Qml底层引擎处理var会慢一些，但是这样就限制了 目标必须是Item或者其子类。var是把双刃剑，有利有弊。涛哥后面要拖动的目标还包括QQuickView 这种类型，所以这里用var就好了。 拖动改变大小拖动改变大小，原理参考下面这张示意图： 就是在要拖动的目标Item的8个位置分别放一个拖动组件，并在拖动时计算相应的坐标和大小变化即可。 涛哥先是把TMoveArea改造成了TDragRect 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// TDragRect.qmlimport QtQuick 2.9import QtQuick.Controls 2.0Item &#123; id: root property alias containsMouse: mouseArea.containsMouse signal posChange(int xOffset, int yOffset) implicitWidth: 12 //这里隐式的宽为12 implicitHeight: 12 //这里隐式的高为12 property int posType: Qt.ArrowCursor //5.10之前, qml是不能定义枚举的，用只读的int属性代替一下。 readonly property int posLeftTop: Qt.SizeFDiagCursor readonly property int posLeft: Qt.SizeHorCursor readonly property int posLeftBottom: Qt.SizeBDiagCursor readonly property int posTop: Qt.SizeVerCursor readonly property int posBottom: Qt.SizeVerCursor readonly property int posRightTop: Qt.SizeBDiagCursor readonly property int posRight: Qt.SizeHorCursor readonly property int posRightBottom: Qt.SizeFDiagCursor MouseArea &#123; id: mouseArea anchors.fill: parent hoverEnabled: true property int lastX: 0 property int lastY: 0 onContainsMouseChanged: &#123; if (containsMouse) &#123; cursorShape = posType; &#125; else &#123; cursorShape = Qt.ArrowCursor; &#125; &#125; onPressedChanged: &#123; if (containsPress) &#123; lastX = mouseX; lastY = mouseY; &#125; &#125; onPositionChanged: &#123; if (pressed) &#123; posChange(mouseX - lastX, mouseY - lastY) &#125; &#125; &#125;&#125; 就是把前面的鼠标拖动时的处理逻辑，换成了带参数的信号发送出去，由外面决定怎么用这两个坐标 同时也定义了一组枚举，用来表示拖动区域的位置。位置不同，则鼠标样式不同。 之后涛哥写了一个叫TResizeBorder的组件，里面实例化了8个TDragRect组件，分别放在前面示意图 所示的位置，并实现了不同的处理逻辑。 (后来涛哥把上下左右四个中心点换成了四个边) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// TResizeBorder.qmlimport QtQuick 2.7Rectangle &#123; id: root color: \"transparent\" border.width: 4 border.color: \"black\" width: parent.width height: parent.height property var control: parent TDragRect &#123; posType: posLeftTop onPosChange: &#123; //不要简化这个判断条件，至少让以后维护的人能看懂。化简过后我自己都看不懂了。 if (control.x + xOffset &lt; control.x + control.width) control.x += xOffset; if (control.y + yOffset &lt; control.y + control.height) control.y += yOffset; if (control.width - xOffset &gt; 0) control.width-= xOffset; if (control.height -yOffset &gt; 0) control.height -= yOffset; &#125; &#125; TDragRect &#123; posType: posMidTop x: (parent.width - width) / 2 onPosChange: &#123; if (control.y + yOffset &lt; control.y + control.height) control.y += yOffset; if (control.height - yOffset &gt; 0) control.height -= yOffset; &#125; &#125; TDragRect &#123; posType: posRightTop x: parent.width - width onPosChange: &#123; //向左拖动时，xOffset为负数 if (control.width + xOffset &gt; 0) control.width += xOffset; if (control.height - yOffset &gt; 0) control.height -= yOffset; if (control.y + yOffset &lt; control.y + control.height) control.y += yOffset; &#125; &#125; TDragRect &#123; posType: posLeftMid y: (parent.height - height) / 2 onPosChange: &#123; if (control.x + xOffset &lt; control.x + control.width) control.x += xOffset; if (control.width - xOffset &gt; 0) control.width-= xOffset; &#125; &#125; TDragRect &#123; posType: posRightMid x: parent.width - width y: (parent.height - height) / 2 onPosChange: &#123; if (control.width + xOffset &gt; 0) control.width += xOffset; &#125; &#125; TDragRect &#123; posType: posLeftBottom y: parent.height - height onPosChange: &#123; if (control.x + xOffset &lt; control.x + control.width) control.x += xOffset; if (control.width - xOffset &gt; 0) control.width-= xOffset; if (control.height + yOffset &gt; 0) control.height += yOffset; &#125; &#125; TDragRect &#123; posType: posMidBottom x: (parent.width - width) / 2 y: parent.height - height onPosChange: &#123; if (control.height + yOffset &gt; 0) control.height += yOffset; &#125; &#125; TDragRect &#123; posType: posRightBottom x: parent.width - width y: parent.height - height onPosChange: &#123; if (control.width + xOffset &gt; 0) control.width += xOffset; if (control.height + yOffset &gt; 0) control.height += yOffset; &#125; &#125;&#125; 注意组件的顶层，使用的是透明的Rectangle，这样做的目的是，外面可以给这个组件设置 不同的颜色、边框等。无论哪种UI框架，透明处理都是需要一定的性能消耗的，所以在不需要显示 出来的情况下，组件顶层最好还是用Item替代。 融合我们来实例化一个能拖动改变大小和位置的Item 1234567891011121314151617181920Item &#123; width: 800 height: 600 Rectangle &#123; x: 300 y: 200 width: 120 height: 80 color: \"darkred\" TMoveArea &#123; anchors.fill: parent control: parent //默认就是parent，可以不写。这里写出来示意一下。 &#125; TResizeBorder &#123; control: parent //默认就是parent，可以不写。这里写出来示意一下。 anchors.fill: parent &#125; &#125;&#125; 用起来还是挺方便的，直接在目标Item里面实例化TMoveArea和TResizeBorder两个组件，作为目标Item的child， 分别指定control,就把两种功能 融合起来了。注意前后顺序，如果反过来写则TMoveArea会把TResizeBorder遮 盖住。（Qml是有z轴的，以后的文章涛哥再讲） 多级组件和Qml应用的框架结构回过头来看一下，先是封装了两个组件：TMoveArea和TDragRect，之后又封装了一个组件：TResizeBorder， 而这个TResizeBorder里面使用了多个TDragRect组件，显然是有层级结构在里面的。 涛哥把TMoveArea和TDragRect这样的最基础的组件叫做一级组件，那么TResizeBorder就是一个二级组件。 涛哥大量的实战经验后，总结出了这样一种Qml应用框架结构： 一级和二级组件可以单独做成一个插件(或者叫Qml通用库)。 实际的Qml项目，在这些基础上，做一些功能性或者业务性的组件，即三级组件。 由这些三级组件组成一堆的页面(Page)。 最终的main.qml中，只剩下Page的布局。示意图如下： 自定义窗口自定义窗口，这里以QQuickView为主。 无边框去掉边框，需要在C++中设置flag为Qt::FramelessWindowHint 同时我们注册view到qml上下文环境，给后面的功能来使用。 12345...QQuickView view;view.setFlag(Qt::FramelessWindowHint);view.rootContext()-&gt;setContextProperty(\"view\", &amp;view);... 可拖动窗口将我们前面做的两种拖动框放在main.qml中，填满顶层Item，并指定control为view。 1234567891011121314151617181920212223242526272829303132333435//main.qmlimport QtQuick 2.0#import TaoQuick 1.0 //这里是做成插件的情况下，引用了插件#import \"qrc:/Tao/Qml\" //没有做插件的情况下，只要引用qml文件的资源路径即可Item &#123; //标题栏 TitlePage &#123; id: titleRect width: root.width height: 60 ... //标题栏区域，实例化一个可以拖动位置的组件 TMoveArea &#123; height: parent.height anchors &#123; left: parent.left right: parent.right rightMargin: 170 //留一点右边距，给最小化、最大化、关闭等按钮用 &#125; //指定拖动目标为view control: view &#125; ... &#125; //实例化一个拖动改大小的组件 TResizeBorder &#123; //指定拖动目标为view control: view anchors.fill: parent &#125; ...&#125; 自定义标题栏标题栏的关键就是实现右侧的三个按钮，如果你看了《Qml组件化编程1-按钮的定制与封装》， 这都没有什么难度了。涛哥这里用图片按钮的方式实现。 注意最大化按钮在最大化状态下变成标准化按钮。 最小化：view.showMinimized() 最大化：view.showMaximized() 标准化：view.showNormal() 关闭: view.close() 这里给出关键代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Item&#123; ... property bool isMaxed: false Row &#123; id: controlButtons height: 20 anchors.verticalCenter: parent.verticalCenter anchors.right: parent.right anchors.rightMargin: 12 spacing: 10 TImageBtn &#123; width: 20 height: 20 imageUrl: containsMouse ? \"qrc:/Image/Window/minimal_white.png\" : \"qrc:/Image/Window/minimal_gray.png\" onClicked: &#123; view.showMinimized() &#125; &#125; TImageBtn &#123; width: 20 height: 20 visible: !isMaxed imageUrl: containsMouse ? \"qrc:/Image/Window/max_white.png\" : \"qrc:/Image/Window/max_gray.png\" onClicked: &#123; view.showMaximized() isMaxed = true &#125; &#125; TImageBtn &#123; width: 20 height: 20 visible: isMaxed imageUrl: containsMouse ? \"qrc:/Image/Window/normal_white.png\" : \"qrc:/Image/Window/normal_gray.png\" onClicked: &#123; view.showNormal() isMaxed = false &#125; &#125; TImageBtn &#123; width: 20 height: 20 imageUrl: containsMouse ? \"qrc:/Image/Window/close_white.png\" : \"qrc:/Image/Window/close_gray.png\" onClicked: &#123; view.close() &#125; &#125; &#125;&#125; 效果最后，我们来看一下效果吧","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qml(1)-从按钮开始","slug":"玩转Qml(1)-从按钮开始","date":"2019-05-09T15:44:23.000Z","updated":"2020-12-25T09:55:33.450Z","comments":true,"path":"2019/05/09/玩转Qml(1)-从按钮开始/","link":"","permalink":"https://jaredtao.github.io/2019/05/09/%E7%8E%A9%E8%BD%ACQml(1)-%E4%BB%8E%E6%8C%89%E9%92%AE%E5%BC%80%E5%A7%8B/","excerpt":"","text":"简介 写作背景 文章定位 我眼中的QQuick Qt版本的选择 默认按钮 Qml版本混用 按钮的本质 按钮的演变 组件化按钮 组件化图片按钮 组件化图文按钮 简介本文是《玩转Qml》系列文章的第一篇，涛哥将教大家，如何在Qml中实现各种功能的按钮， 同时也会教大家一些组件化编程的思想，如何将做好的功能封装成一个个组件，以便在工程中复用。 写作背景作者“武威的涛哥”，从2015年开始参加工作，便入手了Qml，参与了很多大大小小的Qml项目， 至今已有五年多实战经验。 2019年，涛哥决定把自己掌握的很多知识都总结整理出来，以《Qml组件化编程》系列文章的形式分享给广大Qml 爱好者和开发者。 涛哥会坚持高质量和深入浅出的原则，将文章写好，让支持涛哥的读者能够受益匪浅。 系列文章中涉及的源代码，绝大部分涛哥都会在github上开源。 如果觉得涛哥写的还不错，还请为涛哥打个赏，您的赞赏是涛哥持续创作的源泉。 有时也难免会犯一些错误，希望看到的读者能够热心指出。有任何相关的问题，也欢迎与涛 哥交流，向涛哥提出建议和意见。 感谢大家！ 文章定位涛哥写的是进阶教程，教大家如何从新手成长为高手，要理解文章中的内容，需要有一点儿Qml基础。 关于基础教程，网络上有很多，涛哥推荐以下几个质量比较高的： QmlBook QmlBook中文翻译 豆子的系列文章《Qt学习之路》 76章开始 《Qt学习之路》 豆子的文章前75章关于Widget部分也很不错。 还有一本安晓辉的书《QtQuick核心编程》 我眼中的QQuickQQuick使用Qml来描述界面，Qml是可以与html5媲美的存在，其开发效率、舒适度、描述能力和定制化能力已经远远超 过了QWidget，配合各种属性动画、粒子系统和Effects特效可以轻易做出各种酷炫、现代化的UI，不规则的图形可以通 过Painter的方式实现，对于渲染有性能要求的地方可以通过集成OpenGL、Vulkan等图形API的方式来处理。 Qml的特性是自由和灵活，这也是它的缺点，上手Qml需要一小段时间的适应，之后就会大量的造轮子，造的多了就轻车 熟路了，常见的各种二维界面或效果基本上都能造出来。 (当然Qml中也有些bug，需要一定的经验和技巧才能解决。话说回来，哪个框架没点Bug呢？) 再久一点，可以考虑考虑Qml中的设计模式（或者叫惯用手法），如何抽象出通用Qml库、如何最大程度地复用Qml 代码、如何让Qml代码更容易维护等。 Qt版本的选择Qt发布的版本有很多，一般稳妥的做法是使用LTS（长期支持版）版本的最后一个修正版本。 当前已知的LTS最新修正版本是5.9.8和5.12.3 , 涛哥会优先使用这两个版本，后续有版本 要求的地方，涛哥都会进行额外的说明。 默认按钮开始进入正题了 Qml中已经有了现成的按钮，在QtQuick.Controls模块中, 目前有两个版本: QtQuick.Controls 1.x 1.x的版本是通过style的方式进行定制 QtQuick.Controls 2.x 2.x的版本则是通过修改Control属性的方式进行定制 2.x版本的默认风格，还可以通过修改配置文件qtquickcontrols2.conf中的style来修改 可参考Qt在线文档- style配置 Qml版本混用这里顺便说一个经常有人问到的问题: 2.x版本中能否混用1.x版本的控件? 答案是可以。只需要使用别名机制即可。（如果你看过Qml的源代码，就能轻易发现这个用法） 12345678910111213141516// MixControls.qmlimport QtQuick 2.0 import QtQuick.Controls 2.0 //导入Controls 2.0模块import QtQuick.Controls 1.4 as QC14 //导入Controls 1.4模块，取别名QC14import QtQuick.Controls.Styles 1.4 as QCS14 //导入Controls.Styles 1.4模块，取别名QCS14Rectange &#123; Button &#123; //默认使用2.0的Button &#125; QC14.Button &#123; //通过别名使用1.4的Button style: QCS14.ButtonStyle &#123; //通过别名使用1.4的style &#125; &#125;&#125; 按钮的本质默认的按钮，很多时候并不能达到想要的效果，比如圆角、贴图片、渐变色的按钮等等，还需要做很多的定制化工作 其实按钮的本质，就是一个可以点击的区域(MouseArea)，附带颜色(Rectangle)、图片(Image)或文字(Text)。 涛哥教大家造第一个轮子，一个带文字的按钮。 12345678910111213141516171819202122232425262728// Taobutton.qmlimport QtQuick 2.0import QtQuick.Controls 2.0Item &#123; width: 800 height: 600 property color btnColor: \"#009688\" Rectangle &#123; width: 140 height: 40 anchors.centerIn: parent color: btnArea.pressed ? Qt.darker(btnColor, 1.2) : (btnArea.containsMouse ? Qt.lighter(btnColor, 1.2) : btnColor) Text &#123; id: btnText anchors.centerIn: parent text: qsTr(\"我是一个按钮\") &#125; MouseArea &#123; id: btnArea anchors.fill: parent hoverEnabled: true //打开悬浮 onClicked: &#123; console.log(qsTr(\"按钮被按了\")) &#125; &#125; &#125;&#125; 使用qmlscene预览一下效果 （gif录制工具不能鼠标悬浮，所以悬浮效果看不到，实际上是有悬浮效果的，可自行尝试） 说明一下，qml中有个全局的对象Qt，它有一组调颜色的函数，Qt.lighter和Qt.darker，分别可以按系数来变浅和加深 一个颜色值，这样只要有了一个颜色值，就能自动计算出深一点或者浅一点的颜色，可以减少很多配颜色的工作哦 再看一下这个表达式，当鼠标按下去的时候，使用深一点的颜色，鼠标悬浮的时候使用浅一点的颜色，其它情况就用设定的颜色 1color: btnArea.pressed ? Qt.darker(btnColor, 1.2) : (btnArea.containsMouse ? Qt.lighter(btnColor, 1.2) : btnColor) 这里的1.2是试出来的值，也可以使用其它值。 按钮的演变如果要带个边框呢？只要给Rectange设置边框的宽度和颜色就行了 1234567property color btnBorderColor: \"orange\"Rectangle &#123; ... border.width: btnArea.containsMouse ? 2 : 0 //鼠标悬浮时有宽度，才能看到边框 border.color: btnBorderColor ...&#125; 如果要圆角呢? 只要给Rectangle 设置radius就行了 12345Rectangle&#123; ... radius: 5 ...&#125; 如果要圆形呢？只要给Rectangle设置宽度和高度相等（正方形），radius是宽度的一半即可 1234567Rectangle&#123; ... width: 120 height: width radius: width / 2 ...&#125; 如果要背景色做成渐变的呢？ 123456789101112Rectangle&#123; id: gradientBtn ... property color btnColor: containsMouse ? Qt.darker(\"#009688\") : \"#009688\" color: btnColor gradient: Gradient &#123; GradientStop &#123; position: 0 ; color: Qt.darker(gradientBtn.btnColor, 1.2) &#125; GradientStop &#123; position: 0.5 ; color: Qt.darker(gradientBtn.btnColor, 1.4) &#125; GradientStop &#123; position: 1 ; color: Qt.darker(gradientBtn.btnColor, 1.6) &#125; &#125; ...&#125; 顺带提一下，5.12的Rectangle,有了新的渐变色 渐变色网站,大约有180种 可以直接在Qml中使用。 1234gradient: Gradient.NightFade //通过枚举使用gradient: \"SugarLollipop\" //通过字符串名字使用 （gif录制工具不能鼠标悬浮，所以悬浮效果看不到，实际上是有悬浮效果的，可自行尝试） 组件化按钮为了能够复用我们的按钮，需要将它做成一个组件。 这里以文本按钮为例： 1234567891011121314151617181920212223242526272829303132// TTextBtn.qmlimport QtQuick 2.9import QtQuick.Controls 2.0Rectangle &#123; id: root property alias textItem: t //导出Text实例，方便外部直接修改 property alias text: t.text //导出文本 property alias textColor: t.color //导出文本颜色 property alias containsMouse: area.containsMouse //导出鼠标悬浮 property alias containsPress: area.containsPress //导出鼠标按下 signal clicked(); //自定义点击信号 color: \"transparent\" Text &#123; id: t //默认坐标居中 anchors.centerIn: parent //默认文字对齐方式为水平和垂直居中 verticalAlignment: Text.AlignVCenter horizontalAlignment: Text.AlignHCenter //默认宽度为parent的宽度，这样字太长超出范围时自动显示省略号 width: parent.width &#125; MouseArea &#123; id: area anchors.fill: parent; hoverEnabled: parent.enabled; onClicked: root.clicked(); //点击时触发自定义点击信号 cursorShape: Qt.PointingHandCursor //悬浮或点击时的鼠标样式 &#125;&#125; Qml组件，先以最简单的方式理解，就是放在一个单独的Qml文件中，声明一些属性导出，由使用者去实例化并设置属性 比如这样: 为了和标准的组件区分开，涛哥写的组件名字都以大写的T开头。 组件化的好处，包括容易复用（如上图，多个实例都不一样）、可以统一修改（后面会有动态换皮肤的方案，依赖于组件化）、 便于维护和扩展等。后续涛哥还会讲如何做多层抽象的组件、单例组件、如何引用插件中的组件等。 组件化图片按钮带图片的按钮，只需要把Rectangle换成Image即可。 为了应对各种按钮状态，涛哥做了以下的属性扩展 12345678910111213141516171819202122232425262728293031323334353637// TImageBtn.qmlimport QtQuick 2.9import QtQuick.Controls 2.0Item &#123; id: root property url normalUrl //常规状态下的图片路径 property url hoveredUrl //悬浮 property url pressedUrl //按下 property url disabledUrl //禁用 property alias imageItem: img //直接别名导出Image实例，外面可以修改其任意属性 property alias imageUrl: img.source //别名导出图片路径 property alias imageWidth: img.width property alias imageHeight: img.height property alias imageAnchors: img.anchors property alias containsMouse: area.containsMouse property alias containsPress: area.containsPress //点击信号 signal clicked(); Image &#123; id: img anchors.fill: parent //默认按鼠标状态选取不同的图片 source: root.enabled ? (containsPress ? pressedUrl : (containsMouse ? hoveredUrl : normalUrl)) : disabledUrl &#125; MouseArea &#123; id: area anchors.fill: parent; hoverEnabled: parent.enabled; onClicked: root.clicked(); cursorShape: Qt.PointingHandCursor preventStealing: true &#125;&#125; 组件化图文按钮有了前面的文字按钮和图片按钮，我们可以做一个图片和文字都有的按钮。 图片和文字同时显示，那么就有了布局问题。图片在左？还是在右？在上？还是在下？ 涛哥这里用了点技巧，封装了一个同时支持四种布局的图文按钮 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// TImgTextBtn.qmlimport QtQuick 2.9import QtQuick.Controls 2.0Rectangle &#123; id: root property url normalUrl property url hoveredUrl property url pressedUrl property url disabledUrl property alias imageItem: img property alias imageUrl: img.source property alias imageWidth: img.width property alias imageHeight: img.height property alias textItem: t property alias text: t.text property alias textColor: t.color property alias containsMouse: area.containsMouse property alias containsPress: area.containsPress signal clicked(); //5.10以前的版本，Qml中没有枚举，用int属性代替枚举 property int layoutType: layoutImageLeft //布局类型,默认图片在左，外部可修改 readonly property int layoutImageLeft: 0 //图片在左 只读属性，代替枚举 readonly property int layoutImageRight: 1 //图片在右 只读属性，代替枚举 readonly property int layoutImageUp: 2 //图片在上 只读属性，代替枚举 readonly property int layoutImageDown: 3 //图片在下 只读属性，代替枚举 color: \"transparent\" Image &#123; id: img source: root.enabled ? (containsPress ? pressedUrl : (containsMouse ? hoveredUrl : normalUrl)) : disabledUrl &#125; Text &#123; id: t //默认文字对齐方式为水平和垂直居中 verticalAlignment: Text.AlignVCenter horizontalAlignment: Text.AlignHCenter &#125; //按布局类型 处理布局 Component.onCompleted: &#123; switch (layoutType) &#123; case layoutImageLeft: img.anchors.verticalCenter = root.verticalCenter t.anchors.verticalCenter = root.verticalCenter img.anchors.left = root.left t.anchors.left = img.right t.anchors.leftMargin = 6 break; case layoutImageRight: img.anchors.verticalCenter = root.verticalCenter t.anchors.verticalCenter = root.verticalCenter t.anchors.left = root.left img.anchors.left = t.right img.anchors.leftMargin = 6 break case layoutImageUp: img.anchors.horizontalCenter = root.horizontalCenter t.anchors.horizontalCenter = root.horizontalCenter img.anchors.top = root.top t.anchors.top = img.bottom t.anchors.topMargin = 6 break case layoutImageDown: img.anchors.horizontalCenter = root.horizontalCenter t.anchors.horizontalCenter = root.horizontalCenter t.anchors.top = root.top img.anchors.top = t.bottom img.anchors.topMargin = 6 break; &#125; &#125; MouseArea &#123; id: area anchors.fill: parent; hoverEnabled: parent.enabled; onClicked: root.clicked(); cursorShape: Qt.PointingHandCursor &#125;&#125; 最后，我们来看看效果吧","categories":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Qml","slug":"Qml","permalink":"https://jaredtao.github.io/tags/Qml/"},{"name":"QtQuick","slug":"QtQuick","permalink":"https://jaredtao.github.io/tags/QtQuick/"},{"name":"组件化编程","slug":"组件化编程","permalink":"https://jaredtao.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"玩转Qml","slug":"玩转Qml","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQml/"}]},{"title":"玩转Qt(2)-自制简易好看的日志系统","slug":"玩转Qt(2)-自制简易好看的日志系统","date":"2019-04-30T15:44:23.000Z","updated":"2020-12-25T10:04:59.945Z","comments":true,"path":"2019/04/30/玩转Qt(2)-自制简易好看的日志系统/","link":"","permalink":"https://jaredtao.github.io/2019/04/30/%E7%8E%A9%E8%BD%ACQt(2)-%E8%87%AA%E5%88%B6%E7%AE%80%E6%98%93%E5%A5%BD%E7%9C%8B%E7%9A%84%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"简介 预览 原理 html格式的log Qt的log系统 融合 文件句柄复用 多线程测试 github仓库链接 简介一个完善的软件工程，自然是少不了log系统的。 这次涛哥教大家，用最少的代码做一个轻量又好看的log系统。 涛哥知道有现成的log4cpp、log4cplus之类的，也有使用过。 这次是抱着学习的心态来造这个轮子的，造轮子的过程才能学到 更多知识，才能有进步、有提升，难道不是么？ 预览先看一下成果 原理html格式的log为了实现 “代码最少” 和 “好看” 的需求，涛哥把log写进了一个html文件。 这样的log相当于一个静态的网页，只要装有浏览器的操作系统，都可以打开并看到上面图示那样的log。 涛哥给这个html文件设计了一个固定的模板的: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;TaoLogger&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;style type=\"text/css\" id=\"logCss\"&gt; body &#123; background: #18242b; color: #afc6d1; margin-right: 20px; margin-left: 20px; font-size: 14px; font-family: Arial, sans-serif, sans; &#125; a &#123; text-decoration: none; &#125; a:link &#123; color: #a0b2bb; &#125; a:active &#123; color: #f59504; &#125; a:visited &#123; color: #adc7d4; &#125; a:hover &#123; color: #e49115; &#125; h1 &#123; text-align: center; &#125; h2 &#123; color: #ebe5e5; &#125; .d, .w, .c, .f, .i &#123; padding: 3px; overflow: auto; &#125; .d &#123; background-color: #0f1011; color: #a8c1ce; &#125; .i &#123; background-color: #294453; color: #a8c1ce; &#125; .w &#123; background-color: #7993a0; color: #1b2329; &#125; .c &#123; background-color: #ff952b; color: #1d2930; &#125; .f &#123; background-color: #fc0808; color: #19242b; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&lt;a href=\"https://jaredtao.github.io\"&gt;TaoLogger&lt;/a&gt; 日志文件&lt;/h1&gt; &lt;script type=\"text/JavaScript\"&gt; function objHide(obj) &#123; obj.style.display=\"none\" &#125; function objShow(obj) &#123; obj.style.display=\"block\" &#125; function selectType() &#123; var sel = document.getElementById(\"typeSelect\"); const hideList = new Set(['d', 'i', 'w', 'c', 'f']); if (sel.value === 'a') &#123; hideList.forEach(element =&gt; &#123; var list = document.querySelectorAll('.' + element); list.forEach(objShow); &#125;); &#125; else &#123; var ss = hideList; ss.delete(sel.value); ss.forEach(element =&gt; &#123; var list = document.querySelectorAll('.' + element); list.forEach(objHide); &#125;); var showList = document.querySelectorAll('.' + sel.value); showList.forEach(objShow); &#125; &#125; &lt;/script&gt; &lt;select id=\"typeSelect\" onchange=\"selectType()\"&gt; &lt;option value='a' selected=\"selected\"&gt;All&lt;/option&gt; &lt;option value='d'&gt;Debug&lt;/option&gt; &lt;option value='i'&gt;Info&lt;/option&gt; &lt;option value='w'&gt;Warning&lt;/option&gt; &lt;option value='c'&gt;Critical&lt;/option&gt; &lt;option value='f'&gt;Fatal&lt;/option&gt; &lt;/select&gt; （如果你不懂html，也没关系，直接拿过去用就好了） 这个模板只使用了一些很基本的html元素和css样式表，筛选器那里用了一点JavaScript。 Log模板的用法 很简单的，模板作为html文件的前面部分，接下来每一行log，以追加的方式跟在模板后面就行了。 (html的body结束标记并没有写，浏览器都能正常打开。容错性真的强！) 当然, 每一条log有个格式要求: 1&lt;div class=\"d\"&gt; 山有木兮木有枝，心悦君兮君不知。&lt;/div&gt; 就是增加了一对div标记， div的class属性要设置为d、i、w、c、f这几个字符中的一个，分别是 debug、info、warning、critical、fatal的首字母, 这正是Qt所提供的log分类。 设置div的class属性，就是给筛选器用来做筛选。 Log模板的存取 文件读取? 不，太慢了。 这就是一段固定的字符串，直接编译进代码里，程序启动的时候直接装载到内存就好了。 那么C++里面，怎么才能装下这段带有转义字符的字符串呢？涛哥的答案是：C++11的 “原始字符串字面量”或者叫 “R字符串” 可以参考这里 cppreference 简单来说，是这样写的： 1string logTemplate = R\"(xxxxxx)\"; 只要有了 R”( )” 这个写法，括号中间随便写转义字符、换行符都行。当然为了方便让编译器识别哪个 才是真正的’结束括号’，C++11标准提出了括号前后增加分隔符的写法，即: 1string logTemplate = R\"prefix(xxxxxx)prefix\"; 左括号的前面和右括号的后面, 是同样的一段字符串作为分隔符就行了。 涛哥的代码里是这么用的 12345678910111213141516namespace Logger&#123; const static QString logTemplate = u8R\"logTemplate(&lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;TaoLogger&lt;/title&gt; ... 这里省略一大堆html代码 ... )logTemplate\";&#125; Qt的log系统 Qt的log分类 Qt的打印信息，大家普遍使用的是qDebug，不过Qt除了qDebug，还有qInfo, qWarning, qCritical等等。 涛哥翻了Qt5.12的源码，发现这几个打印最终都是通过fprintf(stderr)或者fprintf(stdout)来实现输出的， 不同的地方就在于Log类型。如果要用好这个分类，那我们平时使用打印的时候，就要注意做区分: - 调试信息用qDebug - 常规信息用qInfo - 警告用qWarning - 比较严重的问题用qCritical Qt的log格式化 Qt提供了一个函数qSetMessagePattern，用来定制输出信息。 例如： 1qSetMessagePattern(\"[%&#123;time yyyyMMdd h:mm:ss.zzz t&#125; %&#123;if-debug&#125;D%&#123;endif&#125;%&#123;if-info&#125;I%&#123;endif&#125;%&#123;if-warning&#125;W%&#123;endif&#125;%&#123;if-critical&#125;C%&#123;endif&#125;%&#123;if-fatal&#125;F%&#123;endif&#125;] %&#123;file&#125;:%&#123;line&#125; - %&#123;message&#125;\"); 一般只要在main.cpp中添加这一行代码，之后的qDebug、qInfo等函数都会按照这个格式来输出，包含了 时间戳、log类型、文件名、行号 等信息。也可以不改任何代码、改环境变量来做到 Release模式信息缺失 这里有个问题，就是文件名和行号在debug模式正常，Release模式会变成空的。 要解决这个问题，那么就需要编译器提供的内置宏__FILE__ 和 __LINE__了 涛哥写了这样几个宏，代替qDebug和qInfo等函数。 1234#define LOG_DEBUG qDebug() &lt;&lt; __FILE__ &lt;&lt; __FUNCTION__ &lt;&lt; __LINE__#define LOG_INFO qInfo() &lt;&lt; __FILE__ &lt;&lt; __FUNCTION__ &lt;&lt; __LINE__#define LOG_WARN qWarning() &lt;&lt; __FILE__ &lt;&lt; __FUNCTION__ &lt;&lt; __LINE__#define LOG_CRIT qCritical() &lt;&lt; __FILE__ &lt;&lt; __FUNCTION__ &lt;&lt; __LINE__ 用法类似这样: 1LOG_DEBUG &lt;&lt; u8\"山有木兮木有枝，心悦君兮君不知。\"; Qt的写log文件 Qt还提供了一个函数 qInstallMessageHandler，可以插入一个回调函数，让每一行qDebug/qInfo等 函数的打印信息，都经过这个回调来处理。看一下帮助文档： 其实帮助文档已经提供了一个简易的log功能，涛哥就是在这个功能的基础上，做了一些定制化的修改。 融合 log存储路径和容量 涛哥写了一个函数和一组静态变量，用来设置和记录log存储的路径和容量 头文件中的声明 123456789#pragma once#include &lt;QDebug&gt;namespace Logger&#123;//默认存储路径为当前路径的Log文件夹下，默认文件数量为1024void initLog(const QString&amp; logPath = QStringLiteral(\"Log\"), int logMaxCount = 1024);&#125; // namespace Logger CPP中的实现 123456789101112131415161718192021222324252627282930313233343536namespace Logger&#123;//静态变量，记录存储路径static QString gLogDir;//静态变量，记录最大存储数量static int gLogMaxCount;void initLog(const QString &amp;logPath, int logMaxCount)&#123; //安装回调 qInstallMessageHandler(outputMessage); //记录路径 gLogDir = QCoreApplication::applicationDirPath() + \"/\" + logPath; //记录最大存储数 gLogMaxCount = logMaxCount; //检查存储文件夹，不存在则创建 QDir dir(gLogDir); if (!dir.exists()) &#123; dir.mkpath(dir.absolutePath()); &#125; //获取文件列表 QStringList infoList = dir.entryList(QDir::Files, QDir::Name); //硬盘空间有限，超过最大存储数的都删掉。 while (infoList.size() &gt; gLogMaxCount) &#123; //每次删第一个。文件名其实是默认按时间排序的，第一个就是时间最早的。 dir.remove(infoList.first()); infoList.removeFirst(); &#125;&#125;static void outputMessage(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg)&#123; //&#125;&#125; log存储 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static void outputMessage(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg)&#123; //每一条消息的约定格式。%1即log类型，%2即log内容。这里用静态变量，每次用的时候填充 //生成一个QString副本，达到最大程度的复用。 static const QString messageTemp= QString(\"&lt;div class=\\\"%1\\\"&gt;%2&lt;/div&gt;\\r\\n\"); //预定的消息类型映射表 static const char typeList[] = &#123;'d', 'w', 'c', 'f', 'i'&#125;; //锁 static QMutex mutex; //取时间 QDateTime dt = QDateTime::currentDateTime(); //时间作为文件名 //每分钟一个文件 //QString fileNameDt = dt.toString(\"yyyy-MM-dd_hh_mm\"); //每小时一个文件 QString fileNameDt = dt.toString(\"yyyy-MM-dd_hh\"); //每天一个文件 //QString fileNameDt = dt.toString(\"yyyy-MM-dd_\"); //时间戳 QString contentDt = dt.toString(\"yyyy-MM-dd hh:mm:ss\"); //消息的前面写上时间戳，后面写内容。 msg如果是用LOG_WARN那几个宏打印的，本身已经带了文件名和行号了。 QString message = QString(\"%1 %2\").arg(contentDt).arg(msg); //组装一条html格式的log QString htmlMessage = messageTemp.arg(typeList[static_cast&lt;int&gt;(type)]).arg(message); QFile file(QString(\"%1/%2_log.html\").arg(gLogDir).arg(fileNameDt)); //这里开始锁起来，多线程安全 mutex.lock(); bool exist = file.exists(); //写 | 追加的方式 file.open(QIODevice::WriteOnly | QIODevice::Append); //文件流 QTextStream text_stream(&amp;file); //注意字符编码 text_stream.setCodec(\"UTF-8\"); if (!exist) &#123; //文件不存在的情况下，先把我们的html模板写进去。 text_stream &lt;&lt; logTemplate &lt;&lt; \"\\r\\n\"; &#125; //往文件流里面追加数据 text_stream &lt;&lt; htmlMessage; file.close(); mutex.unlock(); //解锁 //把log都写到文件了，QtCreator 或者VS 不就看不到输出了？ //这里用Win32的方式多加了一次输出，当然也可以使用std::cout fprintf。不能再使用qDebug了，因为这是在qDebug的回调里，会无限递归调用的。 ::OutputDebugString(message.toStdWString().data()); ::OutputDebugString(L\"\\r\\n\");&#125; github仓库链接源代码代码去github吧。 TaoLogger","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"Log","slug":"Log","permalink":"https://jaredtao.github.io/tags/Log/"},{"name":"日志系统","slug":"日志系统","permalink":"https://jaredtao.github.io/tags/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"},{"name":"轻量级Log系统","slug":"轻量级Log系统","permalink":"https://jaredtao.github.io/tags/%E8%BD%BB%E9%87%8F%E7%BA%A7Log%E7%B3%BB%E7%BB%9F/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"玩转Qt(1)-输出彩色log","slug":"玩转Qt(1)-输出彩色log","date":"2019-04-29T15:44:23.000Z","updated":"2020-12-25T10:04:35.361Z","comments":true,"path":"2019/04/29/玩转Qt(1)-输出彩色log/","link":"","permalink":"https://jaredtao.github.io/2019/04/29/%E7%8E%A9%E8%BD%ACQt(1)-%E8%BE%93%E5%87%BA%E5%BD%A9%E8%89%B2log/","excerpt":"","text":"简介我们在Qt Creator中开发程序的时候，经常要做的一件事情，就是看程序的输出Log。一般的log信息都是黑白的，比如这样的： 涛哥在这里告诉大家一个隐藏的技能，那就是输出彩色的log: 从此看到的log，不再是黑白的，而是五颜六色的，生活更加绚丽多彩。 原理要输出彩色信息有点类似于html的语法，即在要输出的文字前加上转义字符。指令格式如下\\033[m这里的就是转义字符，例如我们要输出一段绿色的文字,则qDebug() &lt;&lt; “\\033[32m” &lt;&lt;”Hello!”;即在输出文字前，先输出一个颜色指令。注意这个指令对后续的输出都会生效，如果想关掉颜色只要再输出0号指令即可qDebug() &lt;&lt; “\\033[0m”; 这里有一个指令表 1234567891011121314151617181920212223242526272829303132333435363738 0 : Reset Color Attributes 1 : 加粗 2 : 去粗 4 : 下划线 5 : 闪烁 7 : 反色 21/22 : 加粗 正常 24 : 去掉下划线 25 : 停止闪烁 27 : 反色 30 : 前景，黑色 31 : 前景，红色 32 : 前景，绿色 33 : 前景，黄色 34 : 前景，篮色 35 : 前景，紫色 36 : 前景，青色 37 : 前景，白色 40 : 背景，黑色 41 : 背景，红色 42 : 背景，绿色 43 : 背景，黄色 44 : 背景，篮色 45 : 背景，紫色 46 : 背景，青色 47 : 背景，白色其它转义字符命令 清除屏幕 : /033c 设定水平标位置 : /033[XG X为水平标位置。 设定垂直标位置 : /033[Xd Y为垂直标位置。 /033[0K : 删除从标到该行结尾 /033[1K : 删除从该行开始到标处 /033[2K : 删除整行 /033[0J : 删除标到萤幕结尾 /033[1J : 删除从萤幕开始到标处 /033[2J : 删除整个屏幕 涛哥在QtCreator中测试了，只有颜色和加粗指令能生效。 代码（代码使用C++11标准） 为了方便、直观地使用，涛哥定义了一套枚举 12345678910111213141516171819202122232425enum class LogType &#123; Reset = 0, Bold, Unbold, FrontBlack, FrontRed, FrontGreen, FrontYellow, FrontBlue, FrontPurple, FrontCyan, FrontWhite, BackBlack, BackRed, BackGreen, BackYellow, BackBlue, BackPurple, BackCyan, BackWhite, TypeCount&#125;; 之后又写了一个指令列表，顺序和前面的枚举一一对应 123456789101112131415161718192021static const char * logCommands[] = &#123; \"\\033[0m\", \"\\033[1m\", \"\\033[2m\", \"\\033[30m\", \"\\033[31m\", \"\\033[32m\", \"\\033[33m\", \"\\033[34m\", \"\\033[35m\", \"\\033[36m\", \"\\033[37m\", \"\\033[40m\", \"\\033[41m\", \"\\033[42m\", \"\\033[43m\", \"\\033[44m\", \"\\033[45m\", \"\\033[46m\", \"\\033[47m\",&#125;; 这样就可以通过查表的方式，拿到对应的颜色指令了 1logCommands[(int)(LogType::FrontYellow)] 这个代码使用了c的强制转换，在c++11标准中会报警告，建议用static_cast。所以涛哥又写了一个转换函数,将枚举通过static_cast转换成int类型。 1234567template &lt;typename EnumType, typename IntType = int&gt;int enumToInt(EnumType enumValue)&#123; static_assert (std::is_enum&lt;EnumType&gt;::value, \"EnumType must be enum\"); return static_cast&lt;IntType&gt;(enumValue);&#125; 最后就是代码的全貌了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;QDebug&gt;enum class LogType &#123; Reset = 0, Bold, Unbold, FrontBlack, FrontRed, FrontGreen, FrontYellow, FrontBlue, FrontPurple, FrontCyan, FrontWhite, BackBlack, BackRed, BackGreen, BackYellow, BackBlue, BackPurple, BackCyan, BackWhite, TypeCount&#125;;static const char * logCommands[] = &#123; \"\\033[0m\", \"\\033[1m\", \"\\033[2m\", \"\\033[30m\", \"\\033[31m\", \"\\033[32m\", \"\\033[33m\", \"\\033[34m\", \"\\033[35m\", \"\\033[36m\", \"\\033[37m\", \"\\033[40m\", \"\\033[41m\", \"\\033[42m\", \"\\033[43m\", \"\\033[44m\", \"\\033[45m\", \"\\033[46m\", \"\\033[47m\",&#125;;template &lt;typename EnumType, typename IntType = int&gt;int enumToInt(EnumType enumValue)&#123; static_assert (std::is_enum&lt;EnumType&gt;::value, \"EnumType must be enum\"); return static_cast&lt;IntType&gt;(enumValue);&#125;int main(int argc, char *argv[])&#123; for (int i = enumToInt(LogType::Bold); i &lt; enumToInt(LogType::TypeCount); ++i) &#123; qInfo().nospace() &lt;&lt; logCommands[i] &lt;&lt; i &lt;&lt; \" Hello World\" &lt;&lt; logCommands[0]; &#125; qWarning() &lt;&lt; logCommands[enumToInt(LogType::FrontBlue)] &lt;&lt; logCommands[enumToInt(LogType::BackRed)] &lt;&lt; u8\"感谢大家对涛哥系列文章的支持，也\" \"欢迎直接联系我寻求帮助\" &lt;&lt; logCommands[0]; return 0;&#125; 顺便说一下，设置了console的工程不能显示出彩色，得把console去掉。","categories":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"https://jaredtao.github.io/tags/Qt/"},{"name":"彩色log","slug":"彩色log","permalink":"https://jaredtao.github.io/tags/%E5%BD%A9%E8%89%B2log/"}],"keywords":[{"name":"玩转Qt","slug":"玩转Qt","permalink":"https://jaredtao.github.io/categories/%E7%8E%A9%E8%BD%ACQt/"}]},{"title":"涛哥博客杂谈","slug":"涛哥博客杂谈","date":"2019-04-29T12:44:23.000Z","updated":"2020-11-10T04:11:32.854Z","comments":true,"path":"2019/04/29/涛哥博客杂谈/","link":"","permalink":"https://jaredtao.github.io/2019/04/29/%E6%B6%9B%E5%93%A5%E5%8D%9A%E5%AE%A2%E6%9D%82%E8%B0%88/","excerpt":"","text":"欢迎来到涛哥的博客。 涛哥在这里主要发布技术相关的文章、教程，偶尔也会分享一些奇思妙想。 涛哥出生于甘肃-武威-凉州，属于西凉人士。 目前在上海工作，从事Qt相关的软件开发，主要使用C++做为开发工具， 特别是Qt/Qml已经使用有五年多(偶尔也会使用C#、golang、js、java等) 已经积攒了很多的经验，现在准备整理并分享出来，一方面是想构建自己的知识体系， 另一方面也希望能帮助到其他需要的人。在这个过程中，涛哥会努力做到 抽丝剥茧、深入浅出，揭露事物的本质。有时候也难免会犯一些错误，希望 看到的读者能够热心指出。有任何相关的问题，也欢迎与涛哥 交流，向涛哥提出建议和意见。 时间轴2019-4-29 涛哥博客正式开通","categories":[{"name":"涛哥的博客","slug":"涛哥的博客","permalink":"https://jaredtao.github.io/categories/%E6%B6%9B%E5%93%A5%E7%9A%84%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客说明","slug":"博客说明","permalink":"https://jaredtao.github.io/tags/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"},{"name":"大事记","slug":"大事记","permalink":"https://jaredtao.github.io/tags/%E5%A4%A7%E4%BA%8B%E8%AE%B0/"}],"keywords":[{"name":"涛哥的博客","slug":"涛哥的博客","permalink":"https://jaredtao.github.io/categories/%E6%B6%9B%E5%93%A5%E7%9A%84%E5%8D%9A%E5%AE%A2/"}]}]}